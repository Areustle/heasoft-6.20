#include <iostream>
#include <sstream>
#include <string>
#include "hoops/hoops.h"
#include "hoops/hoops_limits.h"

static int sStatus = hoops::P_OK;
static const int ERROR_UNDETECTED =  + 1;

int SetGlobalStatus (int status) {
  using namespace hoops;
  if (P_OK == sStatus) {
    if (P_OK == status) sStatus = ERROR_UNDETECTED;
    else sStatus = status;
  }
  return sStatus;
}

int main() {
  using namespace hoops;
  const char *code[1024];

  for (int ii = 0; ii < 1024; ++ii) code[ii] = "";
  code[P_OK] = "P_OK";
  code[P_ILLEGAL] = "P_ILLEGAL";
  code[P_OVERFLOW] = "P_OVERFLOW";
  code[P_UNDERFLOW] = "P_UNDERFLOW";
  code[P_BADSIZE] = "P_BADSIZE";
  code[P_PRECISION] = "P_PRECISION";
  code[P_SIGNEDNESS] = "P_SIGNEDNESS";
  code[P_STR_OVERFLOW] = "P_STR_OVERFLOW";
  code[P_STR_INVALID] = "P_STR_INVALID";
  code[P_STR_NULL] = "P_STR_NULL";
  code[P_UNEXPECTED] = "P_UNEXPECTED";
  code[ERROR_UNDETECTED] = "ERROR_UNDETECTED";

  std::cout.precision(32);
  std::cerr.precision(32);

  // Declare one variable for each primitive type's maximum.
  const bool max_bool = Lim<bool>::max();
  const char max_char = Lim<char>::max();
  const signed char max_signed_char = Lim<signed char>::max();
  const short max_short = Lim<short>::max();
  const int max_int = Lim<int>::max();
  const long max_long = Lim<long>::max();
  const unsigned char max_unsigned_char = Lim<unsigned char>::max();
  const unsigned short max_unsigned_short = Lim<unsigned short>::max();
  const unsigned int max_unsigned_int = Lim<unsigned int>::max();
  const unsigned long max_unsigned_long = Lim<unsigned long>::max();
  const float max_float = Lim<float>::max();
  const double max_double = Lim<double>::max();
  const long double max_long_double = Lim<long double>::max();

  // Declare one variable for each primitive type's minimum.
  const bool min_bool = Lim<bool>::min();
  const char min_char = Lim<char>::min();
  const signed char min_signed_char = Lim<signed char>::min();
  const short min_short = Lim<short>::min();
  const int min_int = Lim<int>::min();
  const long min_long = Lim<long>::min();
  const unsigned char min_unsigned_char = Lim<unsigned char>::min();
  const unsigned short min_unsigned_short = Lim<unsigned short>::min();
  const unsigned int min_unsigned_int = Lim<unsigned int>::min();
  const unsigned long min_unsigned_long = Lim<unsigned long>::min();
  const float min_float = Lim<float>::min();
  const double min_double = Lim<double>::min();
  const long double min_long_double = Lim<long double>::min();

  // Declare one variable for each primitive type's scratch value.
  bool tmp_bool;
  char tmp_char;
  signed char tmp_signed_char;
  short tmp_short;
  int tmp_int;
  long tmp_long;
  unsigned char tmp_unsigned_char;
  unsigned short tmp_unsigned_short;
  unsigned int tmp_unsigned_int;
  unsigned long tmp_unsigned_long;
  float tmp_float;
  double tmp_double;
  long double tmp_long_double;

  // Status variable, used to test success of each conversion.
  int status = P_OK;

  // Declare one variable of each Prim type, and initialize them to maximum.
  IPrim * hd_prim_bool = 0;
  IPrim * hd_prim_char = 0;
  IPrim * hd_prim_signed_char = 0;
  IPrim * hd_prim_short = 0;
  IPrim * hd_prim_int = 0;
  IPrim * hd_prim_long = 0;
  IPrim * hd_prim_unsigned_char = 0;
  IPrim * hd_prim_unsigned_short = 0;
  IPrim * hd_prim_unsigned_int = 0;
  IPrim * hd_prim_unsigned_long = 0;
  IPrim * hd_prim_float = 0;
  IPrim * hd_prim_double = 0;
  IPrim * hd_prim_long_double = 0;

  IPrim * hd_prim_std_string = 0;

  // Catch-all try block:
  try {
    PrimFactory factory;
    hd_prim_bool = factory.NewIPrim(Lim<bool>::max());
    hd_prim_char = factory.NewIPrim(Lim<char>::max());
    hd_prim_signed_char = factory.NewIPrim(Lim<signed char>::max());
    hd_prim_short = factory.NewIPrim(Lim<short>::max());
    hd_prim_int = factory.NewIPrim(Lim<int>::max());
    hd_prim_long = factory.NewIPrim(Lim<long>::max());
    hd_prim_unsigned_char = factory.NewIPrim(Lim<unsigned char>::max());
    hd_prim_unsigned_short = factory.NewIPrim(Lim<unsigned short>::max());
    hd_prim_unsigned_int = factory.NewIPrim(Lim<unsigned int>::max());
    hd_prim_unsigned_long = factory.NewIPrim(Lim<unsigned long>::max());
    hd_prim_float = factory.NewIPrim(Lim<float>::max());
    hd_prim_double = factory.NewIPrim(Lim<double>::max());
    hd_prim_long_double = factory.NewIPrim(Lim<long double>::max());

    // Test whether construction from maximum value worked
    {
      bool tmp_bool;
      hd_prim_bool->To(tmp_bool);
      if (Lim<bool>::max() != tmp_bool) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_bool has value " << hd_prim_bool << ", not " << Lim<bool>::max() << std::endl;
       }
    }
    {
      char tmp_char;
      hd_prim_char->To(tmp_char);
      if (Lim<char>::max() != tmp_char) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_char has value " << hd_prim_char << ", not " << Lim<char>::max() << std::endl;
       }
    }
    {
      signed char tmp_signed_char;
      hd_prim_signed_char->To(tmp_signed_char);
      if (Lim<signed char>::max() != tmp_signed_char) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_signed_char has value " << hd_prim_signed_char << ", not " << Lim<signed char>::max() << std::endl;
       }
    }
    {
      short tmp_short;
      hd_prim_short->To(tmp_short);
      if (Lim<short>::max() != tmp_short) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_short has value " << hd_prim_short << ", not " << Lim<short>::max() << std::endl;
       }
    }
    {
      int tmp_int;
      hd_prim_int->To(tmp_int);
      if (Lim<int>::max() != tmp_int) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_int has value " << hd_prim_int << ", not " << Lim<int>::max() << std::endl;
       }
    }
    {
      long tmp_long;
      hd_prim_long->To(tmp_long);
      if (Lim<long>::max() != tmp_long) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_long has value " << hd_prim_long << ", not " << Lim<long>::max() << std::endl;
       }
    }
    {
      unsigned char tmp_unsigned_char;
      hd_prim_unsigned_char->To(tmp_unsigned_char);
      if (Lim<unsigned char>::max() != tmp_unsigned_char) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_unsigned_char has value " << hd_prim_unsigned_char << ", not " << Lim<unsigned char>::max() << std::endl;
       }
    }
    {
      unsigned short tmp_unsigned_short;
      hd_prim_unsigned_short->To(tmp_unsigned_short);
      if (Lim<unsigned short>::max() != tmp_unsigned_short) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_unsigned_short has value " << hd_prim_unsigned_short << ", not " << Lim<unsigned short>::max() << std::endl;
       }
    }
    {
      unsigned int tmp_unsigned_int;
      hd_prim_unsigned_int->To(tmp_unsigned_int);
      if (Lim<unsigned int>::max() != tmp_unsigned_int) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_unsigned_int has value " << hd_prim_unsigned_int << ", not " << Lim<unsigned int>::max() << std::endl;
       }
    }
    {
      unsigned long tmp_unsigned_long;
      hd_prim_unsigned_long->To(tmp_unsigned_long);
      if (Lim<unsigned long>::max() != tmp_unsigned_long) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_unsigned_long has value " << hd_prim_unsigned_long << ", not " << Lim<unsigned long>::max() << std::endl;
       }
    }
    {
      float tmp_float;
      hd_prim_float->To(tmp_float);
      if (Lim<float>::max() != tmp_float) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_float has value " << hd_prim_float << ", not " << Lim<float>::max() << std::endl;
       }
    }
    {
      double tmp_double;
      hd_prim_double->To(tmp_double);
      if (Lim<double>::max() != tmp_double) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_double has value " << hd_prim_double << ", not " << Lim<double>::max() << std::endl;
       }
    }
    {
      long double tmp_long_double;
      hd_prim_long_double->To(tmp_long_double);
      if (Lim<long double>::max() != tmp_long_double) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: Immediately after creation, hd_prim_long_double has value " << hd_prim_long_double << ", not " << Lim<long double>::max() << std::endl;
       }
    }

    // At this point, each Prim variable contains the maximum value for
    // its underlying type. Try converting each one to each type of
    // C++ primitive variable. This should cause a maximum number of
    // overflows and no underflows.
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_bool) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_char) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_char) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_short) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_short) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_int) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_int) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_long) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_long) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_float) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_float) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_double) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_double) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_bool << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_bool) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_char) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_char) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_short) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_short) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_int) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_int) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_long) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_long) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_float) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_float) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_double) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_double) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_char << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_bool) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_char) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_char) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_short) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_short) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_int) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_int) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_long) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_long) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_float) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_float) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_double) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_double) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_signed_char << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_bool) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_char) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_char) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_short) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_short) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_int) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_int) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_long) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_long) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_float) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_float) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_double) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_double) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_short << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_bool) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_char) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_char) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_short) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_short) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_int) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_int) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_long) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_long) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_float) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_float) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_double) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_double) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_int << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_bool) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_char) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_char) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_short) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_short) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_int) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_int) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_long) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_long) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_float) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_float) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_double) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_double) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_char << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_short << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_int << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_long << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_bool) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_char) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_short) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_short) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_int) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_int) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_long) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_long) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_float) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_float) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_double) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_double) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_float << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_bool) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_char) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_short) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_short) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_int) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_int) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_long) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_long) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_float) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_float) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_double) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_double) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_double << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_bool) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_char) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_short) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_short) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_int) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_int) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_long) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_long) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_float) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_float) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_double) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_double) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double->To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long_double << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }

    // Try to set each Prim variable to the minimum value for its underlying type.
    hd_prim_bool->From(Lim<bool>::min());
    hd_prim_char->From(Lim<char>::min());
    hd_prim_signed_char->From(Lim<signed char>::min());
    hd_prim_short->From(Lim<short>::min());
    hd_prim_int->From(Lim<int>::min());
    hd_prim_long->From(Lim<long>::min());
    hd_prim_unsigned_char->From(Lim<unsigned char>::min());
    hd_prim_unsigned_short->From(Lim<unsigned short>::min());
    hd_prim_unsigned_int->From(Lim<unsigned int>::min());
    hd_prim_unsigned_long->From(Lim<unsigned long>::min());
    hd_prim_float->From(Lim<float>::min());
    hd_prim_double->From(Lim<double>::min());
    hd_prim_long_double->From(Lim<long double>::min());


    // At this point, each Prim variable contains the minimum value for
    // its underlying type. Try converting each one to each type of
    // C++ primitive variable. This should cause a maximum number of
    // underflows and no overflows.
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((bool) tmp_bool != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((char) tmp_bool != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_char) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_char) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((signed char) tmp_bool != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((short) tmp_bool != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_short) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_short) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((int) tmp_bool != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_int) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_int) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((long) tmp_bool != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_long) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_long) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((unsigned char) tmp_bool != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((unsigned short) tmp_bool != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((unsigned int) tmp_bool != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((unsigned long) tmp_bool != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((float) tmp_bool != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_float) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_float) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((double) tmp_bool != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_double) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_double) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if ((long double) tmp_bool != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_bool << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((bool) tmp_char != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((char) tmp_char != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_char) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_char) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((signed char) tmp_char != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((short) tmp_char != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_short) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_short) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((int) tmp_char != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_int) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_int) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((long) tmp_char != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_long) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_long) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((unsigned char) tmp_char != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((unsigned short) tmp_char != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((unsigned int) tmp_char != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((unsigned long) tmp_char != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((float) tmp_char != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_float) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_float) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((double) tmp_char != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_double) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_double) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if ((long double) tmp_char != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_char << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((bool) tmp_signed_char != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((char) tmp_signed_char != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_char) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_char) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((signed char) tmp_signed_char != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((short) tmp_signed_char != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_short) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_short) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((int) tmp_signed_char != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_int) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_int) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((long) tmp_signed_char != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_long) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_long) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((unsigned char) tmp_signed_char != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((unsigned short) tmp_signed_char != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((unsigned int) tmp_signed_char != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((unsigned long) tmp_signed_char != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((float) tmp_signed_char != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_float) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_float) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((double) tmp_signed_char != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_double) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_double) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if ((long double) tmp_signed_char != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_signed_char << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((bool) tmp_short != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((char) tmp_short != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_char) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_char) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((signed char) tmp_short != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((short) tmp_short != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_short) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_short) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((int) tmp_short != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_int) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_int) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((long) tmp_short != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_long) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_long) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((unsigned char) tmp_short != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((unsigned short) tmp_short != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((unsigned int) tmp_short != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((unsigned long) tmp_short != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((float) tmp_short != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_float) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_float) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((double) tmp_short != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_double) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_double) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if ((long double) tmp_short != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_short << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((bool) tmp_int != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((char) tmp_int != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_char) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_char) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((signed char) tmp_int != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((short) tmp_int != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_short) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_short) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((int) tmp_int != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_int) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_int) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((long) tmp_int != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_long) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_long) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((unsigned char) tmp_int != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((unsigned short) tmp_int != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((unsigned int) tmp_int != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((unsigned long) tmp_int != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((float) tmp_int != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_float) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_float) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((double) tmp_int != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_double) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_double) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if ((long double) tmp_int != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_int << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((bool) tmp_long != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((char) tmp_long != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_char) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_char) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((signed char) tmp_long != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((short) tmp_long != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_short) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_short) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((int) tmp_long != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_int) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_int) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((long) tmp_long != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_long) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_long) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((unsigned char) tmp_long != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((unsigned short) tmp_long != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((unsigned int) tmp_long != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((unsigned long) tmp_long != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((float) tmp_long != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_float) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_float) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((double) tmp_long != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_double) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_double) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if ((long double) tmp_long != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_long << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((bool) tmp_unsigned_char != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((char) tmp_unsigned_char != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_char) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((signed char) tmp_unsigned_char != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((short) tmp_unsigned_char != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_short) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((int) tmp_unsigned_char != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_int) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((long) tmp_unsigned_char != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_long) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((unsigned char) tmp_unsigned_char != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((unsigned short) tmp_unsigned_char != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((unsigned int) tmp_unsigned_char != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((unsigned long) tmp_unsigned_char != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((float) tmp_unsigned_char != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_float) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((double) tmp_unsigned_char != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_double) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if ((long double) tmp_unsigned_char != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_unsigned_char << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((bool) tmp_unsigned_short != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((char) tmp_unsigned_short != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_char) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((signed char) tmp_unsigned_short != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((short) tmp_unsigned_short != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_short) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((int) tmp_unsigned_short != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_int) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((long) tmp_unsigned_short != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_long) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((unsigned char) tmp_unsigned_short != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((unsigned short) tmp_unsigned_short != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((unsigned int) tmp_unsigned_short != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((unsigned long) tmp_unsigned_short != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((float) tmp_unsigned_short != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_float) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((double) tmp_unsigned_short != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_double) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if ((long double) tmp_unsigned_short != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_unsigned_short << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((bool) tmp_unsigned_int != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((char) tmp_unsigned_int != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_char) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((signed char) tmp_unsigned_int != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((short) tmp_unsigned_int != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_short) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((int) tmp_unsigned_int != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_int) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((long) tmp_unsigned_int != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_long) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((unsigned char) tmp_unsigned_int != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((unsigned short) tmp_unsigned_int != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((unsigned int) tmp_unsigned_int != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((unsigned long) tmp_unsigned_int != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((float) tmp_unsigned_int != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_float) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((double) tmp_unsigned_int != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_double) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if ((long double) tmp_unsigned_int != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_unsigned_int << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((bool) tmp_unsigned_long != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((char) tmp_unsigned_long != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_char) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((signed char) tmp_unsigned_long != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((short) tmp_unsigned_long != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_short) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((int) tmp_unsigned_long != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_int) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((long) tmp_unsigned_long != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_long) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((unsigned char) tmp_unsigned_long != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((unsigned short) tmp_unsigned_long != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((unsigned int) tmp_unsigned_long != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((unsigned long) tmp_unsigned_long != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((float) tmp_unsigned_long != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_float) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((double) tmp_unsigned_long != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_double) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if ((long double) tmp_unsigned_long != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_unsigned_long << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((bool) tmp_float != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((char) tmp_float != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_char) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((signed char) tmp_float != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((short) tmp_float != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_short) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_short) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((int) tmp_float != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_int) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_int) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((long) tmp_float != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_long) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_long) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((unsigned char) tmp_float != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((unsigned short) tmp_float != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((unsigned int) tmp_float != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((unsigned long) tmp_float != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((float) tmp_float != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_float) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_float) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((double) tmp_float != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_double) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_double) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if ((long double) tmp_float != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((bool) tmp_double != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((char) tmp_double != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_char) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((signed char) tmp_double != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((short) tmp_double != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_short) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_short) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((int) tmp_double != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_int) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_int) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((long) tmp_double != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_long) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_long) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((unsigned char) tmp_double != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((unsigned short) tmp_double != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((unsigned int) tmp_double != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((unsigned long) tmp_double != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((float) tmp_double != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_float) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_float) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((double) tmp_double != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_double) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_double) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if ((long double) tmp_double != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((bool) tmp_long_double != tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((char) tmp_long_double != tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_char) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((signed char) tmp_long_double != tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((short) tmp_long_double != tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_short) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_short) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((int) tmp_long_double != tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_int) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_int) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((long) tmp_long_double != tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_long) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_long) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((unsigned char) tmp_long_double != tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((unsigned short) tmp_long_double != tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((unsigned int) tmp_long_double != tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((unsigned long) tmp_long_double != tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((float) tmp_long_double != tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_float) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_float) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((double) tmp_long_double != tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_double) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_double) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if ((long double) tmp_long_double != tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }

    // Try to assign each Prim variable a value which can be converted
    // to all types without throwing an exception, namely, 1.
    hd_prim_bool->From(Lim<bool>::max());
    hd_prim_char->From(Lim<bool>::max());
    hd_prim_signed_char->From(Lim<bool>::max());
    hd_prim_short->From(Lim<bool>::max());
    hd_prim_int->From(Lim<bool>::max());
    hd_prim_long->From(Lim<bool>::max());
    hd_prim_unsigned_char->From(Lim<bool>::max());
    hd_prim_unsigned_short->From(Lim<bool>::max());
    hd_prim_unsigned_int->From(Lim<bool>::max());
    hd_prim_unsigned_long->From(Lim<bool>::max());
    hd_prim_float->From(Lim<bool>::max());
    hd_prim_double->From(Lim<bool>::max());
    hd_prim_long_double->From(Lim<bool>::max());


    // At this point, each Prim variable contains the value 1
    // Try converting each one to each type of C++ primitive variable.
    // This should lead to a minimum of exceptions.
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_char) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_short) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_int) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_long) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_float) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_double) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          bool tmp_bool;
          hd_prim_bool->To(tmp_bool);
          if (tmp_bool != (bool) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_bool->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_bool->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<bool>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_bool << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_char) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_short) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_int) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_long) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_float) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_double) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          char tmp_char;
          hd_prim_char->To(tmp_char);
          if (tmp_char != (char) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_char << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<char>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_char << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_char) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_short) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_int) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_long) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_float) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_double) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          signed char tmp_signed_char;
          hd_prim_signed_char->To(tmp_signed_char);
          if (tmp_signed_char != (signed char) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_signed_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_signed_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<signed char>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_signed_char << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_char) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_short) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_int) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_long) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_float) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_double) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          short tmp_short;
          hd_prim_short->To(tmp_short);
          if (tmp_short != (short) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_short << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<short>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_short << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_char) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_short) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_int) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_long) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_float) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_double) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          int tmp_int;
          hd_prim_int->To(tmp_int);
          if (tmp_int != (int) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_int << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<int>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_int << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_char) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_short) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_int) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_long) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_float) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_double) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long tmp_long;
          hd_prim_long->To(tmp_long);
          if (tmp_long != (long) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_long << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<long>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_long << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned char tmp_unsigned_char;
          hd_prim_unsigned_char->To(tmp_unsigned_char);
          if (tmp_unsigned_char != (unsigned char) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_char->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_char->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_char << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned short tmp_unsigned_short;
          hd_prim_unsigned_short->To(tmp_unsigned_short);
          if (tmp_unsigned_short != (unsigned short) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_short->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_short->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_short << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned int tmp_unsigned_int;
          hd_prim_unsigned_int->To(tmp_unsigned_int);
          if (tmp_unsigned_int != (unsigned int) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_int->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_int->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_int << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_char) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_short) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_int) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_long) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_float) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_double) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          unsigned long tmp_unsigned_long;
          hd_prim_unsigned_long->To(tmp_unsigned_long);
          if (tmp_unsigned_long != (unsigned long) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_unsigned_long->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_unsigned_long->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_unsigned_long << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_short) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_int) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_long) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_float) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_double) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_float->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_float->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<float>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_float << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_short) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_int) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_long) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_float) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_double) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<double>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_double << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_bool;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_bool - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<bool>::round_error())
            maxdiff = Lim<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_bool) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_char;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_char - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<char>::round_error())
            maxdiff = Lim<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_char) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_signed_char;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_signed_char - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<signed char>::round_error())
            maxdiff = Lim<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_signed_char) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_short) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_short;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_short - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<short>::round_error())
            maxdiff = Lim<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_short) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_int) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_int;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_int - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<int>::round_error())
            maxdiff = Lim<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_int) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_long) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<long>::round_error())
            maxdiff = Lim<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_long) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_char;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_char - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned char>::round_error())
            maxdiff = Lim<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_char) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_short;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_short - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned short>::round_error())
            maxdiff = Lim<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_short) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_int;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_int - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned int>::round_error())
            maxdiff = Lim<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_int) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_unsigned_long;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_unsigned_long - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<unsigned long>::round_error())
            maxdiff = Lim<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_unsigned_long) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_float) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_float;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_float - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<float>::round_error())
            maxdiff = Lim<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_float) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_double) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_double;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_double - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<double>::round_error())
            maxdiff = Lim<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_double) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_PRECISION:
        {
          long double difference;
          try {
            hd_prim_long_double->To(difference);
          } catch (const Hexception & x) {}
          difference -= tmp_long_double;
          if (0. > difference) {
            try {
              hd_prim_long_double->To(difference);
            } catch (const Hexception & x) {}
            difference = tmp_long_double - difference;
          }
          long double maxdiff = Lim<long double>::round_error();
          if (maxdiff < Lim<long double>::round_error())
            maxdiff = Lim<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double->To(tmp_long_double) rounded incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }

    // Assign Prim floating types a non-integral value, and
    // confirm that it converts correctly to all types.

    hd_prim_float->From(1 + Lim<float>::epsilon());
    hd_prim_double->From(1 + Lim<float>::epsilon());
//    hd_prim_long_double = 1 + Lim<float>::epsilon();
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<bool>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_bool) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_bool;
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<char>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_char) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_char;
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<signed char>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_signed_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_signed_char;
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_short) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<short>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_short) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_short;
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_int) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<int>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_int) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_int;
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_long) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_long) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_long;
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned char>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_unsigned_char;
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned short>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_unsigned_short;
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned int>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_unsigned_int;
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned long>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_unsigned_long;
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_float) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<float>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_float) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_float) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_float;
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_double) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<double>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_double) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_double;
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          float tmp_float;
          hd_prim_float->To(tmp_float);
          if (tmp_float != (float) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_float << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long double>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_long_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_float << " to " << tmp_long_double;
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<bool>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_bool) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_bool;
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<char>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_char) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_char;
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<signed char>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_signed_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_signed_char;
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_short) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<short>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_short) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_short;
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_int) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<int>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_int) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_int;
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_long) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_long) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_long;
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned char>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_unsigned_char;
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned short>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_unsigned_short;
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned int>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_unsigned_int;
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned long>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_unsigned_long;
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_float) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<float>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_float) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_float) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_float;
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_double) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<double>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_double) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_double;
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          double tmp_double;
          hd_prim_double->To(tmp_double);
          if (tmp_double != (double) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_double << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long double>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_long_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_double << " to " << tmp_long_double;
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_bool) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_bool) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_bool;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<bool>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_bool) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_bool) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_bool;
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<char>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_char) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_char;
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_signed_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_signed_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_signed_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<signed char>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_signed_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_signed_char) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_signed_char;
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_short) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<short>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_short) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_short;
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_int) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<int>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_int) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_int;
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_long) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_long) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_long;
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_char) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_char) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_char;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned char>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_char) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_unsigned_char;
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_short) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_short) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_short;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned short>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_short) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_unsigned_short;
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_int) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_int) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_int;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned int>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_int) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_unsigned_int;
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_unsigned_long) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_long) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_unsigned_long;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned long>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_unsigned_long) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_unsigned_long;
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_float) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_float) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_float;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<float>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_float) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_float) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_float;
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_double) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<double>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_double) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_double;
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double->To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        {
          long double tmp_long_double;
          hd_prim_long_double->To(tmp_long_double);
          if (tmp_long_double != (long double) tmp_long_double) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_long_double) converted incorrectly from " <<
                *hd_prim_long_double << " to " << tmp_long_double;
            if (P_OK != status)
              std::cerr << std::endl << "and threw a " <<
                  code[status] << " exception";
            std::cerr << "." << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long double>::GetCode()) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_long_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double->To(tmp_long_double) converted incorrectly from " <<
              *hd_prim_long_double << " to " << tmp_long_double;
        }
        break;
    }
    std::string tmp_std_string = "A non-numeric string";
    hd_prim_std_string = factory.NewIPrim(tmp_std_string);
    if (hd_prim_std_string->StringData().compare(tmp_std_string)) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: After initialization from std::string, hd_prim_char is " << *hd_prim_std_string << ", not " << tmp_std_string << std::endl;
    }
    try {
      hd_prim_std_string->To(tmp_bool);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_bool) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to bool, hd_prim_std_string->To(tmp_bool) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_char);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_char) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to char, hd_prim_std_string->To(tmp_char) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_signed_char);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_signed_char) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to signed_char, hd_prim_std_string->To(tmp_signed_char) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_short);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_short) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to short, hd_prim_std_string->To(tmp_short) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_int);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_int) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to int, hd_prim_std_string->To(tmp_int) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_long);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_long) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to long, hd_prim_std_string->To(tmp_long) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_unsigned_char);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_unsigned_char) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to unsigned_char, hd_prim_std_string->To(tmp_unsigned_char) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_unsigned_short);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_unsigned_short) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to unsigned_short, hd_prim_std_string->To(tmp_unsigned_short) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_unsigned_int);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_unsigned_int) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to unsigned_int, hd_prim_std_string->To(tmp_unsigned_int) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_unsigned_long);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_unsigned_long) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to unsigned_long, hd_prim_std_string->To(tmp_unsigned_long) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_float);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_float) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to float, hd_prim_std_string->To(tmp_float) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_double);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_double) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to double, hd_prim_std_string->To(tmp_double) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    try {
      hd_prim_std_string->To(tmp_long_double);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_std_string->To(tmp_long_double) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to long_double, hd_prim_std_string->To(tmp_long_double) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    tmp_bool = 1;
    try {
      hd_prim_std_string->From(tmp_bool);
      if (hd_prim_std_string->StringData().compare("true")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from bool, hd_prim_std_string->From(tmp_bool) converted incorrectly from " << tmp_bool << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from bool, hd_prim_std_string->From(tmp_bool) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_char = 1;
    try {
      hd_prim_std_string->From(tmp_char);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from char, hd_prim_std_string->From(tmp_char) converted incorrectly from " << tmp_char << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from char, hd_prim_std_string->From(tmp_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_signed_char = 1;
    try {
      hd_prim_std_string->From(tmp_signed_char);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from signed_char, hd_prim_std_string->From(tmp_signed_char) converted incorrectly from " << tmp_signed_char << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from signed_char, hd_prim_std_string->From(tmp_signed_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_short = 1;
    try {
      hd_prim_std_string->From(tmp_short);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from short, hd_prim_std_string->From(tmp_short) converted incorrectly from " << tmp_short << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from short, hd_prim_std_string->From(tmp_short) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_int = 1;
    try {
      hd_prim_std_string->From(tmp_int);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from int, hd_prim_std_string->From(tmp_int) converted incorrectly from " << tmp_int << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from int, hd_prim_std_string->From(tmp_int) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_long = 1;
    try {
      hd_prim_std_string->From(tmp_long);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from long, hd_prim_std_string->From(tmp_long) converted incorrectly from " << tmp_long << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from long, hd_prim_std_string->From(tmp_long) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_char = 1;
    try {
      hd_prim_std_string->From(tmp_unsigned_char);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from unsigned_char, hd_prim_std_string->From(tmp_unsigned_char) converted incorrectly from " << tmp_unsigned_char << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from unsigned_char, hd_prim_std_string->From(tmp_unsigned_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_short = 1;
    try {
      hd_prim_std_string->From(tmp_unsigned_short);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from unsigned_short, hd_prim_std_string->From(tmp_unsigned_short) converted incorrectly from " << tmp_unsigned_short << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from unsigned_short, hd_prim_std_string->From(tmp_unsigned_short) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_int = 1;
    try {
      hd_prim_std_string->From(tmp_unsigned_int);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from unsigned_int, hd_prim_std_string->From(tmp_unsigned_int) converted incorrectly from " << tmp_unsigned_int << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from unsigned_int, hd_prim_std_string->From(tmp_unsigned_int) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_long = 1;
    try {
      hd_prim_std_string->From(tmp_unsigned_long);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from unsigned_long, hd_prim_std_string->From(tmp_unsigned_long) converted incorrectly from " << tmp_unsigned_long << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from unsigned_long, hd_prim_std_string->From(tmp_unsigned_long) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_float = 1;
    try {
      hd_prim_std_string->From(tmp_float);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from float, hd_prim_std_string->From(tmp_float) converted incorrectly from " << tmp_float << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from float, hd_prim_std_string->From(tmp_float) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_double = 1;
    try {
      hd_prim_std_string->From(tmp_double);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from double, hd_prim_std_string->From(tmp_double) converted incorrectly from " << tmp_double << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from double, hd_prim_std_string->From(tmp_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_long_double = 1;
    try {
      hd_prim_std_string->From(tmp_long_double);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting from long_double, hd_prim_std_string->From(tmp_long_double) converted incorrectly from " << tmp_long_double << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from long_double, hd_prim_std_string->From(tmp_long_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_signed_char = 0;
    try {
      hd_prim_std_string->To(tmp_signed_char);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to signed_char, hd_prim_std_string->To(tmp_signed_char) converted incorrectly from " << tmp_signed_char << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to signed_char, hd_prim_std_string->To(tmp_signed_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_short = 0;
    try {
      hd_prim_std_string->To(tmp_short);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to short, hd_prim_std_string->To(tmp_short) converted incorrectly from " << tmp_short << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to short, hd_prim_std_string->To(tmp_short) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_int = 0;
    try {
      hd_prim_std_string->To(tmp_int);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to int, hd_prim_std_string->To(tmp_int) converted incorrectly from " << tmp_int << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to int, hd_prim_std_string->To(tmp_int) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_long = 0;
    try {
      hd_prim_std_string->To(tmp_long);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to long, hd_prim_std_string->To(tmp_long) converted incorrectly from " << tmp_long << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to long, hd_prim_std_string->To(tmp_long) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_char = 0;
    try {
      hd_prim_std_string->To(tmp_unsigned_char);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to unsigned_char, hd_prim_std_string->To(tmp_unsigned_char) converted incorrectly from " << tmp_unsigned_char << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to unsigned_char, hd_prim_std_string->To(tmp_unsigned_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_short = 0;
    try {
      hd_prim_std_string->To(tmp_unsigned_short);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to unsigned_short, hd_prim_std_string->To(tmp_unsigned_short) converted incorrectly from " << tmp_unsigned_short << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to unsigned_short, hd_prim_std_string->To(tmp_unsigned_short) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_int = 0;
    try {
      hd_prim_std_string->To(tmp_unsigned_int);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to unsigned_int, hd_prim_std_string->To(tmp_unsigned_int) converted incorrectly from " << tmp_unsigned_int << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to unsigned_int, hd_prim_std_string->To(tmp_unsigned_int) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_long = 0;
    try {
      hd_prim_std_string->To(tmp_unsigned_long);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to unsigned_long, hd_prim_std_string->To(tmp_unsigned_long) converted incorrectly from " << tmp_unsigned_long << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to unsigned_long, hd_prim_std_string->To(tmp_unsigned_long) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_float = 0;
    try {
      hd_prim_std_string->To(tmp_float);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to float, hd_prim_std_string->To(tmp_float) converted incorrectly from " << tmp_float << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to float, hd_prim_std_string->To(tmp_float) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_double = 0;
    try {
      hd_prim_std_string->To(tmp_double);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to double, hd_prim_std_string->To(tmp_double) converted incorrectly from " << tmp_double << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to double, hd_prim_std_string->To(tmp_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_long_double = 0;
    try {
      hd_prim_std_string->To(tmp_long_double);
      if (hd_prim_std_string->StringData().compare("1")) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to long_double, hd_prim_std_string->To(tmp_long_double) converted incorrectly from " << tmp_long_double << " to " << *hd_prim_std_string << std::endl;
      }
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to long_double, hd_prim_std_string->To(tmp_long_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_bool = false;
    try {
      hd_prim_std_string->To(tmp_bool);
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to bool, hd_prim_std_string->To(tmp_bool) returned incorrect code " << code[x.Code()] << std::endl;
    }
    if (true != tmp_bool) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to bool, hd_prim_std_string->To(tmp_bool) converted incorrectly from " << *hd_prim_std_string << " to " << tmp_bool << std::endl;
    }
    tmp_char = 0;
    try {
      hd_prim_std_string->To(tmp_char);
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to char, hd_prim_std_string->To(tmp_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    if (1 != tmp_char) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to char, hd_prim_std_string->To(tmp_char) converted incorrectly from " << *hd_prim_std_string << " to " << tmp_char << std::endl;
    }
    hd_prim_std_string->From(-1);
    tmp_char = 0;
    try {
      hd_prim_std_string->To(tmp_char);
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to char, hd_prim_std_string->To(tmp_char) didn't throw" << std::endl;
    } catch (const Hexception &x) {
      if (P_SIGNEDNESS != x.Code()) {
        SetGlobalStatus(P_UNEXPECTED);
        std::cerr << "ERROR: While converting to char, hd_prim_std_string->To(tmp_char) returned incorrect code " << code[x.Code()] << std::endl;
      }
    }
    if (-1 != (signed char) tmp_char) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting to char, hd_prim_std_string->To(tmp_char) converted incorrectly from " << *hd_prim_std_string << " to " << tmp_char << std::endl;
    }
    try {
      tmp_double = 0.;
      hd_prim_float->From(tmp_double);
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from 0., hd_prim_float->From(tmp_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      tmp_long_double = 0.L;
      hd_prim_float->From(tmp_long_double);
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from 0.L, hd_prim_float->From(tmp_long_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      std::ostringstream os;
      os << Lim<double>::min();
      std::string tmp_string = os.str();
      hd_prim_float->From(tmp_string);
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from string 0., hd_prim_float->From(tmp_string) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      tmp_long_double = 0.L;
      hd_prim_double->From(tmp_long_double);
    } catch (const Hexception &x) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: While converting from 0.L, hd_prim_double->From(tmp_long_double) returned incorrect code " << code[x.Code()] << std::endl;
    }

  } catch (const Hexception &x) {
    std::cerr << "An unexpected exception " << code[status] << " was caught at the top level!" << std::endl;
    SetGlobalStatus(status);
  } catch (...) {
    std::cerr << "A completely unexpected exception was caught at the top level!" << std::endl;
    SetGlobalStatus(-1);
  }

  delete hd_prim_std_string;

  delete hd_prim_long_double;
  delete hd_prim_double;
  delete hd_prim_float;
  delete hd_prim_unsigned_long;
  delete hd_prim_unsigned_int;
  delete hd_prim_unsigned_short;
  delete hd_prim_unsigned_char;
  delete hd_prim_long;
  delete hd_prim_int;
  delete hd_prim_short;
  delete hd_prim_signed_char;
  delete hd_prim_char;
  delete hd_prim_bool;

  // Final status check and report.
  if (P_OK == sStatus)
    std::cout << "Test succeeded." << std::endl;
  else
    std::cerr << "Test failed with error " << code[sStatus] << std::endl;
  return sStatus;
}
