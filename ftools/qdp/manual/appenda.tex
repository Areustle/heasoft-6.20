\chapter{COD Command summary}
\label{codcommands}

\section*{*}
Multiply the top two numbers in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> *
 10.0
\end{verbatim}

\section*{+}
Add the top two numbers in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> +
 7.0
\end{verbatim}

\section*{+LOOP}
Terminate a COD {\tt FOR} loop.
When this statement executes,
the number at the top of the stack is added to the current index.
The loop terminates when the index passes the limit value.
The \verb@+LOOP@ statement allows for loops
in which the index value can either increase or decrease.
This word can only be used in colon definitions.

\medskip
\noindent {\em Example:}
\begin{verbatim}
COD> : TMP 0 2 FOR I . -1 +LOOP ;

COD> TMP
 2.0
 1.0
 0.0

COD> : DOUBLE 100 1 FOR I . I +LOOP ;

COD> DOUBLE
 1.0
 2.0
 4.0
 8.0
 16.0
 32.0
 64.0
\end{verbatim}

\section*{+STO}
Add the previous number to the number stored
at the address given at the top of the stack.
Although it is easy to determine the address associated with a given variable,
and hence use that address directly,
it is advisable always to use a variable name
to load an address into the stack before using \verb@+STO@.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 0.0
COD> VAR TMP 5 TMP STO TMP RCL
 0.0 5.0
COD> TMP +STO
 0.0
COD> TMP RCL
 0.0 10.0
\end{verbatim}

\section*{$-$}
Subtract the top two numbers in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> -
 3.0
\end{verbatim}

\section*{.}
Print the number at the top of the stack,
and decrement stack pointer by one.
The sequence ``\verb@DUP .@'' can be inserted anywhere into COD functions
to print the number at the top of the stack.
This may help you figure out what the function is doing.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 1.0 2.0 3.0 4.0 5.0
COD> .
 5.0
 1.0 2.0 3.0 4.0
\end{verbatim}

\section*{/}
Divide the previously entered number by the number on the top of the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> /
 2.5
\end{verbatim}

\section*{/MOD}
Replace the top two numbers in the stack with the remainder
and quotient of the previous number divided by the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 23.1 10.0
COD> /MOD
 3.1  2.0
\end{verbatim}

\section*{0$<$}
Replace the top number in the stack with 1.0 if it is less than zero,
0.0 otherwise.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 -1.0
COD> 0<
 1.0
\end{verbatim}

\section*{0=}
Replace the top number in the stack with 1.0 if it equals zero,
0.0 otherwise.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 -1.0
COD> 0=
 0.0
\end{verbatim}

\section*{0$>$}
Replace the top number in the stack with 1.0 if it is greater than zero,
0.0 otherwise.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 -1.0
COD> 0>
 0.0
\end{verbatim}

\section*{1+}
Add one to the number at the top of the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 3.0 5.0
COD> 1+
 3.0 6.0
\end{verbatim}

\section*{1$-$}
Subtract one from the number at the top of the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 3.0 5.0
COD> 1-
 3.0 4.0
\end{verbatim}

\section*{1/}
Compute the inverse of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> 1/
 5.0 0.50
\end{verbatim}

\section*{2+}
Add two to the number at the top of the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 3.0 5.0
COD> 2+
 3.0 7.0
\end{verbatim}

\section*{2$-$}
Subtract two from the number at the top of the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 3.0 5.0
COD> 2-
 3.0 3.0
\end{verbatim}

\section*{:}
Begin a new colon definition.
In COD, colon definitions define new dictionary words
({\it i.e.}, new functions).
The token following the \verb@ : @
is taken to be the name of the function.
All words typed after the \verb@ : @
are compiled (stored) into memory.
A semicolon \verb@ ; @ terminates the colon definition
and returns the state from compile to execute mode.
The name of the function must not match any existing COD keyword.
The interactive {\tt COD} program does not print the stack
when the internal state is compiling
({\it i.e.}, during a colon definition).

\medskip
\noindent {\em Example:}
\begin{verbatim}
 0.0
COD> : X2 DUP * ;
 0.0
COD> 5
 0.0 5.0
COD> X2
 0.0 25.0
\end{verbatim}

\section*{;}
Terminate the current colon definition and return state from compile
to execute mode.  (See the \verb@ : @ topic for an example.)

\section*{$<$}
Replace the top two numbers in the stack with 1.0
if the previous number is less than the top number,
0.0 otherwise.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 1.0 2.0
COD> <
 1.0
\end{verbatim}

\section*{=}
Replace the top two numbers in the stack with 1.0 if the numbers are equal,
0.0 otherwise.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 1.0 2.0
COD> =
 0.0
\end{verbatim}

\section*{$>$}
Replace the top two numbers in the stack with 1.0
if the previous number is greater than the top number,
0.0 otherwise.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 1.0 2.0
COD> >
 0.0
\end{verbatim}

\section*{?}
Display the number stored at the address given at the top of the stack.
Although it is easy to determine
the address associated with a given variable,
and hence use that address directly,
it is advisable always to use a variable name
to load an address into the stack before using \verb@ ? @.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 1.0 2.0
COD> VAR TMP 5 TMP STO
 1.0 2.0
COD> TMP ?
 5.0
 1.0 2.0
\end{verbatim}

\section*{?Dup}
Duplicate the number at the top of the stack only if it is non-zero.

\medskip
\noindent {\em Examples:}
\begin{verbatim}
 5.0 0.0
COD> ?DUP
 5.0 0.0
COD> 1.0 ?DUP
 5.0 0.0 1.0 1.0
\end{verbatim}

\section*{A2tn}
Compute the arctangent assuming the top two numbers in the stack
represent an $x$,$y$ pair.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 1.0 2.0
COD> A2tn
 1.570796
\end{verbatim}

\section*{ABOrt}
Reset the stack pointer.
This deletes all numbers in the stack
and can be very useful in the interactive mode to clean out the stack.
If this command occurs when a COD function is executing,
the function exits and a {\tt NO} data function value is returned.

\section*{ABS}
Take the absolute value of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 -2.0
COD> ABS
 5.0 2.0
\end{verbatim}

\section*{ACos}
Computer the arccosine (in radians) of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 0.5
COD> ACos
 5.0 1.047198
\end{verbatim}

\section*{ALog}
Compute 10. raised to the power of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> ALog
 5.0 100.0
\end{verbatim}

\section*{ASin}
Compute the arcsine (in radians) of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 0.5
COD> ASin
 5.0 0.5235988
\end{verbatim}

\section*{ATan}
Compute the arctangent (in radians) of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 0.5
COD> ATan
 5.0 0.4636476
\end{verbatim}

\section*{BEGIN}
Begin a {\tt BEGIN\ldots UNTIL}
or a {\tt BEGIN\ldots WHILE\ldots REPEAT} structure.
See either the {\tt UNTIL} or {\tt WHILE} topics for examples of use.
This word can only be used in colon definitions.

\section*{COS}
Compute the cosine of the top number (in radians) in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 0.5
COD> COS
 5.0 0.8775826
\end{verbatim}

\section*{DDms}
Convert a number in decimal degrees to the form DDDMMSS.S .

\medskip
\noindent {\em Example:}
\begin{verbatim}
 12.5
COD> DDms
 123000.0
\end{verbatim}

\section*{DEPth}
Leave the number of values contained in the stack
(not counting the result).

\medskip \noindent {\em Example:}
\begin{verbatim}
 5.0 4.0
COD> DEP
 5.0 4.0 2.0
\end{verbatim}

\section*{DMsd}
Convert a number of the form DDDMMSS.S to decimal degrees.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 123000.0
COD> DMsd
 12.5
\end{verbatim}

\section*{DRop}
Drop the stack pointer so that the number at the top of the stack is lost.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 4.0
COD> DRop
 5.0
\end{verbatim}

\section*{DTor}
Convert decimal degrees to radians.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 90.0
COD> DTor
 5.0 1.570796
\end{verbatim}

\section*{DUP}
Duplicate the number on the top of the stack
(equivalent to \, {\tt 1~PICK}).

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> DUP
 5.0 2.0 2.0
\end{verbatim}

\section*{ELSE}
If the condition was false when the {\tt IF} statement executed,
then transfer control to the first statement following the {\tt ELSE}.
If the condition was true,
then the function executes code down to the {\tt ELSE} statement
and then skips to the first statement following the {\tt THEN} statement.
This statement must be preceded by an {\tt IF} statement.
This word can only be used in colon definitions.
See the IF topic for an example.

\section*{EXIT}
Immediately terminate the current colon function.
Since the stack is unaffected,
check to verify that the stack is left in the same state
no matter how the colon function is terminated
(otherwise obscure and nasty bugs result).
This word can only be used in colon definitions.

\section*{EXP}
Compute the exponential of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 1.0
COD> EXP
 5.0 2.718282
\end{verbatim}

\section*{FOR}
Set up a {\tt FOR\ldots LOOP} or a {\tt FOR\ldots +LOOP} structure
using the top two numbers in the stack to denote the range.
The index for the {\tt FOR} loop is an {\tt INTEGER*2},
hence the maximum value is 32767.
This word can only be used in colon definitions.

\medskip
\noindent {\em Example:}
\begin{verbatim}
COD> : TMP 4 1 FOR I . LOOP ;

COD> TMP
 1.0
 2.0
 3.0
 4.0
\end{verbatim}
Warning to people who know Forth:
The COD {\tt FOR} statement is similar to the Forth {\tt DO} statement;
however, there is an important difference
concerning the two numbers that precede the {\tt FOR}\@.
In COD, these represent the upper and lower index values, respectively;
in Forth, the first number is one greater than the upper index value.

\section*{HCos}
Compute the hyperbolic cosine of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 0.5
COD> HCos
 5.0 1.127626
\end{verbatim}

\section*{HSin}
Compute the hyperbolic sine of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 0.5
COD> HSin
 5.0 0.5210953
\end{verbatim}

\section*{HTan}
Compute the hyperbolic tangent of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 0.5
COD> HTan
 5.0 0.4621172
\end{verbatim}

\section*{I}
Push the index value of the innermost {\tt FOR} loop onto the stack.
This statement can only be used inside {\tt FOR} loops inside
a colon definition.
See the {\tt FOR} topic for an example of use.

\section*{IF}
If the condition is true,
execute statements up to the corresponding {\tt ELSE} or {\tt THEN} statement.
If the condition is false,
pass control to the first statement following the {\tt ELSE} if it exists,
otherwise to the first statement following the {\tt THEN}\@.
{\tt IF} structures can be nested.
This word can only be used in colon definitions.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 X 1 <
 IF
  ! do these statements if X<1
 THEN

 X 1 >
 IF
  ! do these statements if X>1
 ELSE
  ! do these statements if X<=1
 THEN
\end{verbatim}

\section*{INT}
Compute the integer portion of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 0.9
COD> INT
 5.0 0.0
\end{verbatim}

\section*{J}
Push the index value of the next outer {\tt FOR} loop onto the stack.
This statement can only be used inside {\tt FOR} loops inside
a colon definition.

\medskip
\noindent {\em Example:}
\begin{verbatim}
COD> : TMP 2 1 FOR
COD>           5 4 FOR
COD>               J . LOOP LOOP ;

COD> TMP
 1.0
 1.0
 2.0
 2.0
\end{verbatim}

\section*{LEAVE}
Cause an immediate exit from the current loop.
No statements from the {\tt LEAVE} statement to the loop terminator
are executed.
This statement resembles the Fortran 8x EXIT statement.
{\tt LEAVE} can only be used inside {\tt FOR} loops inside
a colon definition.

\section*{LN}
Take the natural logarithm of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> LN
 5.0 0.6931472
\end{verbatim}

\section*{LOG}
Take the base-10 logarithm of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> LOG
 5.0 0.3010300
\end{verbatim}

\section*{LOOP}
Terminate a COD {\tt FOR} loop.
When this statement executes,
one is added to the current index value.
If the current index is less than or equal to the maximum index,
then control is transferred to the first statement
following the corresponding {\tt FOR} statement.
Otherwise, control passes to the statement following the {\tt LOOP} statement.
This word can only be used in colon definitions.
See the {\tt FOR} topic for an example of use.

\section*{MAX}
Replace the top two numbers in the stack with the maximum of the two numbers.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 1.0 3.0 5.0
COD> MAX
 1.0 5.0
\end{verbatim}

\section*{MIN}
Replace the top two numbers in the stack with the minimum of the two numbers.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 1.0 3.0 5.0
COD> MIN
 1.0 3.0
\end{verbatim}

\section*{MOD}
Compute the value of the previous number modulo the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 2.0 3.0
COD> MOD
 2.0
COD> ABO 3.0 3.0
 3.0 3.0
COD> MOD
 0.0
\end{verbatim}

\section*{NEG}
Negate the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> NEG
 5.0 -2.0
\end{verbatim}

\section*{NInt}
Compute the nearest integer to the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 0.9
COD> NInt
 5.0 1.0
\end{verbatim}

\section*{NOT}
Replace the top number in the stack with 1.0 if it is zero,
0.0 otherwise.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 1.0
COD> NOT
 0.0
\end{verbatim}

\section*{OVer}
Duplicate the second number on the stack
(equivalent to \, {\tt 2~PICK}).

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 4.0
COD> OVER
 5.0 4.0 5.0
\end{verbatim}

\section*{PI}
Push the value of $\pi$ into the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0
COD> PI
 5.0 3.141593
\end{verbatim}

\section*{PICK}
Duplicate the nth number on the stack (not counting n itself),
where n is the top number on the stack.
Note: {\tt 1~PICK} \, does the same thing as {\tt DUP},
and \, {\tt 2~PICK} \, does the same thing as {\tt OVER}.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 100. 200. 300. 400.
COD> 3 PICK
 100. 200. 300. 400. 200.
\end{verbatim}

\section*{RCL}
Replace the address at the top of the stack with the number at that address.
See the {\tt STO} topic for an example of how {\tt RCL} is used.

\section*{REPEAT}
Terminate a {\tt BEGIN\ldots WHILE\ldots REPEAT} loop.
When this statement executes,
control is always passed to the first statement
following the {\tt BEGIN} statement.
This word can only be used in colon definitions.
See the {\tt WHILE} topic for an example of use.

\section*{ROLL}
Rotate the nth number (not counting n itself) to the top of the stack,
where n is the top number in the stack.
Note: {\tt 2~ROLL} \, does the same thing as {\tt SWAP},
and \, {\tt 3~ROLL} \, does the same thing as {\tt ROT};
and n must be greater than 1.0.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 100. 200. 300. 400.
COD> 4 ROLL
 200. 300. 400. 100.
\end{verbatim}

\section*{ROT}
Rotate the third number to the top of the stack
(equivalent to \, {\tt 3~ROLL}).

\medskip
\noindent {\em Example:}
\begin{verbatim}
 100. 200. 300. 400.
COD> ROT
 100. 300. 400. 200.
\end{verbatim}

\section*{RTod}
Convert radians to decimal degrees.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 1.0
COD> RTod
 5.0 57.29578
\end{verbatim}

\section*{SIN}
Compute the sine of the top number (in radians) in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 0.5
COD> SIN
 5.0 0.4794255
\end{verbatim}

\section*{SQrt}
Compute the square-root of the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> SQrt
 5.0 1.414214
\end{verbatim}

\section*{STO}
Store the previous number at the address
given at the top of the stack.
Although it is easy to determine the address associated with a given variable,
and hence use that address directly,
it is advisable always to use a variable name
to load an address into the stack before using {\tt STO}.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 1.0
COD> VAR TMP
 1.0
COD> 5 TMP STO
 1.0
COD> TMP RCL
 1.0 5.0
\end{verbatim}

\section*{SWap}
Swap the top two numbers on the stack
(equivalent to \, {\tt 2~ROLL}).

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> SWap
 2.0 5.0
\end{verbatim}

\section*{TAN}
Compute the tangent of the top number (in radians) in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 0.5
COD> TAN
 5.0 0.5463025
\end{verbatim}

\section*{THEN}
Terminate an {\tt IF} structure.
This word can only be used in colon definitions.
See the {\tt IF} topic for an example of use.

\section*{TSig}
Transfer the sign of the top number in the stack
to the absolute value of the previous number.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 2.0 -5.0
COD> TSig
 -2.0
\end{verbatim}

\section*{UNTIL}
Terminate a {\tt BEGIN\ldots UNTIL} block.
{\tt UNTIL} pops one number off the stack.
If that number is false (=0.0),
the function jumps back to the first statement
following the {\tt BEGIN} statement.
Otherwise execution continues with the statement
following the {\tt UNTIL} statement.
This word can only be used in colon definitions.

\medskip
\noindent {\em Example:}
\begin{verbatim}
COD> VAR Y                ! Create variable Y

COD> : TEST 2 Y STO       ! Initialize Y to 2
COD> BEGIN
COD>   Y RCL .            ! Print the value of Y
COD>   Y RCL DUP * Y STO  ! Square it and store new value
COD>   Y RCL 1.E10 >      ! Test condition
COD> UNTIL ;

COD> TEST
 2.0
 4.0
 16.O
 256.0
 4.2949673E+9
\end{verbatim}

\section*{VAR}
Define the following token to be a new variable name.
The variable name is not allowed to match any existing COD keyword.
When that variable is used in the future,
it will cause the address of that variable to be loaded into the stack
(for use with a following {\tt STO} or {\tt RCL} command).

\medskip
\noindent {\em Example:}
\begin{verbatim}
 0.0
COD> VAR 2PI 2 PI * 2PI STO
 0.0
COD> 2PI RCL
 0.0 6.283185
\end{verbatim}

\section*{WHILE}
The {\tt WHILE} statement pops one number off the stack.
If that number is true ($\neq 0.0$),
the statement following the {\tt WHILE} will be executed.
If the number is false,
then control passes to the first statement
following the {\tt REPEAT} statement.
This statement can only be used
inside a {\tt BEGIN\ldots WHILE\ldots REPEAT} loop
in a colon definition.

\medskip
\noindent {\em Example:}
\begin{verbatim}
COD> VAR Y                  ! Create variable Y

COD> : TEST 2 Y STO         ! Initialize Y to 2
COD> BEGIN
COD>   Y RCL .              ! Print the value of Y
COD>   Y RCL 1.E10 < WHILE  ! Recall number and test for <1.E10
COD>   Y RCL DUP * Y STO    ! Square and store new value
COD> REPEAT ;

COD> TEST
 2.0
 4.0
 16.O
 256.0
 4.2949673E+9
 1.8446744E+19
\end{verbatim}

\section*{X}
Push the current X value into the stack.

\section*{\Huge \^{}}
Raise the previously entered number
to the power given by the top number in the stack.

\medskip
\noindent {\em Example:}
\begin{verbatim}
 5.0 2.0
COD> ^
 25.0
\end{verbatim}
