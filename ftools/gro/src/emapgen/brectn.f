CCCCCCCCCCCCCCCCCCCCCCCC MAPGEN.SOURCE(BRECTN) CCCCCCCCCCCCCCCCCCCCCCCCC
C
CH1  ROUTINE NAME:  BRECTN
CH1
CH1  VERSION: 1.01              DATE: 01/29/90
CH1  $Id: brectn.f,v 1.7 2013/05/21 19:08:24 irby Exp $
CH1
CH1  PROGRAMMER(S) AND COMPLETION DATE:
CH1     ALBERT ETIENNE - S.T.X. - 02/13/89
CH1
CH1  FUNCTION: BINS THE CURRENT EVENT INTO A RECTANGULAR GRID AND
CH1            GENERATES SOME OF THE VALUES FOR THE FITS HEADER.
CH1
CH1  SOFTWARE SYSTEM AND SPACECRAFT:  EGRET PROJECT
CH1
CH1  COMPUTER AND LANGUAGE:  IBM 3081 - VS FORTRAN
CH1
CH2  CALLING SEQUENCE:  CALL BRECTN(ELEVEL)
CH2     ARGUMENT    TYPE   I/O                 DESCRIPTION
CH2     --------    ----   ---  ----------------------------------------
CH2     ELEVEL      I*4     I   INDEX FOR THE EVENT'S ENERGY LEVEL
CH2
CH2  CALLED BY:  BINEVT
CH2
CH2  CALLS: NONE
CH2
CH3 COMMON USE:
CH3 COMMON BLOCK NAME: MAIN          (HOLDS THE MAIN VARIABLES)
CH3 VARIABLE     TYPE                        DEFINITION
CH3   NAME
CH3 --------   ---------   ---------------------------------------------
CH3 USRTIM(2)  REAL*8      COMBINED TJD/MSD USER TIME (1:START, 2:END)
CH3 RETCOD     INTEGER     PROGRAM RETURN CODE (0=NORMAL)
CH3 NUMLEV     INTEGER     NUMBER OF ENERGY LEVELS SELECTED BY THE USER
CH3 SKYLIM(4)  REAL        MAP BOUNDARIES SELECTED BY THE USER
CH3 BINSIZ(2)  REAL        BIN SIZE SELECTED BY THE USER (1:X, 2:Y)
CH3 USTIME(8)  INTEGER     START TIME (TJD,MSD,MONTH,DAY,YEAR,HR,MIN,SC)
CH3 UETIME(8)  INTEGER     END TIME (TJD,MSD,MONTH,DAY,YEAR,HR,MIN,SEC)
CH3 ENRGY1(20) INTEGER     MINIMUM VALUE FOR EACH OF THE ENERGY LEVELS
CH3 ENRGY2(20) INTEGER     MAXIMUM VALUE FOR EACH OF THE ENERGY LEVELS
CH3 CVTANG     REAL        FACTOR TO CONVERT DEGREES TO RADIANS
CH3 TWOPI      REAL        VALUE OF 2 PI IN RADIANS
CH3 ENFLAG(20) LOGICAL     DETERMINES IF EACH ENERGY LEVEL HAS DATA
CH3 ERFLAG     LOGICAL     DETERMINES IF ENERGY RETURN CODE MUST BE USED

CH3 AXLIMT(2)  INTEGER     MAXIMUM SIZE OF BIN DATA ARRAY IN 1ST 2 DIM.
CH3 ERCLAS     INTEGER     ENERGY RETURN CODE CLASS
CH3 PULVAL(4)  REAL*4      PULSAR PARAMETERS LIMITS
CH3 MAPTYP     CH*4        MAP TYPE (ALL SKY, SINGLE POINTING, GAL DISK)
CH3 SYS        INTEGER     INDEX FOR THE COORDINATE SYSTEM TO USE
CH3 MAPTP2     CH*4        MAP TYPE (ALL SKY, SINGLE POINTING, GAL DISK)
CH3 TESTPI     LOGICAL     DETERMINES IF PI IS BETWEEN THE USER LIMITS
CH3 NUMSAV     INTEGER     NUMBER OF FITS HEADER LINES SAVED
CH3 NUMEXC     INTEGER     TOTAL NUMBER OF EXCLUDED EVENTS
CH3 CSYSTM     CH*4        COORDINATE SYSTEM TO USE (GAL,CEL,INST,EARTH)
CH3 TIMFMT     CH*8        TIME FORMAT (CAL=CALENDAR, TJD=TJD/MSD)
CH3 FILNAM     CH*8        NAME EXTENSION OF THE OUTPUT FITS FILE
CH3 EVFILE     CH*24       NAME OF THE EVENT INPUT FILE
CH3 SAVEHD(150)CH*64       HEADER LINES SAVED
CH3 ERBITS(6)  CH*1        ENERGY RETURN CODE BITS ('0', '1' OR 'X')
CH3
CH3 COMMON BLOCK NAME: EVTREC        (HOLDS THE EVENT RECORD)
CH3 VARIABLE     TYPE                        DEFINITION
CH3   NAME
CH3 --------   ---------   ---------------------------------------------
CH3 EVTMSD     INTEGER*4   EVENT MILLISECOND OF DAY
CH3 EVTMIC     INTEGER*2   EVENT MICROSECOND
CH3 EVTTJD     INTEGER*2   EVENT TRUNCATED JULIAN DAY
CH3 SPARE1(6)  REAL*4      SPARE BYTES
CH3 EVTPOS(8)  REAL*4      EVENT POSITIONS IN ALL COORDINATE SYSTEMS
CH3 EVTENG     REAL*4      EVENT ENERGY
CH3 EVTUNC     REAL*4      EVENT ENERGY UNCERTAINTY
CH3 EVTERC     REAL*4      EVENT ENERGY RETURN CODE
CH3 SPARE2(3)  INTEGER     SPARE BYTES
CH3 EVTBIN     REAL*4      EVENT BINARY PULSAR PARAMETER
CH3 EVTPUL     REAL*4      EVENT PULSAR PARAMETER
CH3 SPARE2(3)  REAL*4      SPARE BYTES
CH3
CH3 COMMON BLOCK NAME: FITSDT        (HOLDS THE FITS HEADER VALUES)
CH3 VARIABLE     TYPE                        DEFINITION
CH3   NAME
CH3 --------   ---------   ---------------------------------------------
CH3 BITPIX     INTEGER*4   NUMBER OF BITS PER PIXELS
CH3 NAXIS      INTEGER*4   NUMBER OF AXIS
CH3 NAXIS1     INTEGER*4   NUMBER OF BINS ON THE FIRST AXIS
CH3 NAXIS2     INTEGER*4   NUMBER OF BINS ON THE SECOND AXIS
CH3 NAXIS3     INTEGER*4   NUMBER OF BINS ON THE THIRD AXIS
CH3 NAXIS4     INTEGER*4   NUMBER OF BINS ON THE FOURTH AXIS
CH3 CRVAL1     REAL*4      COORDINATE OF REFERENCE POINT ON AXIS 1
CH3 CRPIX1     REAL*4      ARRAY INDEX OF REFERENCE POINT ON AXIS 1
CH3 CDELT1     REAL*4      INCREMENT OF COORDINATE ALONG AXIS 1
CH3 CTYPE1     CHAR*4      TYPE OF COORDINATE ON AXIS 1
CH3 CRVAL2     REAL*4      COORDINATE OF REFERENCE POINT ON AXIS 1
CH3 CRPIX2     REAL*4      ARRAY INDEX OF REFERENCE POINT ON AXIS 2
CH3 CDELT2     REAL*4      INCREMENT OF COORDINATE ALONG AXIS 2
CH3 CTYPE2     CHAR*4      TYPE OF COORDINATE ON AXIS 2
CH3 CRVAL3     REAL*4      COORDINATE OF REFERENCE POINT ON AXIS 3
CH3 CRPIX3     REAL*4      ARRAY INDEX OF REFERENCE POINT ON AXIS 3
CH3 CDELT3     REAL*4      INCREMENT OF COORDINATE ALONG AXIS 3
CH3 CTYPE3     CHAR*4      TYPE OF COORDINATE ON AXIS 3
CH3 BUNIT      CHAR*12     DATA UNITS
CH3 BSCALE     REAL*4      SCALE FACTOR TO CONVERT THE BIN DATA
CH3 BZERO      REAL*4      OFFSET TO CONVERT THE BIN DATA
CH3 PCOUNT     INTEGER*4   NUMBER OF PARAMETERS
CH3 GCOUNT     INTEGER*4   NUMBER OF GROUPS
CH3 MAPSIZ     INTEGER*4   NUMBER OF VALUES IN THE MAP (INCLUDING PARMS)
CH3 DATIME(4)  INTEGER*4   DATA START AND END TIMES
CH3 PDIREC(2)  REAL*4      INSTRUMENT POINTING DIRECTION
CH3 FTPARM     REAL*4      5 PARAMETERS (200 GROUPS). INDEX 1 TO 5 ARE:
CH3   (5,200)              1:NUMBER BINS IN GROUP, 2:POSITION ON AXIS1,
CH3                        3:POSITION ON AXIS2, 4:INCREMENT ON AXIS1,
CH3                        5:INCREMENT ON AXIS 2
CH3 BINDAT     INTEGER*2   BIN DATA (200 X 200 X 20 ENERGY LEVELS)
CH3 (200,200,20)
CH3 FITSRC     CHAR*2880   FITS RECORD
CH3 SIMPLE     LOGICAL     DETERMINES IS THE SIMPLE FITS FORMAT IS USED
CH3 GROUPS     LOGICAL     DETERMINES IF GROUPS ARE USED
CH3 STRTIM     CHAR*21     START TIME IN CHARACTERS
CH3 ENDTIM     CHAR*21     END TIME IN CHARACTERS
CH3
CH3 SIGNIFICANT LOCAL VARIABLES:  N.A.
CH3   VARIABLE   TYPE   INI. VAL.               DESCRIPTION
CH3   --------   ----   ---------  -----------------------------------
CH3   EVENTX     R*4        -      EVENT X POSITION
CH3   EVENTY     R*4        -      EVENT Y POSITION
CH3   FIRST      L*4     .TRUE.    FLAG TO DETERMINE FIRST TIME CALLED
CH3   PASS       L*4     .FALSE.   DETERMINES IF THE EVENT WAS SELECTED
CH3
CH4  LOGICAL UNITS USED:   UNIT #                DESCRIPTION
CH4                        ------    -----------------------------------
CH4                        NONE
CH4
CH4  METHOD:
CH4     GET THE EVENTS COORDINATES IN THE (-180,180 & -90,90) SYSTEM
CH4     TEST IF THE EVENT IS WITHIN THE SELECTED BOUNDARIES
CH4     (THERE IS SPECIAL TEST TO DO IF THE BOUNDARIES INCLUDE PI)
CH4     IF (THE EVENT WAS FOUND WITHIN THE BOUNDARIES) THEN
CH4        IF (THIS IS THE FIRST TIME AN EVENT IS SELECTED) THEN
CH4           COMPUTE THE VALUES FOR THE FITS PARAMETERS
CH4           TEST THAT THE NUMBER OF BINS PER AXIS IS VALID
CH4           SAVE THE FILE START TIME
CH4        END IF
CH4        COMPUTE THE ARRAY POSITIONS, I AND J OF THE EVENT
CH4        INCREMENT THE BIN DATA ARRAY FOR THE POSITION I AND J
CH4        SAVE THE FILE END TIME
CH4     ENDIF
CH4  END BRECTN
CH4
CH5  MODIFICATIONS BETWEEN VERSIONS:
CH5     MOD #   MODIFIER    DATE                  DESCRIPTION
CH5     -----   --------  --------   -----------------------------------
CH5     1.01    A.ETIENNE 01/29/90   USED A SPECIAL ARRAY, GALDAT, TO
CH5                                  STORE THE GALACTIC DISK DATA SO
CH5                                  THAT THE MAP DOES NOT HAVE TO BE
CH5                                  DIVIDED IN 4 PARTS. REMOVED THE
CH5                                  CODE THAT SAVED THE POINTING
CH5                                  DIRECTION.
CH5	2.0	E.S.Panduranga 08/12/91
CH5				Merged changes from version 1.06 on IBM
CH5				FORCED BIN CUTOFF BEYOND MAXIMUM
CH5				ANGLE FROM THE DETECTOR AXIS AS
CH5				SELECTED BY THE USER.
CH5 $Log: brectn.f,v $
CH5 Revision 1.7  2013/05/21 19:08:24  irby
CH5 Change character*n to character(n) to silence warnings: "Obsolescent
CH5 feature: Old-style character length".
CH5
CH5 Revision 1.6  2005/08/26 19:36:34  irby
CH5 Purely cosmetic changes to allow compilation with gfortran/g95, mostly
CH5 involving fixes to lines longer than 72 chars that were being truncated,
CH5 but in the case of the CGRO code, also moving misplaced (tabbed) line
CH5 continuation characters to their appropriate position in column 6.
CH5
CH5 Revision 1.5  2002/12/26 17:16:25  irby
CH5 Fix variable declarations for f90 compatibility, e.g.:
CH5       INTEGER         EVTTJD*2
CH5 is properly declared as:
CH5       INTEGER*2       EVTTJD
CH5
CH5 Revision 1.4  1998/10/09 00:31:51  peachey
CH5 Changed references to addbin to addbin_m and celgal to celgal_m
CH5
c Revision 1.3  1998/10/06  12:52:20  silvis
c A stop was removed from the main program so that the learn feature
c for the par file would work properly and some minor changes were made
c to the par file.
c
C Revision 2.3  1992/03/27  15:53:48  albert
C Used variable dimension arrays for the maps. Used the bin centers when
C testing for the cutoff angles.
C
C Revision 2.2  1991/11/27  18:49:15  albert
C Used the 2 values of the bin sizes depending on whether the X or Y
C axis are involved.
C
C Revision 2.1  1991/08/28  19:36:16  esp
C First really controlled version on SUN (ported from IBM 3081)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE BRECTN(ELEVEL,XPDIR,YPDIR,EVTMSD,EVTTJD,EVTPOS)
      implicit none 

       REAL    EVENTX,EVENTY,PI,THETAX,THETAY,THETA,evx,evy
C       
C       The character variable below has been added 
C       so that the code can use the fitsio routine 
C       fcecho. 
C       
C       Jeff Silvis 
C       RSTX 
C       6  August  98
 
       character(250) FCECHO_STR 
      REAL EVTPOS(8)
      INTEGER    EVTMSD
      INTEGER*2  EVTTJD


      REAL    XPDIR,YPDIR
      INTEGER I,J,ELEVEL
      LOGICAL FIRST,PASS

Cesp  
      real	themax

      INCLUDE 'main.cmn.inc'
      INCLUDE 'fitsdt.cmn.inc'


      DATA FIRST /.TRUE./

      character(80)	id
      common	/id/	id
      id = '$Id: brectn.f,v 1.7 2013/05/21 19:08:24 irby Exp $'

      RETCOD = 1

C---> GET THE EVENT COORDINATES IN THE APPROPRIATE SYSTEM
      IF (FIRST) THEN
         PI = TWOPI/2.0
         THEMAX = DETMAX * CVTANG
         IF (TESTPI.AND. (XPDIR.LT.SKYLIM(1)) ) XPDIR = XPDIR + TWOPI
         I = (XPDIR-SKYLIM(1)) / BINSIZ(1) + 1
         J = (YPDIR-SKYLIM(3)) / BINSIZ(2) + 1
	 XPDIR = SKYLIM(1) + BINSIZ(1)*(I-0.5)
	 YPDIR = SKYLIM(3) + BINSIZ(2)*(J-0.5)
      END IF
      EVENTX = EVTPOS(SYS)
      EVENTY = EVTPOS(SYS+1)
      IF (CSYSTM.EQ.'GALA') THEN
         EVENTX = EVTPOS(SYS+1)
         EVENTY = EVTPOS(SYS)
      ENDIF
      IF (EVENTX.GT.PI) EVENTX = EVENTX - TWOPI

C---> TEST IF THE EVENT IS WITHIN THE SELECTED BOUNDARIES
      PASS = .FALSE.
C---> IF PI IS WITHIN THE LIMITS, A SPECIAL TEST NEEDS TO BE MADE
      IF (TESTPI) THEN
         IF (((  (SKYLIM(1).LE.EVENTX)  .AND.  (EVENTX.LE.PI) ) .OR.
     &   ( (-PI.LT.EVENTX) .AND. (EVENTX.LE.SKYLIM(2)) )) .AND.
     &   ( (SKYLIM(3).LE.EVENTY) .AND. (EVENTY.LT.SKYLIM(4)) )) 
     &   PASS = .TRUE.
      ELSE
         IF ((SKYLIM(1).LE.EVENTX) .AND. (EVENTX.LT.SKYLIM(2)) .AND.
     &   (SKYLIM(3).LE.EVENTY) .AND. (EVENTY.LT.SKYLIM(4)) ) 
     &    PASS = .TRUE.
      ENDIF

C---> DO NOT TAKE EVENTS BEYOND MAXIMUM ANGLE IN INSTRUMENT COORDINATES
      EVX = EVENTX
      EVY = EVENTY
      IF (TESTPI.AND. (EVX.LT.SKYLIM(1)) ) EVX = EVX + TWOPI
      I = (EVX-SKYLIM(1)) / BINSIZ(1) + 1
      J = (EVY-SKYLIM(3)) / BINSIZ(2) + 1
      EVX = SKYLIM(1) + BINSIZ(1)*(I-0.5)
      EVY = SKYLIM(3) + BINSIZ(2)*(J-0.5)
      THETA=ACOS(SIN(EVY)*SIN(YPDIR)+COS(EVY)*COS(YPDIR)*COS(XPDIR-EVX))
      IF ( (CSYSTM.EQ.'ERTH') .OR. (CSYSTM.EQ.'INST') ) THEN
         THETAX = EVTPOS(1)
         THETAY = EVTPOS(2)
         THETA = ATAN(SQRT(TAN(THETAX)**2 + TAN(THETAY)**2))
      end if
      IF (THETA.GT.THEMAX) PASS = .FALSE.

C---> IF THE EVENT PASSED THE SELECTION CRITERIA, PROCESS IT
      IF (PASS) THEN

C------> THE FIRST TIME THROUGH, COMPUTE THE FITS PARAMETERS
         IF (FIRST) THEN
               SIMPLE = .TRUE.
               GROUPS = .FALSE.
               NAXIS = 3
               IF (TESTPI) THEN
                  NAXIS1 = NINT((TWOPI+SKYLIM(2)-SKYLIM(1)) / BINSIZ(1))
               ELSE
                  NAXIS1 = NINT((SKYLIM(2)-SKYLIM(1)) / BINSIZ(1))
               ENDIF
               NAXIS2 = NINT((SKYLIM(4)-SKYLIM(3)) / BINSIZ(2))

C------------> TEST THAT THE NUMBER OF BINS PER AXIS IS VALID
               IF (MOD(NAXIS1,2).NE.0) THEN
                  NAXIS1 = NAXIS1 - 1
                  SKYLIM(2) = SKYLIM(2) - BINSIZ(1)
                  WRITE(FCECHO_STR,'(A,I12)') 'WARNING:UNEVEN #BINS. 
     & NAXIS1 SET TO',NAXIS1
                  call FCECHO(FCECHO_STR) 
               ENDIF
               IF (MOD(NAXIS2,2).NE.0) THEN
                  NAXIS2 = NAXIS2 - 1
                  SKYLIM(4) = SKYLIM(4) - BINSIZ(2)
                  WRITE(FCECHO_STR,'(A,I12)') 'WARNING:UNEVEN #BINS. 
     & NAXIS2 SET TO',NAXIS2
                  call FCECHO(FCECHO_STR) 
               ENDIF
               IF ( (NAXIS1.LT.3) .OR. (NAXIS2.LT.3) ) THEN
                  WRITE(FCECHO_STR,'(A,I12,I12)') 'ERROR: TOO FEW 
     & BINS:',NAXIS1,NAXIS2
                  call FCECHO(FCECHO_STR) 
                  RETCOD = 8
                  RETURN
               ENDIF
	       IF (NAXIS1*NAXIS2*NUMLEV.GT.MAXBIN) THEN
	          WRITE(FCECHO_STR,'(A,I12,I12,I12)')
     &                  'ERROR: TOO MANY BINS',NAXIS1,NAXIS2,NUMLEV
	          call FCECHO(FCECHO_STR) 
	          WRITE(FCECHO_STR,'(A,I12)')
     &                  '       NAXIS1*NAXIS2*NAXIS3 >',MAXBIN
	          call FCECHO(FCECHO_STR) 
	          RETCOD = 8
	          RETURN
	       ENDIF
C------------> SAVE THE FITS HEADER VALUES
               CRVAL1 = SKYLIM(1) / CVTANG
               CRPIX1 = 1.0
               CDELT1 = BINSIZ(1) / CVTANG
               CRVAL2 = SKYLIM(3) / CVTANG
               CRPIX2 = 1.0
               CDELT2 = BINSIZ(2) / CVTANG
               MAPSIZ = NAXIS1*NAXIS2
               DATIME(1) = EVTTJD
               DATIME(2) = EVTMSD
               FIRST = .FALSE.
         ENDIF

C------> INCREMENT THE BIN ARRAY FOR THAT BIN
	 CALL ADDBIN_M(BINDAT,NAXIS1,NAXIS2,NUMLEV,I,J,ELEVEL,ENFLAG)
Cae      BINDAT(I,J,ELEVEL) = BINDAT(I,J,ELEVEL) + 1
Cae      ENFLAG(ELEVEL) = .TRUE.
Cae      IF (NAXIS1.LE.200) THEN
Cae         BINDAT(I,J,ELEVEL) = BINDAT(I,J,ELEVEL) + 1
Cae      ELSE
Cae         GALDAT(I,J,ELEVEL) = GALDAT(I,J,ELEVEL) + 1
Cae      ENDIF
         DATIME(3) = EVTTJD
         DATIME(4) = EVTMSD
         RETCOD = 0

      ENDIF

      RETURN
CHCCCCCCCCCCCCCCCCCCCCC END MAPGEN.SOURCE(BRECTN) CCCCCCCCCCCCCCCCCCCCCC
      END
