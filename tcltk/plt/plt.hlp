1 HELP 
PLT is an interactive plotting and fitting facility.  When it is
time to plot the data you will be prompted for a plotting device.
There are three valid responses:
Type ? to get a list of legal devices.
Type > to go directly into command mode (no plot is produced).
Or input a valid device and the plot will be produced on that device.

PLT does not distinguish between upper and lower case.  In this
documentation upper case is used to denote the shortest unique
abbreviation.
2 CLear
CLear

Immediately clear the current plot device.
2 COlor
COlor [#] ON|OFf [glist]

The first (optional) number allows you to reset the default color
index for the plot groups specified in "[glist]".  If the first number
is omitted, then color index is not changed but the plotting of groups
in glist can be turned on or off.  For example, if you have 85 groups
and you only want to see group 3, you can do this with

COlor OFf 1..999     ! second number only needs to be larger than 85
COlor ON  3
r y

It is also possible to change the color of other features on the plot.

COlor MOdel #<BR>
   Plot the model using color index #.

Color # ON Grid<BR>
   Use the color index specified by # when plotting the grid in the
currently active window.

COlor ?<BR>
   Generate a list of possible color indices and their default color
representations.
3 examples
<PRE>
PLT> COlor OFf 1,2,3  ! Suppress plotting of groups 1, 2, and 3
PLT> COlor ON  2      ! Turn on plotting of group 2
PLT> COlor 5 ON 3     ! Use color 5 when plotting group 3
</PRE>
2 CONtour
CONtour [gnum] ?|COlor list|LEvel list|LStyle list|LWidth list|OFf

   This command causes PLT contour a two dimensional array of data.
The first number denotes the plot group to be contoured.  If you have
not defined any two dimensional plot groups, then PLT will automatically
create a group for you that consists of the largest possible chunk
of the main data array.  If you omit the first number then PLT uses
the group number from the last time you used the CONtour, IMAge, DGroup
(to define a 2D array).  If none of these commands were used, the
PLT will use group 1.

A contour plot does not automatically turn off the normal plotting
of the remaining plot groups, and typical arrays to be contoured may
contains lots (hundreds!) of columns the possiblity that some of
those groups will normally overwrite the contour is high.  Thus you
are advised to issue a

COlor OFf 1..999

to suppress the normal ploting, unless, of course you are a PLT
wizard and want to mix the two types of plot.

If order for a contour to appear you must define a set of levels
via the LEvel subcommand.
3 example
Although this example is intended to be standalone, it will work with
the fig06.qdp file.  In other words, if you use qdp to plot fig06.qdp
you can enter the following commands to get two contour plots in two
windows.  You will also note that group 1 is plotted in window 2 and
group 2 in window 1.  This was done purely to illustrate that it is
possible.  In general you will get a lot less confused if you stick
to a simpler convention (e.g., group 1 in window 1, etc.)
<PRE>
Yplot OFf 1..99         ! Turn off all previous plots
DGroup 2 1 1 10 20      ! Define group 2 to be a 2D group
WIN 1                   ! Define the window to use
LOC 0 0 0.5 0.5         ! Locate window in bottom left corner
YPL 2                   ! Plot group 2 in window 1
CON 2 LEvels -0.5 0 0.5 ! Create contours at three levels
CON 2 LStyle 4 4        ! Use dotted lines for negative levels
CON 2 LWidth,,3         ! Make the level=0 line fatter
GAP 0.0 Nerr            ! Best for contour plots
R                       ! Reset the scale in this window
DGroup 1 11 1 20 20     ! Define group 1
WIN 2                   ! Define a second window
YPL 1                   ! Plot group 1 in window 2
LOC 0.5 0.5 1.0 1.0     ! :ocate window in upper right corner
CON 1 LEvels -1.5 -0.5 0 0.5 1.5
CON 1 LWidth,,,3        ! Fatten up level=0 in this plot
CON 1 LStyle 4 4        ! Use dotted lines for negative levels
R                       ! Reset the scale in this window
</PRE>
3 hints
PGPLOT draws the line segments that make up the contour such that
one coordinate of an (x,y) pair is always at a integer pixel position,
i.e., a pixel center.  This makes sense if you assume the z value
is correct at the center of the pixel and thus one is computing where
the contour level intersects the line between two pixel centers.
To correctly set the default scale for contour plot you should use:

GAp 0.0 Noerrors
R                 ! reset the default scale.

The GAp 0.0 ensures that there is no extra gap around the data, and
the Noerrors causes the error bars to be ignored when min/max values
are computed.  This causes the default scale to be set by the pixel
centers.

It is possible to plot both a contour and an image in the same
window.  If the contour and image are both from the same group
the PLT automatically plots the image first and then the contour
"on top" of the image.  If the contour and image correspond to
different groups, then you should make sure the image is assigned
a lower group number.  This is because PLT plots the groups in
order from the lowest to the highest.
3 Color
   By default PLT plots the first contour with color index 1, the
second with color index 2, etc.  (Use the PLT COlor ? command to see
the default mapping of color index into colors).  The CONtour Color
sub-command can be used to override this default.  Thus to plot the
first 10 levels with color index 1, you would use

CON Color 1 1 1 1 1 1 1 1 1 1

and to change just the third level to color index 3 use

CON Color,,,3

Note, you must use the CONtour LEv subcommand to define the levels
before any contours will be plotted.
3 LEvel
This subcommand is required must be used before a contour plot will
appear.  The CONtour LEvel subcommand is followed by a list of numbers
that correspond to the levels to be contoured.  You can define up
to 32 (set by MXLEV in PLT code) contour levels.  Thus

CON LEV -20 -10 0 10 20

would define 5 levels.  PLT remembers the previous levels so you
change the value for level 3 only by

CON LEV ,,,3.14159

To use fewer levels than what had been previously defined you must
use the NO data value.  Thus

CON LEV,,,,no

would leave the first 3 levels unchanged and stop plotting levels above 4.
3 LStyle
By default all contours are plotted with a line style of one.  (Use
the PLT "LStyle ?" command to get a list of the possible styles.)
You can use the CONtour LStyle sub-command to change this.  Suppose
you wanted to use dotted lines (line style of 4) to plot negative
contours.  You would do this with

CON LEV -10 -20 0 10 20
CON LS   4   4

Thus the first two contour levels would now be plotted with line
style of 2 and the remainder would use the default line style.

Note, you must use the CONtour LEv subcommand to define the levels
before any contours will be plotted.
3 LWidth
   By default all contours are plotted with a line width of 1.  You
can override this default using the CONtour LWidth subcommand.  Thus

CON LWidth,,,3

would plot the third level with a line width of 3.

Note, you must use the CONtour LEv subcommand to define the levels
before any contours will be plotted.
3 OFf
   This subcommand is use to switch off the plotting of a contour
with a plot group.  This you no longer wish to see plot group 2
plotted with a contour, then you would use

CON 2 OFF

Of course, if you now want to see plot group 2 plotted as a regular
Y vs X manner, make sure you use the COlor ON command, i.e., COL ON 2.
Since group 2 is now a two dimensional array, you will now see the
entire array was was being contoured projected onto the X coordinate.
If you wish to restore group 2 to its original one dimensional form
you should use "DGrroup 2 2", i.e., define group 2 to be the second
vector in the main data array.
2 CPD
CPD [$]
   Change the current plotting device.  The current plot device is
released; the next plot will be produced on the new device.  By default
PLT uses the plotting device specified in the PGPLOT_TYPE environment
variable.  If this variable is not defined then PLT will prompt for
a plotting device at startup.

Note: "CPD" with no argument releases the current plotting device.
This is useful when plotting to a file and closing the device is
necessary to get PGPLOT properly terminate and close the file.  Also
"CPD ?" will list all the devices supported.
3 examples
<PRE>
PLT> CPD /PS         ! Output Postscript commands to a file
PLT> Plot            ! Send the current plot to the file
PLT> CPD             ! Close the file
</PRE>
2 CQuit
CQuit
   Immediately clear the plot device and exit subroutine PLT.
2 CSize
CSize #
   Set character size to # where # is greater than zero and less than
five (one is default).
3 example
PLT> CSize 2.0       ! Use a character size twice the default
2 Device
Device [$]
   Define the plotting device.  This is a synonym for the "CPD" command.
2 DGroup
DGroup gnum def
   The define group command, DGroup, allows programmers and/or users
to define new plot groups.  The PLT default is for each plot group
to consist of a data vector (the SKip command provides another way
to override this default).  The DGroup command gives the user total
control over how the plot groups are defined.

The gnum is the group number and must be in the range 1 to MXGRP-MXMOD
(typically 60).

def is the group definition and can be either

  a) A single number.  The number corresponds to a vector number in
the main data array.  Thus "DGroup 2 2" would define group 2 to be
the second vector, which is the default.

  b) Four numbers.  If you think of the main data array to be a two
dimensional array with coordinates corresponding to the row and vector
numbers, then the first two numbers define a row, vector coordinate
of one corner and the second set form the other corner. Thus
"DGroup 4 5 3 10 3" would define group 4 to be rows 5 through  10
of vector 3, and "DGroup 4 1 1 10 20" would cause group 4 to include
rows 1 through 10 and vectors 1 to 20.

  c) Either the word Model or Residual.  By default, PLT reserves
the high numbered groups (typically 61 to 64) to contain the model.
However if you want to plot the same model in different window than
the default you can define a new group to be that model  The
"DGroup 3 Res" command would cause group 3 to contain the current
model residuals.  The data min and max values are recomputed every
time the model is changed.  Of course, PLT does not change the scale
unless you issue a "Rescale" command.
3 residual_example
<PRE>
PLT> MO 1 CO               ! Define a COnstant model
 23                        ! Starting parameter
PLT> DGroup 2 Res          ! Group 2 is the model residuals
PLT> YPL 2                 ! Plot group 2 in current window
PLT> R Y                   ! Rescale and replot
PLT> FIT                   ! Fit
PLT> P                     ! Replot using the original scale
PLT> R Y                   ! Rescale using currng residual min/max values
3 examples
PLT> DGroup 2 2            ! Group 2 is vector 2 (the PLT default)
PLT> DGroup 2 1 2 10 2     ! Group 2 is rows 1 to 10 of vector 2
PLT> DGroup 2 2 1 10 99    ! Group 2 is now two dimensional, consisting
                           ! of rows 2 through 10 and vectors 1 to 99.
PLT> Dgroup 2 Res          ! Group 2 is now the model residuals.
</PRE>
2 Error
Error OFf [glist]

   Turn off the plotting of errors for all plot groups specified in
"[glist]".

Error ON  [glist]

   Undo the effects of the "Error OFf" command for the specified
plot groups.

Error Sq  [glist]

   Set errors equal to "SQRT(value)" for the specified plot groups.

Error Dia [glist]

   Draw diamond style errors on specified groups.

Error X ON|OFf [glist]

   This command controls the plotting of the x-error bars.  For example,
if groups 1,2, and 3 all have associated errors, then the command
sequence "Xaxis 1"; "Error X ON 2"; "Error X OFf 3", would cause the
x-errors to be plotted when group 2 is plotted but not when group 3
is plotted.

When fitting data, error bars will be used to weight the data only
if the errors are visible.  Thus "Error OFf" followed by "Fit" will
produce an unweighted fit.  Also, note that only the y-errors are
used to weight the data.
3 examples
<PRE>
PLT> Error OFf 1,2,3  ! Turn off errors for groups 1, 2, and 3
PLT> Error Dia 2      ! Plot diamond errors on plot group 2
PLT> Error ON         ! Plot errors for all plot groups
PLT> SKip Sing        ! Turn on the `skip' mode
PLT> Error X OFF      ! Suppress plotting of errors in x-direction
</PRE>
2 EXit
EXit
   Exit subroutine PLT.
2 Fit
Fit [#] [Iterate #]
   Cause PLT to call the fitting routine to search for the best fitting
parameters for the model specified with the "MOdel" command.  The
first optional number is the plot group to fit.  If this number is
omitted, then "Fit" will continue to fit the previous group that you
were fitting if that plot group is still visible.  For the first use
of "Fit" or if the plot group has been "COlored OFf" then "Fit" will
default to fitting the lowest numbered group which is visible.  The
"LAbel PArm" command controls whether the model parameters are plotted
on the right side of the plot.  Fitting continues until Delta chi^2
is less than 0.05.  As a default, you will be prompted to continue
fitting every 10 iterations.  If you wish to increase the number of
iterations without being prompted, then use the "Fit Iterate [#]".
Thus, "Fit I 100", would allow the program to try up to 100 iterations
before you would be prompted again.

Fit ON [#]
   Cause the current model to be plotted on group #.  If # is omitted,
the model will be plotted on plot group that was most recently fitted.

Fit OFf
   Cause the model to no longer be plotted.

Fit Plot #
   Control where the model is evaluated when it plotted.  If # is
greater than zero, then the model is evaluated at # points between
the current x-scale Minimum and Maximum.  If # is less than 0, then
the model is evaluated at "ABS(#)" points between the Data Min and Data
Max --- i.e., no extrapolation is allowed.  If # equals 0, then the
model is evaluated at the values of the data points. (This is the
default.)

Fit Stat Chi|Ml #
   Set the default fitting statistic to either chi^2 or maximum
likelihood.  For example, "Fit Stat M 2"  would vary the fit parameter
to minimize the likelihood function when compared with plot group 2.
3 statistics
Prior to 1998 Oct, Fit Stat ML would minimize the likelihood function:

      C = 2 * SUM{ model(i) - data(i)*ln(model(i)) + ln(data(i)!) }

where data(i) is the observed number of *counts* in the i'th bin and
model(i) is the model evaluated at that location.  Of course, data(i)!
is the factorial.  On 1998-Oct-01, the statistic was changed to:

      C = 2 * SUM{ model(i) + data(i)*[ln(data(i))-ln(model(i))-1.] }

which is the same statistic as is now used by XSPEC (the famous John
Castor "priv. comm." statistic).  This differs from the likelihood
function in terms that depend only upon the data.  Since the goal
is to find the minimum with respect to changes in the model
parameters, this function will have the same minimum as the likelihood
function.  The advantage of this new function is that when you
get a good fit, then C ~ DOF similar to chi^2.  Of course, I would
not suggest using a chi^2 table to interpret any results.

Prior to this change the "fit stat ml" would only work properly if
you were fitting raw counts.  If we assume that

      rate(i) +/- sigma(i) = data(i)/E +/- SQRT(data(i))/E

where E is typically the exposure (area*time).  Then it is easy to
show that:

      E = rate(i)/(sigma(i)^2)

(It is straightforward to handle the special case where data(i)=0.)
Using this expression, the PLT version of CURFIT now scales the rate
back into raw counts, and hence it is now possible to fit rates using
"stat ml".  If you accidently used "stat ml" with the old version,
then don't worry, the main difference is the estimated parameter
uncertainties, in the old version the estimate would be way off, and
now they are approximately correct.

Finally, there is the case where the model goes to zero.  There is
no problem where the data(i) is also zero as C will evaluate to zero
at that location.  Formally speaking if the data<>0 then clearly there
is a background term that should be included in the model (and if
don't include the background then you really should not be fitting
points where model=0).  On the other hand, if the background level
is low, for example, most of the counts are in a single gaussian shaped
feature, then it is real tempting to model this with a single gaussian
term and no background.  If you tried this with the old version
then you would discover that the gaussian width would slowly increase.
This happened because it would result in fewer non-zero model bins
and this would improve the statistic.

In the new version a model floor is defined.  Thus if the model
evalutates to less than the floor level, when calculating the statistic,
the floor value is used.  For now the floor value used is 1.0E-6
counts/bin.  Thus if your model depends on seeing one (or fewer) count
in a million bins, then this will result in a error or bias.  On the
other hand this does allow you to fit a narrow gaussian, no background
and get a sensible result.
2 FNy
FNy #
   Return the value of the current "MOdel" function at location #.
3 example
<PRE>
PLT> MOdel LINR CONS ! Define a straight line
  1, LI: VAL( 1.00), SIG( 0.00 ), PLO( 0.00), PHI( 0.00)?
2.                   ! Set slope of line equal to 2
  2, CO: VAL( 1.00), SIG( 0.00 ), PLO( 0.00), PHI( 0.00)?
3.                   ! Set intercept of line equal to 3
PLT> FNY 3           ! Evaluate function at x=3.0
12.0                 ! The result
</PRE>
2 FOnt
FOnt $
   Set the default to the font specified by the character string.
(Default is Simple font.)

FOnt ?
   List possible fonts.
3 example
PLT> Font Roman      ! Use the Roman font
2 FReeze
FReeze [plist]
   Can only be used after a model has been defined.  This command
causes all parameters listed in "[plist]" to be frozen, which means
the parameter value is not allowed to vary during a "Fit".

3 examples
<PRE>
PLT> FReeze 2       ! Freeze the value of parameter 2
PLT> FReeze 3..5 9  ! Freeze the values of parameters 3 through 5 and 9
</PRE>
2 GAp
GAp #
   Control the size of the gap between the edge of the plot and the
data extrema, when using the default scale.  The effect of the "GAp"
command can only be seen when you reset the default scale with "R",
"R X", or "R Y" (all with no arguments).  The default gap is 0.025
which will leave a 2.5 percent margin around the edge.  The size of
the gap in world coordinates, depends on whether the data are being
plotted on a logarithmic scale.  Therefore, if you wish to use a
default, logarithmic scale, you should first issue the "LOg" and "GAp"
commands and then use the "Rescale" command to reset the default scale.

The default gap is calculated based on the minimum and maximum of
the data.  If your data contains errors, then it is often useful to
include the error bars in the calculation.  This can be done using
the "GAp Error" command which means the gap is calculated based on
the minimum and maximum values including a one sigma error bar on
the data.  To revert to the original behavior to not include errors,
use "GAp NoError".
3 examples
<PRE>
PLT> GAp 0.0        ! No gap
PLT> R X            ! Use default X scale
PLT> GAp 0.05       ! Reset gap, for use with Y scale
PLT> LOg Y          ! Log the Y scale
PLT> R Y            ! Use default Y scale
</PRE>
2 Grid
Grid [clist]
   Control the plotting of a grid, where "[clist]" is one or more
of "ON", "OFf", "X # #", "Y # #".  For "Grid ON", the major tic marks
are expanded to place a grid over the entire plot.  "Grid OFf" turns
off the grid replacing the tic marks.  PGPLOT automatically selects
the location of the major and minor tic marks.  The "Grid" command
allows you to override this selection.  For example, "Grid X 10,2"
would divide the x-axis into 10 major divisions and then divide each
major division into 2 minor divisions.  Use "Grid X 0,0" to go back
to the default grid.  The number -1 can be used to suppress the plotting
of tic marks.  Thus, "Grid X -1 0" would only plot minor tic marks
on the x-axis and "Grid Y -1 -1" would prevent any tic marks from
being plotted on the y-axis.

IMPORTANT:  PGPLOT only places major tic marks at locations where
the least significant digit of the range increments by integer amounts.
If you attempt to force PGPLOT to violate this condition, then
unexpected things may happen.  For example, suppose you had used
"R Y 0 .15", in which case the range is 0.15 and the least significant
digit is 0.01.  Then using "Grid Y 3,2"  would place grid lines at
intervals of 0.05.  However, if you had tried "Grid Y 2,2", then the
grid lines would occur at intervals of 0.075, where the last digit (5)
is not a significant digit.  In this case, the plot will be incorrectly
labeled.  "Grid X 1.5,2" is legal and would correctly produce labels
at intervals of 0.1. (Of course, only one label would actually be
plotted in this case.)
2 Hardcopy
Hardcopy [$]
   Generate a copy of the plot using the current hardcopy specification.
In general, this makes a file that can later be printed.  The default
PLT hardcopy device for the first use can be set using the PLT_HARDCOPY
logical name (on VMS systems) or environment variable (on UNIX systems).
After the first time, the "Hardcopy" command defaults to the same
device as was specified in the previous "Hardcopy" command.  "Hardcopy"
produces a copy of what you would see if you reissued the "Plot" command.
This might not be an exact copy of what is currently displayed on the
graphics device.

Hardcopy ?
   Display on the terminal the default hardcopy specification.
3 example
PLT> Hardcopy /PS   ! Create a Postscript file
2 HElp
HElp [pcommand]
   Get help on the PLT command specified by "[pcommand]".
2 IMAge
IMAge [MIN #|MAX #|OFF|CCT $|LOG|LIN|SQRT|HISTO|TOT]
   This command will allow you to display your data as an image.
3 CCT
IMAge CCT $
   PLT currently has 3 built in color tables.  Use

PLT> IMA CCT ?

to see a list of these and a brief description.  Thus if you use
"CCT 1" you will get the gray scale color where the minimum value
appears black and the maximum as white.  To invert the color table
preceed the name with a minus sign (no space).  Thus "CCT -1" would
give a grayscale image where the minimum is white and the max is black.

Color tables can also be defined in external ASCII files.  If you have
a file called "blue.ct" then you can read this with "CCT blue".
Note, "CCT -blue" will invert the color table, hence you are advised
not to use a minus sign as the first character in the file name.
4 example
PLT> IMA CCT 2       ! Use builtin color table 2 to display images.
4 file_format
A color table file is an ASCII file consisting of a series of rows
each with 4 columns.  The first column is the "normalized color
index" which must be in the range 0 to 1 and monotonically increasing.
The next 3 columns are for the red, green, and blue values and each
number must be in the range 0 to 1.  Thus a minimal color table
would consist of just two rows.  Here is some sample data from
a file which we will call "blue.ct"
<PRE>
!CI   R    G    B
 0.   0.   0.   0.
 1.   0.   0.   1.
</PRE>
Using "CCT blue" will cause the minimum value to be plotted in black
(no color on) and the maximum value will be plotted with the blue
color full on, but red and green colors off.

How does the color table work?  Suppose PGPLOT has allocated color
indices 17 to 240 for images.  Assume you have set the min value is
0 and the max is 100, and you are about to display a pixel value of
40.  With the linear scaling PGPLOT would plot this value with a color
index of 0.4*(240-17+1) = 90.  The normalized color index is
40/(100-0+1) = 0.40.  Since this color index two values in the file,
the software will do a linear interpolation for the red, green and
blue values.  Using the blue.ct given above, red and green values
would both be off and the blue value would be set to 40 percent of
the maximum value.

The reason for using a normalized color index and an normalized color
intensities is to reduce the dependence on the graphics device, i.e.,
you don't need to know how many color indices the device supports
nor which ones PGPLOT have allocated to the image.  Anyone who has
worked with colors knows that "blue full on" looks different on
different devices, hence you will need to fine tune the color table
to look nice on the device you are plotting to.
3 MIN
3 MAX
3 TOT
3 hints
PGPLOT draws pixels centered on the integer pixel location and extending
out to +/- half a pixel.  Thus if you want your image to exactly fill
the plotting window, you should use

GAp 0.0 Errors
R                 ! reset the default scale.

The GAp 0.0 ensures there is no extra gap around the data, and the
Errors causes the error bars to be included when min/max values are
computed.  Since IMAge only works when using XAx Linear and YAx Linear
this effectively includes the extra half pixel when the min/max are
computed.

PLT works equally well with both "pseudo color" and "true color" devices
(if you don't know what these terms mean you might want to read the
history topic below).  Since pseudo color can only have one lookup
table active per program, using multiple color tables in different
PLT windows can result in confusion when switching from a pseudo color
device (such as a SUN X Window display) to a true color device (such
as PostScript file).  To avoid this confusion you should only use
one color table for all plot windows.  It is also suggested that you
define this color table in the image that appears in the lowest numbered
window i.e., the one that is plotted first.  This ensures that the
color table will be correctly loaded for all following windows.
3 history
Pseudo color devices were invented early in the age of computers where
processors were slow and memory was expensive.  Thus it was not
practical to store a 24 bit (Red,Green,Blue) RGB color triplet for
every pixel.  What was (typically) done was store an 8 bit color index
instead which allows only 256 color indices at each pixel.  However,
even early monitors could diplay more than 256 colors resulting in
a missmatch between the display adapter and the monitor.

In order to give users the ability use more than 256 colors, a lookup
table was implemented.  For example, color index 2 could correspond
to Red=255, Green=10, Blue=10 a red pixel.  Thus the hardware would
read the color index of a pixel, lookup corresponding color in the
color lookup table and then draw the pixel on the screen.  This can
be done very quickly and is very memory efficient.  Another advantage
of using a color lookup table is it can be reloaded very quickly.
For example, the IRAF image display exploits this feature by allowing
the user to change the lookup table by draging the mouse around
in the display window.  Although this allows you to quickly find
a color table that enhances the features they are interested in, it
is worth noting that you are not enhancing the data, just the monitors
ability to display the data.  In other words, features that are visible
when one lookup table is loaded, are still present (in the display
memory) for all the other lookup tables tried.

At the current time, it is typical for computers to display several
windows each drawn by a different program.  If all these programs
can agree on a color lookup table then things work fine.  On the other
hand if a program wants total control of a lot of colors (IDL and
Netscape are famous for this) then the operating system must swap
lookup tables around as the user changes from window to window,
program to program.  Since the lookup table can be loaded very
quickly this results in entire monitor flashing from one set of
colors to another.

It is no longer necessary to skimp on memory.  Current machines have
no problem loading 24 bit RGB indices at resolutions up to 1000 by 800
pixels (2.4 MB for display memory).  In fact, since three is an odd
number most displays load 32 bits per pixel, with 24 bits of RGB data
and 8 bits of something else such as a "alpha overlay plane".  This
makes true color devices possible.  What true color means, is each
pixel is loaded with its true RGR color triplet, and hence there is
no color lookup table.

Thus pseudo color means a color index is stored in memory and lookup
table is used to map the color index into a RGB triplet.  A true color
device stores the RGB triplet in memory.

Many people assume X Windows pseudo color, however, X Windows can
actually support either.  Suns typically implement X in a pseudo color
manner whereas SGIs typically implement true color.  PostScript of
course, is true color (i.e., no amount of messing with a color table
is going to change what is printed on paper.)
2 IMOdel
IMOdel [# # [#]]
   Integrate the current model over the range specified by the first
two parameters.  The third (optional) number, which defaults to 200,
is the number of steps.

For 2-dimensional data you can use

IMOdel
IMOdel [# # [#]] [# # [#]]

where 2nd triplet of numbers specify the lower and upper limits, and
the number of steps to use in the Y direction.

The method only uses a simple rectangle rule to calculate the integral.
2 Info
Info Call
   Display the various argument values in the original call to the
PLT subroutine.  Useful for programmers to figure out what they
are really telling PLT to do.

Info Groups
   For each active group, display some interval variables.

Info Scales
   For each active plot group display the label and data min/max
values.  This is the default value.

Info Windows
   Display PLT internal inforomation about the various active windows.
2 LAbel
LAbel G#|X|Y|Top|OX|OY|OTop|File [label]
   Place a label.  The command "LA G# label" associates a label with
a particular plot group.  Thus the command sequence "LAB G1 Time;
Xaxis 1", associates the label "Time" with group 1.  When the command
"Xaxis 1" executes, it makes group 1 the x-axis group, and as a result
the label "Time" will automatically appear on the x-axis.

The arguments "X", "Y", and "Top" would place a label on the x-axis,
y-axis, or the top of the plot.  These labels override the Group labels
so that if the x-axis is labelled with both a group label and a x
label, then only the x label appears.  When using the "Xaxis Linear"
command, "LAbel X" the the only way to label the x-axis.  It is possible
to place an additional line of text just outside these locations by
putting the letter `"O"' in front of these names.  For example, "OT"
would write a second label above the top label.  Finally one can change
the file name by using "LA File [name]".

If you should at any time wish to delete a label, then just omit the
"[label]" from the command.

LAbel OFf
   Suppress plotting of all text labels.  (This speeds up the production
of the plot on slow devices.)

LAbel ON
   Undo the effects of "LAbel OFf".

LAbel NX|NY ON|OFf [winlist]
   where "[winlist]" is a list of windows.  NX affects the plotting of
the numeric labels on the x-axis, NY on the y-axis.  Thus "LAbel NX OFF 1";
"LAbel NY OFF 1", will prevent the plotting of the numeric labels in both
the x and y directions for the first window.  (Note, there are 32 numbered
labels, so using "LAbel NX OFf", followed by several "LAbel #" commands
will allow you to create labels consisting of text strings etc.

LAb POS Y #
  Allows the position of the y label(s) to be changed.  The default
position is "LA POS Y 2.0".

LAbel Rotate
   Rotate numerical labels plotted on the y-axis.  The default PGPLOT
mode is to plot the y-axis numerical labels in the vertical direction.
"LAbel Rotate" will rotate these labels so they are written in a
horizontal direction.  If you issue the command a second time, then
the labels will flip back to vertical in the next plot.
3 examples
<PRE>
PLT> LA F               ! Delete the file name from the plot
PLT> LA T Test! Plot    ! Top label is Test
PLT> LA T "Test! Plot"  ! Top label is Test! Plot
</PRE>
3 Parm
LAbel Parm ON
   Display the parameter values associated with the current model,
on the right side of the plot. (This is the default.)

LAbel Parm OFf
   Suppress the display of the parameter values on the right side
of the plot.
3 #
LAbel # [clist] "string"
   Allow a label to be placed anywhere on the existing graph.  Here # is
a number in the range 1 to 32, "[clist]" is a list of subcommands that
allow you to change various attributes of the label, and ``string''
is the (optional) text.  For example,

PLT> LAbel 1 Pos 2 2 "test"

will create label 1 at position (2,2) containing the message "test".
4 CEnter
LAbel # CEnter Top|Cap|Half|BAse|BOttom
   Control the vertical position of the text string.  The default
position is "Half", although the use of the "LIne" subcommand will
override this.
4 COlor
LAbel # COlor #
   Cause the label to be plotted with color index #.  (Default is color
index 1.)
4 CSize
LAbel # CSize #
   Cause the label to be plotted with character size #.  (Default is
character size 1.0.)
4 Justify
LAbel # Justify Left|Center|Right
   Control justification of text string. (Default is left justify.)
4 LIne
LAbel # LIne # [#]
   Draw line at angle # (in degrees) from position to the label.
If the second number is specified, then it will be used as the length
of the line in viewport units. (Default line length is 0.08.) If no
number follows the "LIne" command, then the line is turned off.
4 LStyle
LAbel # LStyle #
   Control the line style of the line plotted, when the "LIne"
subcommand is used.  (Default is 1.)
4 Marker
LAbel # Marker #
Include marker # in the text line.  The default will produce a left
justified string just to the right of the marker.  If you then right
justify the string, then the string will appear to the left of the
marker.  In either case, the (x,y) position corresponds to the position
of the marker.
4 MSize
LAbel # MSize #
   Use the specified marker size with plotting the specified numbered
label.  Default size is 1.0.
4 Position
LAbel # Position # #
   Specify the (x,y) location of the string in world coordinates.
When using the "LIne" subcommand, "Position # #" gives the (x,y)
location of the position being `pointed at' with the text string at
the other end.  If the "Marker" subcommand is used, then "# #" refers
to the location of the marker.  For other cases, "# #" is the location
of the string.  The "CEnter" and "Justify" subcommands can later
override how text is plotted relative to a location.  (The default
location is (0,0).)
4 TExt
LAbel # TExt one=%1% two=%2%
   All the text on the line following the TExt subcommand becomes
the label.  The main difference between using simple " and using TExt
has to do with the command parsing.  Thus with LAb 1 "%1%" the label
would be the actual string %1% whereas LAb 1 TExt %1% would substitute
%1% with the first argument.
4 To
LAbel # To # #
Draws a line from the position specified with the Pos # # option to
the location in the To field.

NOTE: If you add a text label, the text will be plotted at the "To"
location.  This is for maximum compatibility with the "LAb # LI 45 .1"
command.

Example:

PLT> LAB 1 Pos 0 1 To 0 1 " "    ! Draw line from (0,1) to (1,0)
4 Rotate
LAbel # Rotate #
   Plot the label at an angle of # (degrees) relative to the x-axis.
(Default angle is 0.)
4 VPos
LAbel # VPos # #
   Specify the (x,y) location of the string in viewport coordinates.
When using the "LIne" subcommand, "Position # #" gives the (x,y)
location of the position being `pointed at' with the text string at
the other end.  If the "Marker" subcommand is used, then "# #" refers
to the location of the marker.  For other cases, "# #" is the location
of the string.  The "CEnter" and "Justify" subcommands can later
override how text is plotted relative to a location.

LAbel # VPos Curs
   Display the cursor at the current default position.  You can move
the cursor to the desired position using the standard (PGPLOT) cursor
keys.  Once at the location where you want the label, press the space
bar.  The next time the plot is drawn, the label will appear at the
new location.
4 examples
<PRE>
PLT> LAbel 1 "TEST"   ! Place the word TEST at location (0,0)
PLT> LAbel 1 P 10 10  ! TEST will now appear centered at (10,10)
PLT> LAbel 1 LIne 90  ! Draw a vertical line from the point (10,10) to
                      ! the word TEST.
PLT> LAbel 1 CO 3     ! Color line and word TEST green
PLT> LAbel 1 P 10 10 LIne 90 CO 3 "TEST"   ! Does all the above in a
PLT>                                       ! single command
</PRE>
2 LIne
LIne ON [glist]
   Draw a line connecting all the points in each plot group specified
in "[glist]".

LIne OFf [glist]
   Produce a scatter diagram by turning off the line for each plot
group specified in "[glist]".

LIne Stepped [ON] [glist]
   Produce a stepped-line plot for each plot group specified in "[glist]".

LIne # [ON] [glist]
   PLT always draws straight lines between mesh points and the default
is each data point corresponds to a mesh point.  When plotting a line
it is sometimes useful to use more mesh points than data points.
The LIne # will force PLT to use ABS(#) mesh points.  If # is greater
than zero, then the line is evaluated at # points between the current
x-scale Minimum and Maximum.  If # is less than 0, then the line is
evaluated at "ABS(#)" points between the Data Min and Data Max ---
i.e., no extrapolation is allowed.  If # equals 0, then the line is
evaluated at the data points. (This is the default.) If a mesh point
lies between two data points then a cubic spline using Akima
coefficients is used to evalute the location of the mesh point.  This
gives the illusion that a smooth line connects the data points.  Note:
this command will only work if the x values are strictly increasing.

Note:  If you set "Error OFf", "MArker OFf", and "LIne OFf", then
the line will still appear.  The only way to prevent data from being
plotted is to use the "COlor OFf" command.
3 examples
<PRE>
PLT> LIne ON         ! Use a line for all groups
PLT> LIne OFf 1,3    ! Turn off the line for groups 1 and 3
PLT> LIne Step 1,5   ! Plot groups 1 and 5 with a stepped line
PLT> LIne 200 ON 2   ! Plot 'smooth' line on 200 points over current X range
PLT> LIne -200 ON 3  ! Plot 'smooth' line over 200 points from data min
                     ! to data max
</PRE>
2 LOCation
LOCation # [# [# [#]]]
   The "LOCation" command allows you to control the location of the
currently active window.  The default location of all windows is
0. 0. 1. 1. which means that all windows overlap and use the entire
plotting surface.  This command in combination with the "WIndow" command
allows great control over where the windows are plotted.  Thus a small
window could be plotted inside a larger one.  However, no attempt
is made to erase a plotting region, so overlapping windows could result
in overlapping text.
3 examples
To create 4 windows in the 4 quadrants, use:
<PRE>
PLT> WIndow 1
PLT> LOCation 0 .5 .5 1.
PLT> WIndow 2
PLT> LOCation .5 .5 1. 1.
PLT> WIndow 3
PLT> LOCation 0. 0. .5 .5
PLT> WIndow 4
PLT> LOCation .5 0. 1. .5
</PRE>
2 LOg
LOG X|Y|X,Y ON|OFf [winlist]
   Controls whether a log scale is used when plotting in the windows
specified in "[winlist]".  Thus "LOG Y OFf 2 3 4", would turn off
the use of a log scale in the y direction in windows 2 3 and 4.  Also,
"LOG X,Y OFf 3" would turn off the log scale in both the x and y
directions when plotting in window 3.
2 LStyle
LStyle # [ON] [glist]
   Change the default line style for the plot groups specified in
"[glist]".  The first number is the style type.  Note, glist can
also contain 'Model' to change the line style when plotting the
current model, or 'Grid' to change the line style when plotting
the grid in the currently active window.

LStyle ?
   List possible line styles.
3 examples
<PRE>
PLT> LStyle 2 ON 3    ! Use line style 2 when plotting group 3
PLT> LStyle 1         ! Use solid line when plotting all groups
PLT> LStyle 5 ON 1,4  ! Use line style 5 when plotting groups 1 and 4
PLT> LS 2 ON 3,MOD    ! Use line style 2 when plotting group 3 and the
                      ! current model.
</PRE>
2 LWidth
LWidth # [ON] [glist]
   Set the line width to the value #.  Allowed values are 1 or greater.
On some laser printers, the default line width is very narrow and
so, using thicker lines will enhance the output quality.  If glist
is omitted then this command resets the default line width for the
entire plot.  If you list some group numbers in glist then the groups
listed in glist will no longer be plotted with the default line width
but rather with the line width you specified.  Also, glist can contain
the word 'Model' to change the default line width when plotting the
current model.
3 examples
<PRE>
PLT> LWidth 3         ! Triple the default thickness of all lines
PLT> HArd /PS         ! and make a hardcopy
PLT> LWidth 1 ON 2    ! Plot group 2 with line width 1.  The rest of the
                      ! plot will still be plotted with line width 3.
PLT> LW 3 ON MOD      ! Plot current model with line width 3.
</PRE>
2 MArker
MArker [#] ON [glist]
   Turn on the plotting of polymarkers.  The first (optional) number
is the marker type; if omitted the default marker type will not be
changed.  If "[glist]" is omitted, then markers will be used to plot
all plot groups.

MArker OFf [glist]
   Turn off the plotting of markers for all plot groups specified.
If "[glist]" is omitted, then markers will be removed from all groups.

MArker Size # ON [glist]
   Changes the size of the markers when plotting the plot groups
specified in "[glist]".  The size can range from 0.0 to 5.0, where
1.0 is the default.  Thus every plot group can have a different marker
size.

MArker ?
   Draw a table of all the PGPLOT markers on your current graphics
device.
3 examples
<PRE>
PLT> MArk 19 ON 2     ! Use marker 19 when plotting group 2
PLT> MArk OFF 2       ! No longer plot group 2 with a marker
PLT> MArk ON 2        ! Use default marker when plotting group 2
PLT> MArk ON          ! Use markers when plotting all plot groups
PLT> MArk Size 5      ! Plot markers 5 times larger than default size
</PRE>
2 MMaster
MMaster iwnum X|Y|XY wlist
MMaster iwnum Off

Use this command to slave the scales of the windows listed in the window
list (wlist) to that of the master.  For example if you use

MM 1 X  3 4 7

Then every time you change the X scale in window 1 then the X scales
of windows 3, 4 and 7 will also be updated to be the same as what is
in window 1.  Any attempt to change the X scale of windows 3, 4, and 7
for example using a "R X4" type command, will be ignored.
3 example
<PRE>
! Plot
WIN  1
LOC  0 .5 .5 1
YPL  1
! Create window 2 in upper right corner and put the model in it.
WIN  2
LOC  .5 .5 1 1
YPL  2
! Create window 3 in bottom left corner and put residuals in it.
WIN  3
LOC  0 0 .5 .5
YPL  3
! Sync everything to window 1
WIN  1
MM   1 xy 2 3
r    600 800 550 750  ! Scales for Windows 1, 2, and 3 are all affected.
</PRE>
2 MOdel
  See definition subtopic for help on creating models.

MOdel ?
   List all built-in model components.

MOdel @filename
   Cause the model definition and parameters to be read from the file
with name "filename".  Although chi^2 is written to the model file
it is important to refit before issueing an UNcertain command.  This
is to avoid potential problems with roundoff errors.

3 definition
   A model consists of several components that are added together.
For example, "MOdel CONS LINR QUAD" will add a constant term, a linear
term, and a quadratic term.

For each parameter required by the "MOdel" command, you will be prompted
for four numbers --- "VAL", "SIG", "PLO", and "PHI" --- as described below.
For each parameter, you should enter an initial value for "VAL"; but
you can usually default on the other three numbers.

  "VAL":  This is the actual value of the parameter.  Although CURFIT
will often find  the the best set of parameters to model the data, it
never hurts to start it with parameters near the expected best fit.

  "SIG":  Any value of "SIG">=0 will not affect the outcome of "Fit".
After you fit the model, "SIG" will contain the one-sigma curvature
errors.  This number is used by the "Uncertainty" command to start
a formal error determination.  If the "Uncertainty" command fails
to converge because the original error estimate is wrong, sometimes
you can improve the convergence by adjusting "SIG" to be a better
estimate before using "Uncertainty".  If you set "SIG=-1", then the
parameter is frozen such that CURFIT is not allowed to change the
parameter value while fitting.  If you set "SIG"=-IPAR, the next number
("PLO") will default to 1, such that the current parameter value is
forced to equal the value of parameter IPAR.  (Note:  IPAR can not
equal 1 or the current parameter number.)  If you place a number (N)
after "SIG", this will force the current parameter to be N times the
specified parameter. (N defaults to 1.0.)

PLT> MOdel GAUS GAUS
  1, GC: VAL( 1.00), SIG( 0.00 ), PLO( 0.00), PHI( 0.00)?
,-4,2
  2, GW: VAL( 1.00), SIG( 0.00 ), PLO( 0.00), PHI( 0.00)?

  3, GN: VAL( 1.00), SIG( 0.00 ), PLO( 0.00), PHI( 0.00)?

  4, GC: VAL( 1.00), SIG( 0.00 ), PLO( 0.00), PHI( 0.00)?
 2.
  5, GW: VAL( 1.00), SIG( 0.00 ), PLO( 0.00), PHI( 0.00)?

  6, GN: VAL( 1.00), SIG( 0.00 ), PLO( 0.00), PHI( 0.00)?

defines a model consisting of two gaussians, with the x values of
the centers differing by a factor of 2.  Although you did not enter
a value for parameter 1, it will be set to the value of 6 (2 times
value of parameter 4).  This relation will be maintained throughout
a fit.

  PLO, PHI:  If SIG>=0 and if PLO<PHI, the parameter value is
constrained to lie in the range PLO to PHI.  Note:  If PLO and PHI
are both the same (say equal to zero), then the parameter will not
be constrained in any way.  In general, if you have difficulty fitting
some data, the best thing to do is to freeze some parameters near
to their expected values and then fit the reduced parameter set.
When a good fit has been found with the reduced set, thaw some of
the parameters and refit.  If this method does not work, then you
may be forced to use PLO and PHI to limit certain parameters to a
meaningful range.

PLT> MOdel ? will list all builtin model components.
3 2D_models
PLT can fit functions to two dimensional data.  In general this is
best done with a COD file using the Y variable.  A few common, simple
functions are provided below.
4 CGau
Circular Gaussian:

FNY=FNY+Gn*EXP(-[xs**2-ys**2]/2.)

where xs=(X-Xc)/Gw, ys=(Y-Yc)/Gw, and with integral SQRT(2*PI)*Gn*Gw*Gw.
4 NCga
Normalized Circular Gaussian.  Similar to CGau except the norm is now
the integral:

FNY=FNY+Gn*EXP(-[xs**2-ys**2]/2.)/(2.*PI*Gw*Gw)

where xs=(X-Xc)/Gw, ys=(Y-Yc)/Gw, and with integral SQRT(2*PI)*Gn*Sx*Xy.
4 EGau
Ellipical Gaussian:

FNY=FNY+Gn*EXP(-[xs**2-ys**2]/2.)

where xs=(X-Xc)/Sx, ys=(Y-Yc)/Sy, and with integral SQRT(2*PI)*Gn*Sx*Sy
4 NEga
Normalized Ellipical Gaussian.  Similar to EGau except the norm is now
the integral:

FNY=FNY+Gn*EXP(-[xs**2-ys**2]/2.)

where xs=(X-Xc)/Sx, ys=(Y-Yc)/Sy, and with integral Gn.
4 LY
Linear in Y

FNY=FNY+Ly*Y

Note the general model for a plane is

Li*(X-Xc)+Ly*(Y-Yc)+b

Expand and collect terms to get

Li*X+Ly*Y+b-Li*Xc-Ly*Yc

Which would be created with a MOdel of 'LI LY CO' and the CO would be
set to an initial value of b-Li*Xc-Ly*Yc.

Note, the maximum slope of the plane would be in the direction ATAN2(Ly,Li).
3 CONS
Select a model with a constant component:

FNY=FNY+CO.
3 LINR
Select a model with a linear component:

FNY=FNY+Li*X.
3 QUAD
Select a model with a quadratic component:

FNY=FNY+QU*X**2.
3 CUBI
Select a model with a cubic component:

FNY=FNY+CU*X**3.
3 X4
Select a model with an x^4 component:

FNY=FNY+X4*X**4.
3 X5
Select a model with an x^5 component:

FNY=FNY+X5*X**5.
3 POWR
Select a model with a power-law component:

FNY=FNY+PN*X**IN.
3 SIN
Select a model with a sinusoidal component:

FNY=FNY+SN*SIN(2*PI*(X-PH)/PE).
3 GAUS
Select a model with a gaussian component:

FNY=FNY+GN*EXP(-Z*Z/2.),

where Z=(X-GC)/GW and with integral SQRT(2*PI)*GN*GW.
3 EXP
Select a model with an exponential component:

FNY=FNY+EN*EXP(-(X-EC)/EW).
3 AEXP
Select a model with a symmetric exponential component (exp(-|x|) for
all x):

FNY=FNY+EN*EXP(-ABS(X-EC)/EW).
3 BURS
Select a model with a burst component (linear rise followed by an
exponential decay):

FNY=FNY+0 for X<ST;
FNY=FNY+BN*(X-ST)/(PT-ST) for ST<X<PT; and
FNY=FNY+BN*EXP(-(X-PT)/DT) for PT<X.
3 SBUR
Select a model with a smooth-burst component:

FNY=FNY+BN*(T^RR)*EXP(-(X-TS)/DT),

where T=EXP(1)*(X-TS)/(RR*DT), such that SBUR = BN at the peak.
3 PEAR
Select a model with a Pearson-function component:

FNY=FNY+K*(F1^M1)*(F2^M2),

where F1=[1.+(X-X0)/A1] and F2=[1.-(X-X0)*M1/(A1*M2)].
3 WIND
Select a model with a window-function component:

FNY=FNY+LE for T1<X<T2; and
FNY=FNY+0 otherwise.
3 KING
Select a model with a King-profile component:

FNY=FNY+S0*(1.+(X/RC)^2)^(-IN).
3 LORE
Select a model with a Lorentz-profile component:

FNY=FNY+LN/(1.+[ 2.*(X-LC)/LW ]^2),

where LW is the full width at half maximum (FWHM) and the integral
is PI*LN*LW/2.
3 SPLN
Select a #-knot spline component.  The number of knots defaults to 2,
which generates a straight line.  The spline is computed by solving
equation 3.3.7 in the 1988 edition of Numerical Recipes, by Press,
Flannery, Teukolsky, and Vetterling.

For unconstrained y values, the natural spline condition is imposed,
which sets y''=0 at the boundaries.  You may not extrapolate this
function outside the interval fitted.

It is possible to impose a periodic boundary condition on the spline
curve.  To do this, constrain the y position of the last knot to be
the same as the first.  When this constraint is detected, the program
automatically forces the first derivatives to match at the two
boundaries.  For this case, you are allowed to access the function
outside the interval fitted.  However, the function is assumed to be
periodic, with the period given by the difference in x between the
first and last knots.

For example, "MOdel SPLN 5" will generate a 5-knot spline (10
parameters).  The spline can be added to other models; thus
"MOdel SPLN 5 GAUS" would add a 5-knot spline to a gaussian.  Hence,
the spline would model the `background' and the gaussian, a `line'.
4 problems
It is possible for the x position of two knots to lie between two
adjacent data points.  This results in a local chi^2 minimum as the
lower knot adjusts to fit data below it, the upper knot adjusts to
fit data above it.  A strong wiggle occurs between the two knots but
since there are no data points there, chi^2 is not affected.  In this
section, two knots very close to each other will be called a collision.
If collision occurs during a fit, then convergence will be very slow.

One method to greatly reduce the number of collisions is to first
fit the y locations before attempting to fit the x locations.  By
default, the knots are evenly spaced in the x direction and are not
allowed to vary.  For the first "Fit" you should leave the x positions
frozen, although you can move the knots (using "Newpar") to concentrate
them where the function is changing rapidly.  Once a reasonable set
of y positions is determined you can then thaw the x positions and
re-fit.  You should never thaw the end points:  They determine the
range over which the spline is to be evaluated.

With the above recipe, collisions can still occur.  The straight-forward
method to separate the knots is:  Use "Newpar" to re-position the two
knots, freeze the x locations, and then re-fit.  After this the knots
will sometimes stay separated when you thaw their positions and re-fit.
The trick is to force the knots far enough apart so that they will
not be attracted to the local minimum, but not so far apart as to grossly
distort the fit.

Sometimes two knots collide when you are trying to fit the data with
too few knots.  This case can be easily tested for by increasing the
number of knots and re-fitting.
3 AKIM
Select a #-knot Akima component.  An Akima component is very similar
to "SPLN" in that both use a cubic function to interpolate between
the knots.  Akima's method does not introduce false extrema and
inflection points as does the cubic spline and therefore, is far
superior for data that show abrupt transitions.  Details of Akima's
method can be found in ``A new method of Interpolations and smooth
curve fitting based on local procedures'' by Hiroshi Akima in J.
of the Ass. for Computing Machinery, (1970) 17, 589-602.  (An
implementation is described in PPC Journal, (1985) 12, no. 10, 11-14).

Like "SPLN" two different boundary conditions are allowed.  If the
last y value is unconstrained, then the code uses `virtual' knots
outside the boundaries to determine the function at the boundaries.
The locations of the virtual knots mirror the location of the knots
just inside the boundaries.  If the y position of the last knot is
constrained to match the y position of the first knot then a periodic
boundary condition is imposed.
4 problems
3 DEMO
Call the Fortran user-defined component.  The QDP/PLT User's Guide
describes how to create how to write a Fortran function that can
be linked in to PLT to replace the "DEMO" component.
3 $codfile
Call the user-defined COD (COmponent Definition) function found in
"codfile.COD".  Briefly, a COD function is a program written in a
Forth-like computer language.  To understand COD, read the documentation
or the on-line help for COD.  A COD file can be added to any combination
of built-in components.  For example, the model specified by "MOdel
CONS LINR $TEST" would calculate the sum of a constant term, a linear
term, and the value of the COD function contained in the file
"TEST.COD".

At the present time only one COD function can be defined in a model,
although this function can be referenced more than once.  If you wish
to combine two COD functions, you will need to write a third function
that combines the first two.

COD should be used for all simple components that cannot be expressed
by adding together the built-in components.  Since a COD function
is interpreted, it will run slower than the user-defined component.
However, since COD is highly efficient and supports many mathematical
functions, it is expected that the interpreter will be good enough
for most purposes.  For large numbers of points (> 10^4) or models
that involve reading a disk file, the user is advised to write a Fortran
function using the user component.
4 example
<PRE>
: NGAUS ! The file must contain a : followed by a dummy name
X       ! Push current value of X onto the stack
X       ! Push current value of X onto the stack
*       ! Multiply the top two numbers on the stack to get X*X
P1      ! Push the value of parameter 1 onto the stack
*       ! Multiply to get P1*X*X
NEG     ! Negate the number on the top of the stack (-P1*X*X)
EXP     ! Calculate EXP of -P1*X*X
P2      ! Push the value of parameter 2 onto the stack
*       ! Multiply to get P2*EXP(-P1*X*X)
;       ! The function must end with a ; character
</PRE>
This simple COD function ("NGAUS.COD") contains two parameters and
calculates the value of "P2*EXP(-P1*X*X)".  It could be written much
more concisely as

: NGAUS X X * P1 * NEG EXP P2 * ;
2 Newpar
Newpar
   Display the values associated with all of the parameters and allow
the user to change them.  If you wish to display the parameter values
without changing them, then use the "WModel" command.

Newpar #
   Display the values associated with the parameter specified by the
first argument.  You can either enter return, leaving the parameter
values unchanged, or enter new values.

Newpar # #
   Change the value of the specified parameter to the value you entered
in the second (and following) arguments.  You will not be shown the
original values.
3 examples
<PRE>
PLT> Newp 2      ! Prompt for new values of parameter 2
  2, GW: VAL( 1.00), SIG( 0.00 ), PLO( 0.00), PHI( 0.00)?
3.               ! Value of parameter 2 is now set to 3
PLT> Newp 3 10   ! Value of parameter 3 is now set to 10
PLT> Newp 6,,-1  ! Freeze value of parameter 6
</PRE>
2 PAper
PAper # #
  Resets the default size and aspect of the display/printing surface.
The first number is the width of the plot in cm, the second number is
the aspect ratio (height/width).  This command uses the PGPLOT internal
value for the resolution of the graphics device, and for some device
types (such as displays) is only approximate.  Some device types
will ignore attempts to change the size.

Use PAper 0 0 to reset to the default page size.  Due to the way PGPLOT
works, you may need to issue the CPD command to reinitialize the
device to the correct default.
2 Plot
Plot
   Cause the plot to be redrawn on the graphics device.

Plot All
   Cause all data points, including those flagged as no-data, to be
plotted.

Plot Good
   Undo the effects of the "Plot All" command and prevent plotting of
points flagged as no-data (default).

Plot Vertical
   Plot up to 20 plot groups in separate panels, in a vertical stack.

Plot Overlay
   Plot all groups in a single panel (default).

Plot Zero ON
   Cause the plot groups that have color index zero to be plotted
with the background color.  This is sometimes useful for erasing plots.

Plot Zero OFf
   Do not plot groups with color index zero (default).  This is much
faster than plotting with the background color.
3 Vertical
   Plot groups in separate windows in a vertical stack, with one plot
group plotted in each window.  For maximum compatibility with earlier
versions of PLT, the windows are number with the group number.  Thus
group 3 is plotted in window 3.  This allows commands like Rescale Y3
to rescale the window containing group 3.

After you execute the Plot Vert command all the windows are treated
as a single entity for both the `Rescale X' and `LAbel X' commands.
Thus after a Plot Vert, using a Rescale X command will cause all visible
windows to have the same X scale.  Likewise, LAbel X will place the
X label on the bottom window of the stack.  This behavior will continue
until you use the Window # command to select a given window, afterwhich
the Rescale X and Label X commands will only affect the selected window.
The WIndow All command can be used to restore the behavior where
Rescale X affects all windows.  The only way to restore the LAbel X
behavior is to reissue the Plot Vert command.
2 PRompt
PRompt $
   Redefine the ``PLT>'' prompt.
2 Rescale
Rescale X [#] [#]
   Reset XMIN and XMAX in the current window to the values specified.
both XMIN and XMAX are omitted, then PLT will reset the range to
the default.

Rescale Y [#] [#]
   Reset YMIN and YMAX in the current window to the values specified.
If both YMIN and YMAX are omitted, then PLT will reset the range to
the default.

Rescale [#] [#] [#] [#]
   Reset XMIN, XMAX, YMIN, and YMAX in the current window to the values
specified.  If all four numbers are omitted, then PLT will reset both
the x- and y-ranges to the defaults.

Rescale ?
   Display the current XMIN, XMAX, YMIN, and YMAX values for each
window.

Note:  For Vertical plots each window can be specified separately;
thus "R Y1" will rescale the y-range in window 1 and "R Y4" will
rescale the y-range in window 4.
2 SCr
SCr # # # #
   Immediately change the color representation for the specified color
index.  The first number is the color index and the following three
numbers give the red, green, and blue color intensities and must lie
in the range 0.0 to 1.0.  This command only works on color devices
for which the color representation can be changed.

For color indices 0-15, the color representation you set will become
the new default for as long as you stay in PLT.  This means the HArdcopy
command will show the colors you have set (if the device is capable).
To restore the original default colors use set the Red color value
to NO and then reissue the cpd command.  Thus to restore the default
color representation of color index 2 on your default /xs device,
use:

PLT> SCR 2 NO
PLT> CPD /xs
PLT> P

Note, for PostScript files, color index 0 is *anyways* transparent
and thus the color of the paper.  I.e., there is no way to change
the background color (other than loading different color paper in
the printer) for PostScript files.  If you want to change the background
color, use the /PNG device.
3 Black/White/Default
SCr [Black|White|Default]
   This allows PLT to override the default PGPLOT background color.
In particular, /XS and /GIF devices produce white lines on a black
background, whereas a PostScript hardcopy would be black lines on
white paper.  Thus

PLT> SCr White

will always force the background to be white.  Note, SCr Black is
not recommended as it would require white toner and black paper in
order for it to work with PostScript devices.  SCr Default restores
the default behavior where PGPLOT picks the background color.
3 examples
<PRE>
PLT> SCR 0 1. 1. 1.  ! Set the background color to be white
PLT> SCR 1 0 0 0     ! Plot color index 1 in black
PLT> SCR 2 0 1 0     ! Plot color index 2 in green
</PRE>
3 SEt
Allows user to set various PLT internal variables.  Currently you
can only set the maximum length of lines written with the WData command.

PLT> SEt LEngth 64    ! Don't write lines longer than 64 characters.
2 SHow
Allows user to show the current values of various PLT internal
variables.  Currently you can only show the maximum length of lines
written with the WData command.

PLT> SHow
LEngth   256 ! Maximum length of lines written with the WData command.
2 SKip
Most PLT commands operate on `groups' of data points.  The default
is for each vector of the input data to be in a separate group.  For
the default mode, commands like "COlor" and "MArker" affect the
appearance of an entire vector.  Using the "SKip" command, it is
possible to independently control the appearance of sub-sets of data
within a single vector.  Thus, when using "SKip", a single y vector
can be divided into several plot groups that can be independently
controlled with "COlor", "MArker", "R Y1", etc.  Currently, "SKip"
should only be used when the input data consists of two vectors as
the other vectors will not be plotted.  Note, "SKip" cannot affect
whether a data point has an error associated with it.

SKip OFf
   Each vector of the input data is plotted as a separate group
(default).

SKip Single
   A new plotting group begins every time x-coordinate equals "NO" (the
no data flag) ONE or more consecutive times.  "SKip Single" is useful
when you wish to plot different groups with different markers.

SKip Double
   A new plotting group begins every time x-coordinate equals "NO" (the
no data flag) TWO or more consecutive times.  "SKip Double" is useful
when you wish to plot different groups using lines that contain breaks.
3 example
Consider the QDP file:

<PRE>
  1  2
  2  1
  NO NO
  3  4
  4  3
  NO NO
  NO NO
  5  6
  6  5
</PRE>
With the default "SKip Off", the above will be plotted as two groups
each containing nine points.  Using "SKip Single", would cause the above
data to be divided into three groups.  The first group would consist
of the data in the first three lines, the second would come from lines
four to seven, and the third group from lines eight and nine.  Using
"Skip Double" would cause the above data to be plotted as two groups
with lines one through seven being in the first group and the last
two lines making the second group.
2 STatistics
STatistics [fgroup]
   where "[fgroup]" is the default group for fitting.  This
command causes a short table to be printed on your terminal that
displays some basic statistical properties about that group of data.
The first line tells you which group is fitted and over what range.
Next the unweighted average, variance, and 3rd moment are displayed.
For the unweighted data, the column labeled "SUMW" contains the total
number of points used in the calculation, for weighted data, "SUMW"
is the sum of the weights.  "YMIN" and "YMAX" are the minimum and
maximum data values in the range.  If the plot group has errors
associated with it, then weighted values of the average, variance,
and 3rd moment will be displayed.  The next row contains "WCHI" and
"WRED" which are the chi^2 and reduced chi^2.  The "W" is appended
to remind you that the actual errors on the data were used.  The line
labeled "Sum of Y*XDEL" contains the sum of the y values times the
Delta x values, where Delta x is given by the x-error bars.  This
is a rectangle rule integral of the data.  The last line gives the
(unweighted) linear correlation coefficient of the y vs. x data.

For maximum accuracy, this routine makes two passes through the data,
once to calculate the average, and the second time to calculate moments
based on the difference between the data and the average.

If you don't understand the difference between the unweighted and
weighted values then you should use unweighted quantities.
3 example
<PRE>
PLT> STat
Group  2, from   430.0    , to   540.0

        YBAR        YVAR        Y3M         SUMW       YMIN        YMAX
UNWTD  0.5915      0.1341     -8.3771E-03   23.00     2.2100E-02   1.096
  WTD  7.8728E-02  2.0009E-02  1.2435E-02  4.9056E+05
 WCHI=  9.389E+03,  WRED=  426.768

     Sum of Y*XDEL=   0.883411
Correlation coeff.=  -0.853596
</PRE>
2 THaw
THaw [plist]

Can only be used after a model has been defined.  This command
causes all parameters listed in "[plist]" to be thawed, which means
the parameter value will be allowed to vary when fitting.
3 examples
<PRE>
PLT> THaw 2         ! Cause parameter 2 to be thawed
PLT> THaw 3..5 9    ! Cause parameters 3 through 5 and 9 to be thawed
</PRE>
2 Time
Time ON

Cause the date and time to be plotted in the lower right corner
(default).

Time OFf

Remove the date and time from future plots.
2 Uncertain
Uncertain [# [# [#]]]

Vary the specified parameter(s) in order to estimate their
uncertainties.  Each specified parameter, in turn, is stepped and
chi^2 is minimized.  Stepping stops when the requested value of
Delta chi^2 is obtained.  "Uncertain" can take up to 3 numbers as
arguments.  If one number contains a decimal point, then that number
is interpreted as the requested value of Delta chi^2 (which for the
first time defaults to 2.7 and for later times defaults to the previous
value).  The remaining two numbers in the "Uncertain" command specify
the lower and upper parameter numbers for which you want to estimate
the error.  If only one number is given (without a decimal point),
then the error is generated only for a single parameter.  If errors
are currently turned off (or do not exist), then the routine works
out a correction factor that converts the W-VAR to chi^2.
2 UPper
UPper # ON [glist]
   If a number in one of the groups specified in glist is less than
# sigma from zero, then plot that number as a #-sigma upper limit.
3 example
<PRE>
PLT> UPper 2.7 ON 3   ! When plotting group 3, all numbers within 2.7
PLT>                  ! sigma of zero will be plotted as an upper limit.
</PRE>
2 VErsion
VErsion
   Return the date of last modification to the current version of PLT.

<PRE>
2015-06-12 - Call FRELUN if WModel command fails.
2015-06-11 - 'Model insensitive to parameter' had gone away...
2014-02-04 - Fixed bug reading mal-formed model (.mod) files.
2012-11-05 - Ignore NO data values when plotting residuals.
2012-03-23 - Additional check when reading CMD array.
2011-04-20 - Internal bug fixes.
2011-01-14 - SCR B/W does not restart plot device.
2010-11-10 - Fix bug in SEt LEngth command.
2010-09-23 - Add the LY (Linear in Y) component.
2010-07-13 - Fix plotting bug when SKip ON reduces the number of groups.
2010-07-13 - Fix format for WHead with IMAge MIN less than zero.
2010-06-30 - If FPNUM finds an error, it now returns NO (was 0.0).
2010-06-03 - Fix another image related WH bug.
2010-06-01 - SCR (for indices 0-15) is remembered.
2010-05-28 - Several fixes to WH command.
2010-05-26 - Another XAX/SKIP bug fixed.
2010-05-20 - Fix 20 year old error in example fig04.pco.
2010-04-23 - CURFIT would randomly pick 0.001 as a stopping condition.
2010-03-29 - Xaxis # refers to vectors not groups (software and doc).
2010-03-25 - New SEt/SHow to change maximum length of lines written with WD.
2010-03-24 - Fix potential infinite loop in spline/akima components.
2009-07-02 - When FIT plots final model, it no lonver redraws the labels.
2009-03-10 - Increase MXLAB to 200.
2008-12-16 - Splines handle too many knots before asking user for all pars.
2008-03-17 - LAb # To now works correctly with log coordinates.
2007-09-17 - Increase MXLAB to 100.
2007-04-05 - Contour plots written with WE should now work.
2007-02-02 - Upper limits now plot correctly on LOG scale.
2007-01-08 - The sequence Fit/UN/Fit now works with splines.
2007-01-08 - MO @file/UNcer 2 is now illegal (and never worked correctly).
2006-08-31 - STat command works again.
2006-08-30 - Fit now works if x coordinate is decreasing.
2006-04-10 - Fit Plot -100 (negative number) should now work (again).
2005-09-22 - CURFIT now always writes out the "model insensitive to" error.
2005-08-24 - YAX LIN now affects groups not windows (like XAX LIN).
2005-08-15 - WM adds parameter numbers as comment, mo @ ignores comments.
2005-06-29 - Fix use of GETLUN/FRELUN when using WEnvir.
2004-07-22 - Add LAb # Pos x1 y1 To x2 y2 option.
2004-02-27 - Fix bug that caused "LAb 1 VPort Curs" to fail.
2004-02-24 - Fix bug that prevented same COD file from being used twice.
2004-02-04 - In cod functions, "ASLO" no longer matches "ASin".
2004-01-22 - Fix case where MA ? would be displayed in background color.
2003-07-21 - LIne Step now works if X-coordinate is decreasing.
2003-07-17 - Fix crashes when user uses an undefined group.
2003-04-15 - GRid ON now works with images.
2002-08-02 - Fix bug where PLT incorrectly decides no points are in fit range.
2002-04-02 - Model is now plotted for entire displayed range not fitted range.
2002-03-21 - Add CGau and NCGa built-in functions.
2002-03-19 - SCR [White|Default|Black] added to set default background color.
2002-03-18 - Cursor keys now work with xterms (change to cget.f).
2002-01-22 - STat and IMOdel commands now works with 2D groups.
2002-01-22 - Y range limit implemented for 2D fitting.
2002-01-22 - Fix calling of PLTSVW from PLTCUR routine.
2002-01-17 - Increase to MXPAR=120, MXFREE=100 (computers are faster).
2001-07-18 - "err sq y", "gap err", "r y" now correctly sets the scale.
2001-04-30 - rdqdp now ignores blank lines.
2001-04-23 - YPL # no longer "forgets" if # had been DG'ed to be a 2D group.
2001-04-23 - WH does a better job at writing DG commands.
2001-03-29 - Fix bug in COD a2tn function incorrectly testing for 0,0 case.
2000-10-06 - Fix LAB # ma 2 lin 90 .02 failing on some devices.
2000-10-04 - If using XAX LIN; ERR OFF; STAT, then sum Y*XDEL will be correct.
2000-08-23 - Initilize the fit group var before it is used...
2000-08-10 - Error [X,Y] Gehrels sets the error to 1+SQRT(0.75+N).
2000-08-08 - Error X Sq now works again.
2000-07-03 - bug fix, can now see fits to groups.GT.10.
2000-06-15 - "LIne # on" now works again.
2000-06-14 - If X value is NO then point is ignored in fitting, etc.
2000-02-18 - Fix contour bug that sometimes prevented contours from appearing.
2000-01-25 - DGroup #; XAX # now works correctly.
2000-01-13 - IMA CCT file, now searches same path as scripts.
1999-09-09 - Fix default plotting when using SKip ON, sigh.
1999-09-05 - Scale the CURFIT errors when using "ERR OFF/FIT STAT CHI".
1999-09-05 - Fix bug when using "ERR OFF/FIT STAT ML".
1999-09-05 - Initialize variable qhard to make g77 (and others) happy.
1999-05-20 - DGroup 4 Res; YPlt 4 now work for line plots.
1999-05-17 - Fix bug introduced by inline models.
1999-05-11 - Fix default plotting when using SKip OF.
1999-04-29 - Make inline model files more transparent.
1999-04-22 - Add optional call to hdecod to rdqdp.f.
1999-04-21 - Can include model parameters in QDP files by enclosing in quotes.
1999-04-16 - Add the MMaster commend.
1999-04-15 - WH now writes DGroup commands.
1999-04-14 - Fix bug when WH writes R X command.
1998-12-17 - Line Step now works (again) if no X error bars
1998-11-25 - Groups can now have independent LOG/LIN/SQRT image scaling.
1998-11-18 - DGroup [Model|Residuals] now working properly.
1998-10-06 - PLT no longer does an "Error OFf" if plotting > 2000 points.
1998-10-05 - Redid internal data structures for the X coordinate.
1998-10-01 - Fixed up Fit Stat ML (see HElp FIt statistics for details)
</PRE>
2 Viewport
Viewport  #,[#,[#,#]]
   Control location of the viewport in normalized device coordinates,
where (0.0,0.0) is the bottom left corner and (1.0,1.0) the top right
corner.  The default viewport is 0.1 0.1 0.9 0.9, with the first two
numbers giving the location of the bottom left corner and the next
two numbers, the upper right corner.  If you use "Viewport" with and
only specify two numbers then PLT centers the viewport about the center
of the plot, thus "View x,y" is the same as "View x,y,1.0-x,1.0-y".
If you do not wish to center the viewport, then you can specify all
four numbers, where the last two numbers refer to the top right corner.
3 examples
<PRE>
PLT> View .4 .4        ! Viewport extends from (.4,.4) to (.6,.6)
PLT> View .8 .8 .9 .9  ! Use small viewport in top right corner
PLT> View .1 .1        ! Go back to the default viewport
</PRE>
2 WData
WData [$]
   Write all data between the current x-scale minimum and maximum
to a QDP file.  If you want all the data to be written to the file
then you should use the "R X" command to reset current scale to include
the minimum and maximum data values.  A blank file name will cause
the data to be written to your current terminal screen.

The "WData" command will not write any PLT commands to the file.
However, it will include a reference to an indirect file.  For example,
"WData TEST" will create a file called "TEST.QDP" that includes the
line "@TEST".  The PLT command "WHead" can be used to create a "TEST.PCO"
file that contains all the PLT commands needed to re-create the current
plot.

WData [$] #
   Write the data with only # digits of accuracy (numbers will be
rounded).  If # is negative, the error on a number is written out to
(-#) number of digits and the number itself is written to the same
accuracy.
3 examples
<PRE>
PLT> WData          ! Write the data to the terminal screen
PLT> WData TEST     ! Write the data to TEST.QDP
PLT> WData TEST 3   ! Write the data (3 significant digits) to TEST.QDP
PLT> WData TEST -2  ! E.g., 123.758 +/- 2.698 will be written 123.8 2.7
PLT> WData,,-2      ! As above, but written to the terminal screen.
</PRE>
2 WEnviron
WEnviron [$]
   This command does the same thing as if you entered a "WHead" command
followed by a "WData" command.  This command should be used if you
want to save both the current data and the PLT commands needed to
re-create the current plot.
3 examples
<PRE>
PLT> WEnvir         ! Write commands and data to the terminal screen
PLT> WEnvir TEST    ! Create TEST.PCO and TEST.QDP files
PLT> WEnvir TEST 3  ! Write the data (3 significant digits) to TEST.QDP
PLT> WEnvir TEST -2 ! E.g., 123.758 +/- 2.698 will be written 123.8 2.7
PLT> WEnvir,,-2     ! As above, but written to the terminal screen.
</PRE>
2 WHead
WHead [$]
   This command only writes the list of PLT commands needed to create
the current figure.  Since this command will NOT write any data, it
will run faster than the "WEnviron" command.  Typically one would
first use "WEnviron" to write both the PLT commands and the data to
files.  If any changes are made to the appearance of the plot
(such as adding labels, etc.) then the "WHead" command can be used
to update the PLT command file without over-writing the QDP file
containing the data.
3 examples
<PRE>
PLT> WHead          ! Write commands to the terminal screen
PLT> WHead TEST     ! Write commands to TEST.PCO
PLT> WHead TEST 3   ! Same as previous (the 3 is ignored)
</PRE>
2 WIndow
WIndow #
   This command sets the currently active window to be the number
specified by #.  After the window command has been issued, commands
like "Rescale X", "LA Y" will affect the currently active window.
For maximum compatibility, a "Plot Vertical" command creates N windows
numbered by the number of the plot group that they contain.  Thus
if group 1 is used on the x-axis, then the upper (first) window plotted
will contain plot group 2 and will be plotted in window 2.

To return PLT to the default mode where commands affect all windows,
use the "WIndow All" command.
2 WModel
WModel [$]
   Write the current model into the named file.  The model written
out can later be read with the "MOdel @filename" command.  If you do
not enter a file name, the model will be written to your terminal
screen.  Since all significant digits are written, writing a file
provides a good way to save your current "MOdel" parameters.
If you have previously "Fit" the data then this command will write
two additional lines at the end of the model file as comments.  These
lines contain the WVAR and NBIN determined in the most recent fit.
2 Xaxis
Xaxis #
   The X-axis can be any column containing coordinates (not errors)
in the original data.  Errors are considered to be attached to the
coordinate and a coordinate with any errors is called a vector.  Thus
"Xaxis 3" will use the 3rd vector to define the X-axis.  Note, different
plot windows can have different defining X coordinates.

Xaxis Linear # #
   Cause the x variable to be a linear function.  Thus, the command
"Xaxis Linear 10. 1" would cause the first point to be plotted at
x=10, the second point at x=11, the third at x=12, etc.
2 YAxis
Yaxis Lin # #
   Specify the y-axis coordinate to be used in the current plot
window.  This is only useful when plotting 2D data.
3 example
Assume you have a 10 by 10 array of data, then the commands then
<PRE>
PLT> Xax L 10 1  ! Would cause the X values to range from 10 to 19
PLT> Yax L 5 1   ! Would cause the Y values to range from 5 to 14
PLT> CON Lev 1,2,3 ! Draws a contour plot with these scales
</PRE>
2 Yplot
Yplot [ON|OFf] [glist]
   where "[glist]" is a list of plot groups.  This command is more
intuitive to naive users than the "COlor ON|OFf" command.  This command
causes the plot groups specified in "[glist]" to turned on (plotted)
in the currently active window.
2 $
$ [command]
   Spawn to the operating system, where "[command]" is an operating
system command.  If no command is specified, then a system shell is
created that will allow you to enter several commands until you logout
(under VMS) or exit (under UNIX or DOS).
3 examples
<PRE>
PLT> $       ! Spawn to system
Spawning...  ! Wait for something to happen
$ # enter UNIX commands
$ exit
PLT>         ! You have now returned to PLT
PLT> $ ls    ! This will display your current directory
Spawning...  ! Wait for something to happen
(directory appears here)
PLT>         ! and you are left in PLT.
2 @
</PRE>
@ $<BR>
   Execute commands from an indirect command file.  Command files
can be nested to a depth of 10.  The default file type is ".PCO" (for
Plt COmmands).
3 example
PLT> @nice   ! Execute the PLT commands in the file nice.pco
2 fortran
PLT is a Fortran program with the following calling sequence:
<PRE>
      SUBROUTINE PLT(Y, IERY, MXROW, NPTS, NVEC, CMD, NCMD, IER)
      REAL      Y(*)
      INTEGER   IERY(*), MXROW, NPTS, NVEC, NCMD, IER
      CHARACTER CMD(*)*(*)
C---
C General plot subroutine.
C---
C Y(*)      I    The data array.  The array should be dimensioned
C                Y(MXROW,MXCOL) where MXROW and MXCOL are the actual
C                sizes of the arrays in the calling program.
C                MXCOL=NVEC+NSERR+2*NTERR  where NSERR is the number
C                of vectors that have symmetric errors and NTERR
C                is the number of vectors that have two-sided errors.
C IERY(*)   I    =-1 plot errors as SQRT(Y)
C                = 0 no errors.
C                =+1 explicit symmetric errors.
C                =+2 for two-sided errors
C MXROW     I    The actual first dimension of the Y array.
C NPTS      I    The number of points to plot (NPTS<=MXROW).
C NVEC      I    The number of vectors to be plotted.
C CMD(*)    I    Array of commands.
C NCMD      I    Number of commands.
C IER         O  Error flag, =-1 if user entered EOF, =0 otherwise.
</PRE>
2 history
The QDP/PLT program has evolved over a long period. In the late
1970's Andy Szymkowiak wrote a QDP (Quick and Dirty Plotter) program
for the PDP 11/70 used by the X-ray group at Goddard Space Flight
Center.  This original QDP would read an ASCII file and produce a plot
on a Vector General device.  It was then possible for the user to
issue commands interactively that would affect the appearance of the
plot.  When the user achieved the desired plot, it was a simple
matter to produce a `hardcopy' of the plot on a Versatec printer/
plotter.</PRE>

I, Allyn Tennant, quickly adopted QDP and started to add some new
features to it.  In 1983 I moved from Goddard to Cambridge, England
to join Andy Fabian's group, and took along the idea of QDP program.
Rather than port the existing code, it was decided it would be best
to start over and to rewrite the code with the following goals:

 1) The plotting routine would be isolated from all other activities
such as reading data from disk.  A separate routine was provided
to read ASCII (QDP) files.

 2) All of the author's scientific graphics would be done with PLT.
Thus when a new function was needed it would be added to PLT.  This
would be done in such a way that existing software would not need
to be modified to use the new function.

 3) The interface to the low level graphics routines would be minimized.
Thus all high level functions would be written in Fortran and hence
be portable to new systems.  This goal was met by using the PGPLOT
graphics package.

Over the years, the goal of always using PLT to produce line graphics
has resulted in the slow accretion of functionality, so that now the
QDP name has been changed to stand for the Quick and Dandy Plotter.
PGPLOT has now been ported to several systems and, in addition, there
is a version of PGPLOT that works with GKS.

The appearance of MONGO on Starlink in 1984 influenced the evolution
of PLT.  Up to that time, the only way to change the defaults was
for the user to type in a command.  When MONGO appeared, it was realized
that the calling program could also issue some commands to PLT.
At this time, the calling sequence to PLT was updated to allow a command
list to passed to it.  PLT can now be completely controlled through
this command list: It will never again be necessary to change the
calling sequence.

The development of PLT at Cambridge was influenced by the interaction
with Rick Shafer and his XSPEC program.  Rick and I would often
compete to design the `most user friendly interface'.  This resulted
in the free exchange of ideas between XSPEC and PLT; as a result,
these programs now have similar (but not identical) user interfaces.

One of the strengths of QDP has always been its ability to FIT the
data.  With the original Goddard version, it was possible to fit either
a constant or a line through the data.  At Cambridge, PLT was enhanced
to allow fitting of any linear combination of `components'.  The list
of components slowly grew to include many functions such as sine,
exponential, log, and two types of spline.  In order to keep the
specialized components from becoming part of the standard PLT/FIT
program, a user model was created.  This allows users to link a
program using PLT/FIT that contains a single specialized component.
This component could then be added to components from the existing
list of built-in functions to construct an advanced model.  While
workable, this method entailed making people link `private' versions
of standard programs.

In late 1987, development started on a new way to define a model
component, that would entail reading a `program' stored in an ASCII
disk file.  Clearly the program would be an interpreted language and,
for maximum speed and efficiency, this language would need to be
stack oriented.  Hence, COD (COmponent Definition) files were created.
Although COD is now an integral part of QDP/PLT/FIT, the programming
language itself is still evolving.

In 1988, Allyn Tennant moved from Cambridge to the Marshall Space
Flight Center in Huntsville.  All questions, complaints, requests,
etc., should now be directed to Huntsville.

In early 1989 the first edition of the User's Guide was produced for
distribution by the EXOSAT group at ESTEC.  I'm grateful to Nick White
for his encouragement of this effort and to Steve O'Dell who greatly
assisted in producing the original LaTeX version of the manual.

Finally, many people have contributed ideas for additional features
and many of these have been included.  You are still encouraged
to suggest enhancements (yes, you are even encouraged to point out
minor bugs).
2 QDP_commands
   QDP commands must be inserted at the beginning of a QDP file, as
these commands tell QDP how to read in the data.  Any command not
recognized by QDP is passed to PLT.  QDP separates command lines from
data lines based on the first non-blank character in the line.  If
this character is + - . or a digit then the entire line will be read
as data.
3 READ
4 Serr
READ Serr [vlist]
  Tell QDP/PLT which vectors have symmetric errors.  The command
"READ Serr 1 3 5"  will cause vectors 1, 3, and 5 to be read with
symmetric errors and vectors 2 and 4 to be read without.  Only one
"READ Serr" command should appear in a QDP file

Example:
<PRE>
READ Serr 1 3 5
 1. .1     2.    3. .3    4.   5. .5
</PRE>

would be read as 5 vectors; 1. +/- .1; 2. (no error); 3. +/- .3;
 4.(no error); 5. +/- .5.  Without the "READ Serr" command, the above
would be read as 8 vectors.

4 Terr
READ Terr [vlist]
  Tell QDP/PLT which vectors have two-sided errors.  It takes three
columns to specify a vector with two-sided errors.  The first column
is the central value, the second column, which must be positive,
specifies the upper bound, and the third column, which must be negative
or zero, specifies the lower bound.

Example:
<PRE>
READ Serr 1
READ Terr 2
 1. .1    2. +.1 -2.
</PRE>
would be read as 1. +/-.1; 2 +.1,-2.  Note:  In fitting, non-positive
errors are ignored and so, the first error, of two-sided errors,
should be positive.
