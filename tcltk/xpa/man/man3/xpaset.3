.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "xpaset 3"
.TH xpaset 3 "July 23, 2013" "version 2.1.15" "SAORD Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
\&\fBXPASet: send data to one or more \s-1XPA\s0 servers\fR
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <xpa.h>
\&
\&  int XPASet(XPA xpa,
\&             char *template, char *paramlist, char *mode,
\&             char *buf, size_t len, char **names, char **messages,
\&             int n);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Send data to one or more \s-1XPA\s0 servers whose class:name identifier
matches the specified template.
.PP
A 
template
of the form \*(L"class1:name1\*(R" is sent to the
\&\s-1XPA\s0 name server, which returns a list of at most n matching \s-1XPA\s0
servers.  A connection is established with each of these servers and
the paramlist string is passed to the server as the data transfer
request is initiated. If an \s-1XPA\s0 struct is passed to the call, the
persistent connections are updated as described above. Otherwise,
temporary connections are made to the servers (which will be closed
when the call completes).
.PP
The \fIXPASet()\fR routine transfers data from buf to the \s-1XPA\s0 servers.
The length of buf (in bytes) should be placed in the len variable.
.PP
A string containing the class:name and ip:port of each of these server
is returned in the name array.  If a given server returned an error or
the server callback sends a message back to the client, then the
message will be stored in the associated element of the messages
array. \s-1NB:\s0 if specified, the name and messages arrays must be of size
n or greater.
.PP
The returned message string will be of the form:
.PP
.Vb 1
\&  XPA$ERROR   [error] (class:name ip:port)
.Ve
.PP
or
.PP
.Vb 1
\&  XPA$MESSAGE [message] (class:name ip:port)
.Ve
.PP
The return value will contain the actual number of servers that were
processed.  This value thus will hold the number of valid entries in
the names and messages arrays, and can be used to loop through these
arrays.  In names and/or messages is \s-1NULL\s0, no information is passed back
in that particular array.
.PP
The mode string is of the form: \*(L"key1=value1,key2=value2,...\*(R"
The following keywords are recognized:
.PP
.Vb 5
\&  key           value           default         explanation
\&  \-\-\-\-\-\-        \-\-\-\-\-\-\-\-        \-\-\-\-\-\-\-\-        \-\-\-\-\-\-\-\-\-\-\-
\&  ack           true/false      true            if false, don\*(Aqt wait for ack from server (after callback completes)
\&  verify        true/false      false           send buf from XPASet[Fd] to stdout
\&  doxpa         true/false      true            client processes xpa requests
.Ve
.PP
The ack keyword is useful in cases where one does not want to wait for
the server to complete, e.g. if a lot of processing needs to be done
by the server on the passed data or when the success of the server
operation is not relevant to the client.
.PP
Normally, an \s-1XPA\s0 client will process incoming \s-1XPA\s0 server requests
while awaiting the completion of the client request.  Setting this
variable to \*(L"false\*(R" will prevent \s-1XPA\s0 server requests from being
processed by the client.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  #include <xpa.h>
\&
\&  #define NXPA 10
\&  int  i, got;
\&  size_t  len;
\&  char *buf;
\&  char *names[NXPA];
\&  char *messages[NXPA];
\&  ...
\&  [fill buf with data and set len to the length, in bytes, of the data]
\&  ...
\&  /* send data to all access points */
\&  got = XPASet(NULL, "ds9", "fits", NULL, buf, len, names, messages, NXPA);
\&  /* error processing */
\&  for(i=0; i<got; i++){
\&    if( messages[i] ){
\&      fprintf(stderr, "ERROR: %s (%s)\en", messages[i], names[i]);
\&    }
\&    if( names[i] )    free(names[i]);
\&    if( messages[i] ) free(messages[i]);
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See xpa(n) for a list of \s-1XPA\s0 help pages
