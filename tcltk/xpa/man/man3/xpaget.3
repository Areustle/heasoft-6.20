.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "xpaget 3"
.TH xpaget 3 "July 23, 2013" "version 2.1.15" "SAORD Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
\&\fBXPAGet: retrieve data from one or more \s-1XPA\s0 servers\fR
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <xpa.h>
\&
\&  int XPAGet(XPA xpa,
\&             char *template, char *paramlist, char *mode,
\&             char **bufs, size_t *lens, char **names, char **messages,
\&             int n);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Retrieve data from one or more \s-1XPA\s0 servers whose class:name identifier
matches the specified template.
.PP
A 
template
of the form \*(L"class1:name1\*(R" is sent to the
\&\s-1XPA\s0 name server, which returns a list of at most n matching \s-1XPA\s0
servers.  A connection is established with each of these servers and
the paramlist string is passed to the server as the data transfer
request is initiated. If an \s-1XPA\s0 struct is passed to the call, then the
persistent connections are updated as described above. Otherwise,
temporary connections are made to the servers (which will be closed
when the call completes).
.PP
The \fIXPAGet()\fR routine then retrieves data from at most n \s-1XPA\s0 servers,
places these data into n allocated buffers and places the buffer
pointers in the bufs array. The length of each buffer is stored in the
lens array. A string containing the class:name and ip:port is stored
in the name array.  If a given server returned an error or the server
callback sends a message back to the client, then the message will be
stored in the associated element of the messages array.  \s-1NB:\s0 if
specified, the name and messages arrays must be of size n or greater.
.PP
The returned message string will be of the form:
.PP
.Vb 1
\&  XPA$ERROR error\-message (class:name ip:port)
.Ve
.PP
or
.PP
.Vb 1
\&  XPA$MESSAGE message (class:name ip:port)
.Ve
.PP
Note that when there is an error stored in an messages entry, the
corresponding bufs and lens entry may or may not be \s-1NULL\s0 and 0
(respectively), depending on the particularities of the server.
.PP
The return value will contain the actual number of servers that were
processed.  This value thus will hold the number of valid entries in
the bufs, lens, names, and messages arrays, and can be used to loop
through these arrays.  In names and/or messages is \s-1NULL\s0, no information is
passed back in that array.
.PP
The bufs, names, and messages arrays should be freed upon completion (if
they are not \s-1NULL\s0);
.PP
The mode string is of the form: \*(L"key1=value1,key2=value2,...\*(R"
The following keywords are recognized:
.PP
.Vb 4
\&  key           value           default         explanation
\&  \-\-\-\-\-\-        \-\-\-\-\-\-\-\-        \-\-\-\-\-\-\-\-        \-\-\-\-\-\-\-\-\-\-\-
\&  ack           true/false      true            if false, don\*(Aqt wait for ack from server (after callback completes)
\&  doxpa         true/false      true            client processes xpa requests
.Ve
.PP
The ack keyword is not very useful, since the server completes the callback
in order to return the data anyway.  It is here for completion (and perhaps
for future usefulness).
.PP
Normally, an \s-1XPA\s0 client will process incoming \s-1XPA\s0 server requests
while awaiting the completion of the client request.  Setting this
variable to \*(L"false\*(R" will prevent \s-1XPA\s0 server requests from being
processed by the client.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  #include <xpa.h>
\&
\&  #define NXPA 10
\&  int  i, got;
\&  size_t  lens[NXPA];
\&  char *bufs[NXPA];
\&  char *names[NXPA];
\&  char *messages[NXPA];
\&  got = XPAGet(NULL, "ds9", "file", NULL, bufs, lens, names, messages,
\&  NXPA);
\&  for(i=0; i<got; i++){
\&    if( messages[i] == NULL ){
\&      /* process buf contents */
\&      ProcessImage(bufs[i], ...);
\&      free(bufs[i]);
\&    }
\&    else{
\&      /* error processing */
\&      fprintf(stderr, "ERROR: %s (%s)\en", messages[i], names[i]);
\&    }
\&    if( names[i] )
\&      free(names[i]);
\&    if( messages[i] )
\&      free(messages[i]);
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See xpa(n) for a list of \s-1XPA\s0 help pages
