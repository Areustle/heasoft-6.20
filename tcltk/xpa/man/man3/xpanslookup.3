.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "xpanslookup 3"
.TH xpanslookup 3 "July 23, 2013" "version 2.1.15" "SAORD Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
\&\fBXPANSLookup: lookup registered \s-1XPA\s0 access points\fR
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <xpa.h>
\&
\&  int XPANSLookup(XPA xpa,
\&                  char *template, char type,
\&                  char ***classes, char ***names,
\&                  char ***methods, char ***infos)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1XPA\s0 routines act on a class:name identifier in such a way
that all access points that match the identifier are processed.  It is
sometimes desirable to choose specific access points from the
candidates that match the
template.  In order to do this, the
XPANSLookup routine can be called to return a list of matches, so that
specific class:name instances can then be fed to \fIXPAGet()\fR, \fIXPASet()\fR, etc.
.PP
.Vb 4
\& The first argument is an optional XPA struct. If non\-NULL, the
\&existing name server connection associated with the specified xpa is
\&used to query the xpans name server for matching templates. Otherwise,
\&a new (temporary) connection is established with the name server.
.Ve
.PP
The second argument to XPANSLookup is the class:name 
template
to match.
.PP
The third argument for \fIXPANSLookup()\fR is the type of access and can be
any combination of:
.PP
.Vb 5
\&  type          explanation
\&  \-\-\-\-\-\-        \-\-\-\-\-\-\-\-\-\-\-
\&  g             xpaget calls can be made on this access point
\&  s             xpaset calls can be made on this access point
\&  i             xpainfo calls can be made on this access point
.Ve
.PP
The call typically specifies only one of these at a time.
.PP
The final arguments are pointers to arrays that will be filled
in and returned by the name server. The name server will allocate and
return arrays filled with the classes, names, and methods of all \s-1XPA\s0
access points that match the template
and have the specified type. Also returned are info strings, which
generally are used internally by the client routines. These can be
ignored (but the strings must be freed).  The function returns the
number of matches. The returned value can be used to loop through the
matches:
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  #include <xpa.h>
\&
\&  char **classes;
\&  char **names;
\&  char **methods;
\&  char **infos;
\&  int i, n;
\&  n = XPANSLookup(NULL, "foo*", "g", &classes, &names, &methods, &infos);
\&  for(i=0; i<n; i++){
\&    [more specific checks on possibilities ...]
\&    [perhaps a call to XPAGet for those that pass, etc. ...]
\&    /* don\*(Aqt forget to free alloc\*(Aqed strings when done */
\&    free(classes[i]);
\&    free(names[i]);
\&    free(methods[i]);
\&    free(infos[i]);
\&  }
\&  /* free up arrays alloc\*(Aqed by names server */
\&  if( n > 0 ){
\&    free(classes);
\&    free(names);
\&    free(methods);
\&    free(infos);
\&  }
.Ve
.PP
The specified 
template
also can be a host:port specification, for example:
.PP
.Vb 1
\&  myhost:12345
.Ve
.PP
In this case, no connection is made to the name server. Instead, the
call will return one entry such that the ip array contains the ip for
the specified host and the port array contains the port.  The class
and name entries are set to the character \*(L"?\*(R", since the class and
name of the access point are not known.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See xpa(n) for a list of \s-1XPA\s0 help pages
