//   Read the documentation to learn more about C++ code generator
//   versioning.
//	  %X% %Q% %Z% %W%

#ifndef MODEL_H
#define MODEL_H 1
#include <XSModel/Data/SpectralData.h>

// xsTypes
#include <xsTypes.h>
// Error
#include <XSUtil/Error/Error.h>
// iosfwd
#include <iosfwd>
// list
#include <list>
#include <set>

class Response;
class ModelBase;
class SumComponent;
class ComponentGroup;
class Component;
class ModParam;
template <typename T>
class XSCall;

class MathExpression;
class Parameter;
class CombineIterator;

#include <XSModel/GlobalContainer/ModelTypes.h>
#include <deque>

#include <XSUtil/Parse/ModelExpression.h>
#include <XSUtil/Parse/ModelExprContexts.h>

//	This is the model class. It  contains component group
//	members, and the output calculated model. Currently,
//	only one model is allowed, but the design here is for
//	multiple models.



class Model 
{

  public:



    class ContextError : public YellowAlert  //## Inherits: <unnamed>%376A585BA1B8
    {
      public:
          ContextError (const string& name, const string& yesno, const string& context);
          ContextError (const string& errMessage);

      protected:
      private:
      private: //## implementation
    };



    class NotEnoughParameterStrings : public YellowAlert  //## Inherits: <unnamed>%39119D8E2848
    {
      public:
          NotEnoughParameterStrings (const string& component);

      protected:
      private:
      private: //## implementation
    };



    class NoSourceForModel : public YellowAlert  //## Inherits: <unnamed>%3E24673F0108
    {
      public:
          NoSourceForModel();

      protected:
      private:
      private: //## implementation
    };



    class ComponentNotPresent : public YellowAlert  //## Inherits: <unnamed>%3F0C89C900DA
    {
      public:
          ComponentNotPresent (const string& message);

      protected:
      private:
      private: //## implementation
    };



    class InvalidModelEdit : public YellowAlert  //## Inherits: <unnamed>%3F0C89D10366
    {
      public:
          InvalidModelEdit (const string& message);

      protected:
      private:
      private: //## implementation
    };



    class EmptyModelResults : public YellowAlert  //## Inherits: <unnamed>%3F0EDAAF03AC
    {
      public:
          EmptyModelResults();

      protected:
      private:
      private: //## implementation
    };



    class WrongDataForMixing : public YellowAlert  //## Inherits: <unnamed>%3F671AAE0176
    {
      public:
          WrongDataForMixing (const string& diag);

      protected:
      private:
      private: //## implementation
    };
      Model(const Model &right);
      Model (const string& name, size_t source, const string& modelArgs);
      ~Model();

      //	Called by command line implementation of xsModel.
      //
      //	Constructs and prints  the user prompt, grabs a
      //	string from the prompt and saves it in the array of
      //	returned strings.
      std::deque<string> getParamValuesFromUser ();
      //	setParamValues is a driver routine for setting
      //	parameter values as supplied by input from the
      //	user. With no arguments it is the analogue of
      //	setpar from earlier versions of XSPEC.
      //
      //	It takes an optional IntegerArray as a parameter, which
      //	consists of a list of parameter numbers to set.
      //	This array will be generated by XSutility::getRanges
      //	from a string.
      //
      //	In newpar modes where parameter name is
      //	supplied (according to 4/2000 specification and
      //	not yet implementation) another utility function will
      //	be called to turn the input string into the required
      //	array.
      //	This will be supplied by the lookup member of
      //	parameterList.
      void setParamValues (std::deque<string>& paramStrings, bool& skipEntered);
      bool operator < (const Model& right) const;
      //	apply mixing model to product, if present. Invoke mixing
      //	model's perform() function and operate on the result of
      //	combining the rest of the components.
      //
      //	GroupFluxContainer == map<size_t,ArrayContainer>
      //	contains the calculated model fluxes fit to each data
      //	group in turn.
      bool operator > (const Model& right) const;
      
      void destroy () throw ();
      void initializeMixingTransformation (bool isLowest, IntegerArray allMixSpectra = IntegerArray()) const;
      void initializeAMXingTransformation (bool isLowest) const;
      Model* clone () const;
      const string& name () const;
      size_t sourceNumber () const;
      size_t dataGroupNumber () const;
      void dataGroupNumber (size_t group);
      void sourceNumber (size_t source);
      bool isActive () const;
      void registerParameters () const;
      size_t parameterIndexBase () const;
      void setIndex (size_t i);
      void setDataGroupIndexing (size_t group);
      void attachResponse (Response* response);
      void linkDataGroupParams ();
      void makeActive ();
      // If attachDummy is not set to true, this will leave
      // the Model in a state where it has no associated energy
      // ararys.  This is a dangerous state, and is originally intended
      // only for short-term use in ModelContainer's Update function, 
      // where the Model will quickly be reassigned another response.
      void makeInactive (const bool attachDummy = true);
      void calcComponents(bool saveComponentFlux = false, bool frozen = false);
      const RealArray& modelFlux (size_t responseNumber) const;
      const RealArray& foldedModel (size_t responseNumber) const;
      const RealArray& modelFluxError (size_t responseNumber) const;
      const RealArray& foldedModelError (size_t responseNumber) const;
      void foldedModel (size_t responseNumber, const RealArray& value);
      void foldedModelError (size_t responseNumber, const RealArray& value);
      size_t numberOfParameters () const;
      size_t numberOfComponents () const;
      const string& fullExpression () const;
      void setComputeFlag (bool value);
      bool isFolded () const;
      void isFolded (bool value);
      Model& fold ();
      void debugPrint (std::ostream& s) const;
      bool removeResponse (size_t spectrumNumber = 0);
      SpectralData* spectrum (size_t index) const;
      //	compute difference arrays between model and its
      //	associated spectra.
      void difference (ArrayContainer& df) const;
      const std::map<size_t,Response*>& detector () const;
      const ArrayContainer& foldedModel () const;
      const ArrayContainer& foldedModelError () const;
      const ArrayContainer& modelFlux () const;
      std::list<ModParam*> normParams () const;
      //	Integrate the model flux from eMin to eMax and
      //	return the results in keV (flux) and ergs (eFlux).
      //
      //	Equivalent of XSPEC11's intmod.f
      void integrateFlux (size_t index, Real eMin, Real eMax, Real& flux, Real& eFlux) const;
      void prepareForFit ();
      void allButNorms (IntegerArray& paramsToFreeze) const;
      void resetModelFlux (const ArrayContainer& saved);
      void resetComponentFlux () const;
      void saveComponentFlux () const;
      //	return net countrate prediction for Model fit to spectrum
      //	n.
      //
      //	Supports a tclout option but may be useful elsewhere.
      //	If the argument is zero, produce the total for all
      //	spectra fit bythe model.
      //
      //	countRate is not const just in case it needs to
      //	fold the model
      Real countRate (size_t spectrumNumber = 0);
      void storeDerivative (ArrayContainer& diff);
      Real ergFlux (size_t index) const;
      Real keVFlux (size_t index) const;
      void ergFlux (size_t index, Real value) const;
      void keVFlux (size_t index, Real value) const;
      const ArrayContainer& energy () const;
      std::pair<Real,Real> keVFluxRange (size_t index) const;
      std::pair<Real,Real> ergFluxRange (size_t index) const;
      void keVFluxRange (size_t index, std::pair<Real,Real>& value);
      void ergFluxRange (size_t index, std::pair<Real,Real>& value);
      //	outputs flux information as computed by the flux command.
      void reportFluxes (size_t spectrumNumber, Real redshiftFactor, bool lumin, Real eMin, Real eMax, Real confLevel = .0) const;
      //	Function to generate the list of individual theoretical
      //	X-Ray sources (represented by transformed additive
      //	components) for use in plotting.
      const std::list<SumComponent*>& sources () const;
      void clearSources () throw ();
      void foldSources ();
      //	Integrate the individual source fluxes from eMin to eMax
      //	for  arrays corresponding to spectrum Index
      std::list<std::pair<Real, Real> > integrateSourceFlux (size_t index, Real eMin, Real eMax) const;
      const Response* detector (size_t spectrumNumber) const;
      size_t index ();
      void deleteComponent (int componentIndex);
      void insertComponent (int componentIndex, const string& componentName);
      Component* componentByNumber (int seekIndex, int& groupNumber, int& componentOffset) const;
      void decrementParameterCount (int by = 1);
      void reindexComponents (int start, int by = -1	// reduce component index numbers starting at 'start' by
      	// 'by'
      	// 'by' defaults to -1 (can't see a need for any other
      	// value right now,
      	// but)...
      );
      //	go through all components starting with index 1 and
      //	reindex their
      //	parameters.
      void reindexParameters ();
      std::pair<size_t,size_t> getComponentPeak (size_t compNumber, Real& compTotal);
      Real calcContinuumFlux (size_t compNumber, size_t iMax, size_t specNum, Real fraction);
      void deregisterParameters ();
      //	setParamValues is a driver routine for setting
      //	parameter values as supplied by input from the
      //	user. With no arguments it is the analogue of
      //	setpar from earlier versions of XSPEC.
      //
      //	It takes an optional IntegerArray as a parameter, which
      //	consists of a list of parameter numbers to set.
      //	This array will be generated by XSutility::getRanges
      //	from a string.
      //
      //	In newpar modes where parameter name is
      //	supplied (according to 4/2000 specification and
      //	not yet implementation) another utility function will
      //	be called to turn the input string into the required
      //	array.
      //	This will be supplied by the lookup member of
      //	parameterList.
      void setParamValues (int componentIndex, std::deque<string>& paramStrings, bool& skipEntered);
      void linkDataGroupParams (int componentIndex);
      //	Called by command line implementation of xsModel.
      //
      //	Constructs and prints  the user prompt, grabs a
      //	string from the prompt and saves it in the array of
      //	returned strings.
      std::deque<string> getParamValuesFromUser (int componentIndex);
      //	front end for editmod implementation
      void edit (const string& modelDefinition, int& componentToSet);
      const XSContainer::MixLocations& mixingLocations () const;
      void checkForMixing ();
      const ArrayContainer& modelFluxError () const;
      void resetModelFluxError (const ArrayContainer& saved);
      void initializeFromData ();
      void mixingLocations (const XSContainer::MixLocations& mixLocs);
      static ModelExpression<ModExprStandAlone> getExpressionFromString (const string& modelDef);
      const SpectralData::FluxCalc& lastModelFluxCalc () const;
      void lastModelFluxCalc (const SpectralData::FluxCalc& modelFluxCalc);
      const SpectralData::FluxCalc& lastModelLuminCalc () const;
      void lastModelLuminCalc (const SpectralData::FluxCalc& value);
      void setAutonomousEnergy (const RealArray& energy);
      void setAutonomousEnergy (const XSContainer::ExtendRange& extended);
      void fillEnergyContainer ();
      void setSpectraForAutonomousEngs ();
      void updateNewGainFromFit (const Response* response);
      void bundleParameters (std::vector<Parameter*>& parameters) const;
      void bundleComponents (std::vector<Component*>& components) const;
      std::vector<Model*> makeDataGroupCopies (const std::vector<size_t>& groups);
      static void makeExtendArray (const XSContainer::ExtendRange& extRange, RealArray& extArray);
      bool usingMdef (const XSCall<MathExpression>* mdef) const;
      //	Print the model heading information in the "show
      //	model/par" display.  The output should be the same for
      //	all data group copies of the model.
      void printHeading () const;
      //	Print the mix component (if any) if this is the lowest
      //	numbered of the data group copies.  Otherwise do nothing.
      void printMixComp () const;
      bool areCompsSpecDependent () const;
      void alignFluxForFold (ArrayContainer& saveFlux, ArrayContainer& saveFluxError, SumComponent* sourceComp = 0);
      void checkZeroNorms (std::set<int>& parsWithZeroNorms);
      // Return 'true' if magnitudes of parameter values differ by an amount
      //   exceeding threshold. This only checks non-zero ModParams.
      bool checkParameterMagnitudes(Real threshold) const;
      
      static const string& DEFAULT ();

      friend std::ostream& operator << (std::ostream& s, const Model& right);
      friend class CombineIterator;


  public:
    // Additional Public Declarations
      size_t getComponentPeak (size_t compNumber, Real& compTotal) const;
      Real calcContinuumFlux (size_t compNumber, size_t iMax, Real fraction) const;
  protected:
    // Additional Protected Declarations

  private:
      Model & operator=(const Model &right);
      static void checkContext (const ModelExprTree& expressionTree);
      void createParts ();
      //	Parse for model simply splits the input string into
      //	component groups for processing by component
      //	group parsing function.
      void parse (const string& modelString);
      void define (const string& modelArgs);
      static void resolveComponentNames (ModelExprTree& expressionTree);
      void checkNewModelString (ModelExpression<ModExprStandAlone> fullDef, int& componentIndex, string& componentName);
      void deleteComponentParamInfo (Component* toDelete);

    // Additional Private Declarations

  private: //## implementation
    // Data Members for Class Attributes
      static const string s_DEFAULT;

    // Data Members for Associations
      ModelBase* m_modelBase;

    // Additional Implementation Declarations

};

// Class Model::ContextError 

// Class Model::NotEnoughParameterStrings 

// Class Model::NoSourceForModel 

// Class Model::ComponentNotPresent 

// Class Model::InvalidModelEdit 

// Class Model::EmptyModelResults 

// Class Model::WrongDataForMixing 

// Class Model 

inline const string& Model::DEFAULT ()
{
  return s_DEFAULT;
}


#endif
