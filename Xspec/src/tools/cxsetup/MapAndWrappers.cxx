#include "MapAndWrappers.h"
#include <cstdlib>
#include <iostream>
#include <cctype>


WrappersError::WrappersError(const string& msg)
{
   std::cerr << msg << std::endl;
}

std::map<string,string> MapAndWrappers::s_specialNames;

MapAndWrappers::MapAndWrappers(const string& modInitFile, const string& directory, const string& packageName)
 :ModelMap(modInitFile, directory, packageName),
  m_wrapHeaderFile(),
  m_wrapCodeFile()
{
   if (s_specialNames.empty())
   {
      s_specialNames["powerLaw"] = string("xspwlw");
      s_specialNames["zpowerLaw"] = string("xszplw");
      s_specialNames["cutoffPowerLaw"] = string("xsplco");
      s_specialNames["cemVMekal"] = string("cevmkl");
      s_specialNames["PartialCovering"] = string("prtcov");
      s_specialNames["superExpCutoff"] = string("spexpcut");
      s_specialNames["brokenPowerLaw"] = string("xsbplw");
      s_specialNames["broken2PowerLaw"] = string("xsb2pl");
   }
}

MapAndWrappers::~MapAndWrappers()
{
}

void MapAndWrappers::createWrapperFiles()
{
   const string wrapName("funcWrappers");
   const string wrapHeaderName(wrapName + ".h");
   const string wrapFileName(wrapName + ".cxx");

   const string headerLoc(directory() + '/' + wrapHeaderName);
   const string fileLoc(directory() + '/' + wrapFileName);
   m_wrapHeaderFile.open(headerLoc.c_str());
   if (!m_wrapHeaderFile)
   {
      string msg("Unable to open wrapper header file for writing at:\n");
      msg += headerLoc;
      throw WrappersError(msg);
   }
   m_wrapCodeFile.open(fileLoc.c_str());
   if (!m_wrapCodeFile)
   {
      string msg("Unable to open wrapper code file for writing at:\n");
      msg += fileLoc;
      throw WrappersError(msg);
   }

   m_wrapHeaderFile << "//C++\n#ifndef FUNCWRAPPERS_H\n#define FUNCWRAPPERS_H\n\n"
       <<"// Generated by cxsetup.  Do not edit manually.\n"
       <<"\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n" << std::endl; 

   m_wrapHeaderFile << "   // Wrappers for C++ models w/ C interface.\n"
      << "   // Assumes energy points to arrays of size nFlux+1, flux and fluxError\n"
      << "   // point to arrays of size nFlux (though they need not be initialized),\n"
      << "   // and params points to an array of size nPar for the particular model.\n"
      << "   // initStr may point to a valid character string or it may be NULL if unused.\n"
      << std::endl;

   // This fills in the start of the code file
   copyCodeTemplate();

}

void MapAndWrappers::copyCodeTemplate()
{
   string dir(getenv("HEADAS"));
   dir += "/../Xspec/src/tools/cxsetup/";
   const string templLoc(dir + "funcWrapper.tmpl");

   std::ifstream templFile(templLoc.c_str());
   if (!templFile)
   {
      string msg("Unable to read wrapper template file at:\n");
      msg += templLoc;
      throw WrappersError(msg);
   }

   char ch;
   while (templFile.get(ch))
      m_wrapCodeFile.put(ch);
}

void MapAndWrappers::addWrappers(const string& funcName, const string& funcType, int nPar)
{
   if (funcType == CXXfuncType())
   {
      string fCallsCName(funcName);
      std::map<string,string>::const_iterator itSpecial = s_specialNames.find(funcName);
      if (itSpecial != s_specialNames.end())
         fCallsCName = itSpecial->second;

      string upperName;
      string lowerName;
      for (size_t i=0; i<fCallsCName.length(); ++i)
      {
         upperName += toupper(fCallsCName[i]);
         lowerName += tolower(fCallsCName[i]);
      }


      // declaration for double precision wrapper called by C or Fortran.
      m_wrapHeaderFile << "      void C_" << funcName
         << "(const double* energy, int nFlux, const double* params,\n"
         << "                int spectrumNumber, double* flux, double* fluxError,\n"
         << "                const char* initStr);" << std::endl;

      // declaration for single-precision wrapper, called by Fortran only. 
      m_wrapCodeFile << "void f_" << funcName
         << "(const float* energy, int nFlux, const float* params,\n"
         << "	     int spectrumNumber, float* flux, float* fluxError);\n"
         << std::endl;

      // cfortran.h declaration for calling single-precision wrapper
      m_wrapCodeFile << "FCALLSCSUB6(f_" << funcName << ","
         << upperName << "," << lowerName << ",FLOATV,INT,FLOATV,INT,FLOATV,FLOATV)"
         << std::endl;

      // cfortran.h declaration for calling double-precision wrapper
      m_wrapCodeFile << "FCALLSCSUB7(C_" << funcName << ",D"
         << upperName << ",d" << lowerName << ",DOUBLEV,INT,DOUBLEV,INT,DOUBLEV,DOUBLEV,STRING)\n"
         << std::endl;

      // single-precision wrapper function
      m_wrapCodeFile << "void f_" << funcName << "(const float* energy, int nFlux, const float* params,\n"
         << "        int spectrumNumber, float* flux, float* fluxError)\n"
         << "{\n   const size_t nPar = " << nPar << ";\n"
         << "   fcppModelWrapper(energy, nFlux, params, spectrumNumber, flux, fluxError,\n"
         << "        nPar, " << funcName << ");\n}\n" << std::endl;

      // double-precision wrapper function with initStr 
      m_wrapCodeFile << "void C_" << funcName << "(const double* energy, int nFlux, const double* params,\n"
         << "        int spectrumNumber, double* flux, double* fluxError, const char* initStr)\n"
         << "{\n   const size_t nPar = " << nPar << ";\n"
         << "   cppModelWrapper(energy, nFlux, params, spectrumNumber, flux, fluxError,\n"
         << "        initStr, nPar, " << funcName << ");\n}\n" << std::endl;

   }
}

void MapAndWrappers::completeWrapperFiles()
{
   m_wrapHeaderFile << "\n#ifdef __cplusplus\n}\n#endif\n\n#endif" <<std::endl;
   m_wrapHeaderFile.close();
   m_wrapCodeFile.close();
}
