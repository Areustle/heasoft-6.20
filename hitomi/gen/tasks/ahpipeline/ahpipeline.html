<!--=======================================-->
<!--  HEADAS HTML HELP FILE TEMPLATE, v1.1 -->
<!--=======================================-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<style type="text/css">
    body { margin-left: 5%; margin-right: 5%; }
    h1,h2,h3,h4 { margin-left: -5%;}
</style>
<title>HEADAS help file</title>
</head>

<body>

<h2>NAME</h2>

ahpipeline - HXI/SGD/SXS/SXI reprocessing tool

<h2>USAGE</h2>

<code>
ahpipeline indir outdir steminputs stemoutputs entry_stage instrument
</code>

<h2>DESCRIPTION</h2>

<p>ahpipeline duplicates most of the pipeline (not trend data). It allows the user to run all or part of the pipeline processing and to vary the calibration files and filtering (screening) criteria used. A number of other pipeline processing parameters can also be changed.

<h3>Pipeline Stages</h3>

<p>The pipeline is divided into 3 stages:

<ol>
<li>Calibration</li>
<li>Data screening </li>
<li>Product creation</li>
</ol>

Each stage may be run singly or in combination with the preceding stages.  This is controlled by the <code>entry_stage</code> and <code>exit_stage</code> parameters.

<p>HXI Stage 1 consists of the following ordered steps:
<ol>
 <li>Run cams2att*</li>
 <li>Run hxisgdsff</li>
 <li>Run hxisgdpha</li>
 <li>Run hxisgdexpand</li>
 <li>Run hxievtid</li>
 <li>Run coordevt</li>
</ol>
<p>*Note: cams2att is automatically run twice. Once with parameters set for HXI1, the other with parameters set for HXI2.

<p>SGD Stage 1 consists of the following steps:
<ol>
 <li>Run hxisgdsff</li>
 <li>Run hxisgdpha</li>
 <li>Run hxisgdexpand</li>
 <li>Run sgdevtid</li>
</ol>

<p>SXI Stage 1 consists of the following steps:
 <ol>For each event file:
 <li>(optional) Run coordevt on hot pixel file</li>
 <li>Run coordevt</li>
 <li>Run sxiphas</li>
 <li>Run sxiflagpix</li>
 <li>Run sxipi</li>
 <li>Run sxipi
 <ol type=A>
 <li>Create flickering pixel file
 <ol type=a>
 <li>Filter SXI events STATUS[1]==b0</li>
 <li>Run searchflickpix</li>
 <li>Run coordevt on flickering pixel events</li>
 </ol></li>
 </ol></li>
 <li>Run sxiflagpix with flickering pixels</li>
</ol>

<p>SXS Stage 1 consists of the following steps:
 <ol>
 <li>(optional) Calculate GTIFOUNDALL (gtiinvert on GTILOST)</li>
 <li>Run mxsgti</li>
 <li>Calculate &lt;gaingti&gt; GTI file:
 <ul type=none>
   <li>if <code>linetocorrect</code> eq 'MnKa':<br>Merge GTIOBS GTITEL </li>
   <li>else:                           <br>Merge GTIOBS GTITEL GTIMXSFNON##</li>
 </ul></li>
 <li>Run sxsanticopi
 <li>For each event file:
 <ol type=A>
 <li>Run coordevt</li>
 <li>Run sxsflagpix</li>
 <li>Run sxssecid</li>
 </ol></li>
 <li>Calculate GHF
 <ol type=A>
   <li>Merge pointing and slew event files</li>
   <li>Select merged file</li>
   <ul type=none>
     <li>if <code>linetocorrect</code> eq 'MnKa':<br> <code>PIXEL==12&amp;&amp;ITYPE&lt;5&amp;&amp;gtifilter("&lt;gaingti&gt;")</code></li>
     <li>else:                   <br> <code>PIXEL!=12&amp;&amp;ITYPE&lt;5&amp;&amp;gtifilter("&lt;gaingti&gt;")</code></li>
   </ul></li>
 <li>Run ftsort on filtered merged file</li>
 <li>Run sxsgain on filtered, sorted merged file</li>
 </ul> </ol> </li>
 <li> For each event file:
 <ol type=A>
   <li>Run sxspha2pi (GHF input)</li>
   <li>Run sxsflagpix</li>
   <li>Run sxssecid</li>
   <li>Run sxsseccor</li>
   <li>Run sxspha2pi (GHF input)</li>
   <li>Run sxsperseus </li>
 </ol></li>
 </ol>

<p>The data screening (Stage 2) is identical to that in the production pipeline, when default parameters are used. ahpipeline uses the individual instrument pipelines to screen the data: hxipipeline, sgdpipeline, sxipipeline, sxspipeline. For details on the default screening applied to the events (respectively), see:
<ul type=disk>
  <li> ahfilter - Create the EHK from attitude &amp; orbital data and create the MKF from housekeeping data based on the CALDB mkfconf file</li>
  <li> ahgtigen - Create the GTI from the EHK and MKF parameters based on CALDB selection file</li>
  <li> ahscreen - Screen the data based on GTI and CALDB selection file</li>
</ul>

<p>The product creation (Stage 3) is identical to that in the production pipeline, when default parameters are used. For HXI, SXI &amp; SXS events extractor is run on SKY coordinates and a lightcurve, spectra and images are created for each cleaned event file. For SGD, extractor coordinates are set to NONE. No gif images are created.

<h3>Instruments</h3>

<p>ahpipeline allows the processing of data on an instrument-by-instrument basis.  This is controlled by the <code>instrument</code> parameter. Possible values are:
<ul>
<li>ALL  - Process all data for all modules of all instruments</li>
<li>HXI  - Process HXI data (both HXI1 and HXI2) only</li>
<li>HXI1 - Process HXI data HXI1 only</li>
<li>HXI2 - Process HXI data HXI2 only</li>
<li>SGD  - Process SGD data (both SGD1 and SGD2) only</li>
<li>SGD1 - Process SGD data SGD1 only</li>
<li>SGD2 - Process SGD data SGD2 only</li>
<li>SXS  - Process SXS data only</li>
<li>SXI  - Process SXI data only</li>
</ul>

More than one value may be specified at one time.<br>

Combination of HXI1 and HXI2 is allowed, is equivalent to HXI.<br>

Combination of SGD1 and SGD2 is allowed, is equivalent to SGD.<br>

<h2>INPUT</h2>

<p>The input to ahpipeline is specified using (at minimum) the <code>indir</code> parameter. This should be specified as the top-level sequence directory, e.g.:

<p>
<code>ahpipeline indir=/path/to/100039010 ...</code>

<p>Paths to specific housekeeping and satellite data files can be specified using the <code>attitude</code>, <code>housekeeping</code>, <code>extended_housekeeping</code>, <code>makefilter</code>, <code>orbit</code> and <code>timfile</code> parameters. But this should NOT be necessary if indir is specified correctly.

<p><strong>NOTE: Errors can occur if a subdirectory of a sequence directory is used for the <code>indir</code> parameter or if the output is stored within the sequence directory.</strong>

<h2>OUTPUT</h2>

<h3>Report</h3>

<p>An output report is produced with the default name "ahpipeline.log". The name of the log can be changed with the <code>logfile</code> parameter. This lists all processing done in any particular run of ahpipeline. The level of detail of this report is controlled by the <code>chatter</code> parameter.  (Default = "2", range 0 - 3.)

<p>NOTE: Setting chatter to "3" or above can produce very large output reports.

<h3>Filenames, etc.</h3>

<p>The number of output files depends on both pipeline processing stage(s) and the instrument(s) selected.  All output files are written to the directory specified by the <code>outdir</code> parameter. The archive directory structure is NOT reproduced (i.e. all output files are in a single directory).

<p>The names of files produced are the same as those found in the HEASARC archive. However the usual "ahXXXXXXXXX" prefix (where "XXXXXXXXX" is the sequence number) can be replaced by a character string set by the <code>stemoutputs</code> parameter.  This defaults to the value set by the <code>steminputs</code> parameter.

<h2>PARAMETERS</h2>

<dl>
<p>
<dt>indir [string]
<dd>Directory containing the input data. This should be the full, or relative path to the top-level sequence directory, e.g.:
<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>/path/to/805062010/</code>
<p>NOTE: Problems can arise if a sub-directory of the top-level sequence directory is used.

<p>
<dt>outdir [string]
<dd>Output directory used for all output data, as well as the report file.  If clobber is not set, and this directory already exists, the task fails. This should NEVER be a sub-directory of the input directory (the top level sequence directory).
<p><strong>CAUTION: If <code>clobber</code> is set, and this directory already exists, then this task overwrites files as needed in this directory. </strong>

<p>
<dt>steminputs [string]
<dd>Stem for FITS input files, e.g. ah100039010. This string is used as the base filename for finding input files. For example, if steminputs=ah100039010, then to find the attitude file, ahpipeline matches the regular expression <code>/ah100039010\.att(\..+)?$/</code> against all files found in the <code>indir</code> directory.
<p>When doing this matching, ahpipeline prefers files that match the original archive directory structure over files with the same name that do not. For example, if the files:
<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>/path/to/805062010/hxi/event_uf/ah805062010hxi_0_uf.evt</code>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>/path/to/805062010/hxi/event_uf_2/ah805062010hxi_0_uf.evt</code>
<p>both exist, ahpipeline uses the first file, and not the second. If two files of the same name are found and neither one resides in an archive directory structure, ahpipeline exits with an error.
<p>NOTE: The above file finding issues can be avoided if the downloaded archive data set is left "pristine", by specifying an output directory OUTSIDE of the input directory tree.

<p>
<dt>(stemoutputs = DEFAULT) [string]
<dd>Base (stem) output name used for creating output files. If set to "DEFAULT", then <code>steminputs</code> is used.

<p>
<dt>entry_stage = 1 [1|2|3]
<dd>Entry stage, 1 or 2.
<p>Stage 1: Re-calibrate unfiltered event files.
<p>Stage 2: Start from existing unfiltered event files.

<p>
<dt>exit_stage = 2 [1|2|3]
<dd>Exit stage, 1 or 2.
<p>Stage 1: Produces calibrated unfiltered event files.
<p>Stage 2: Produces screened event files.

<p>
<dt>instrument = ALL [string]
<dd>Comma delimited list of which instruments to process. List can include the following values:
<ul>
 <li>ALL  - Process all data for all modules of all instruments
 <li>HXI  - Process HXI data (both HXI1 and HXI2) only
 <li>HXI1 - Process HXI data HXI1 only
 <li>HXI2 - Process HXI data HXI2 only
 <li>SGD  - Process SGD data (both SGD1 and SGD2) only
 <li>SGD1 - Process SGD data SGD1 only
 <li>SGD2 - Process SGD data SGD2 only
 <li>SXS  - Process SXS data only
 <li>SXI  - Process SXI data only
</ul>

<p>More than one value may be specified at one time:
<ul>
 <li>Combination of HXI1 and HXI2 is allowed, is equivalent to HXI.
 <li>Combination of SGD1 and SGD2 is allowed, is equivalent to SGD.
</ul>


<p>
<dt>verify_input [boolean]</dt>
<dd>Verify with ftverify (yes, no)</dd>
</p>

<p>
<dt>(attitude = DEFAULT) [string]</dt>
<dd>Attitude file</dd>
</p>

<p>
<dt>(housekeeping = DEFAULT) [string]</dt>
<dd>Housekeeping file</dd>
</p>

<p>
<dt>(extended_housekeeping = DEFAULT) [string]</dt>
<dd>Extended housekeeping file</dd>
</p>

<p>
<dt>(makefilter = DEFAULT) [string]</dt>
<dd>Makefilter file</dd>
</p>

<p>
<dt>(orbit = DEFAULT) [string]</dt>
<dd>Orbit file</dd>
</p>

<p>
<dt>(timfile = DEFAULT) [string]</dt>
<dd>Time file</dd>
</p>

<p>
<dt>(obsgti = DEFAULT) [string]</dt>
<dd>Observation GTI file</dd>
</p>

<p>
<dt>(calc_pointing = yes) [boolean]</dt>
<dd>Calculate nominal pointing ([yes]/no)</dd>
</p>

<p>
<dt>(calc_optaxis = yes) [boolean]</dt>
<dd>Calculate optical axis keywords ([yes]/no)</dd>
</p>

<p>
<dt>(create_ehkmkf = no) [boolean]</dt>
<dd>Create the EHK and MKF files (yes/[no])</dd>
</p>

<p>
<dt>(makeregion = no) [boolean]</dt>
<dd>Make a region file (yes/[no])</dd>
</p>

<p>
<dt>(ra = -999.99999) [real]</dt>
<dd>RA of nominal pointing [deg]</dd>
</p>

<p>
<dt>(dec = -999.99999) [real]</dt>
<dd>Dec of nominal pointing [deg]</dd>
</p>

<p>
<dt>(roll = 0.0) [real]</dt>
<dd>Roll of nominal pointing [deg]</dd>
</p>

<p>
<dt>(leapsecfile = REFDATA) [filename]</dt>
<dd>gen: Input leap second file (or CALDB, [REFDATA])</dd>
</p>

<p>
<dt>(selectfile = CALDB) [filename]</dt>
<dd>gen: Input file with the selection expressions</dd>
</p>

<p>
<dt>(mkfconf = CALDB) [filename]</dt>
<dd>gen: Input file with the selection expressions</dd>
</p>

<p>
<dt>(cor2file = CALDB) [filename]</dt>
<dd>Input cut-off rigidity Suzaku file (or CALDB)</dd>
</p>

<p>
<dt>(cor3file = CALDB) [filename]</dt>
<dd>Input cut-off rigidity IGRF 2016 file (or CALDB)</dd>
</p>

<p>
<dt>(saafile = CALDB) [filename]</dt>
<dd>CALDB</dd>
</p>

<p>
<dt>(hxi_start = 0.0) [real]</dt>
<dd>HXI CALDB start time</dd>
</p>

<p>
<dt>(hx1_teldef = CALDB) [filename]</dt>
<dd>coordevt: teldeffile hxi1</dd>
</p>

<p>
<dt>(hx2_teldef = CALDB) [filename]</dt>
<dd>coordevt: teldeffile hxi2</dd>
</p>

<p>
<dt>(hxi_remapfile = CALDB) [filename]</dt>
<dd>hxisgdsff/hxievtid: remapping file</dd>
</p>

<p>
<dt>(hxi_gainfile = CALDB) [filename]</dt>
<dd>hxisgdpha: PHA calibration functions</dd>
</p>

<p>
<dt>(hxi_badpixfile = CALDB) [filename]</dt>
<dd>hxisgdpha/hxievtid: readout channels</dd>
</p>

<p>
<dt>(hxi_fluorefile = CALDB) [filename]</dt>
<dd>hxievtid: Input fluorescence file</dd>
</p>

<p>
<dt>(hxi_enecutfile = CALDB) [filename]</dt>
<dd>hxievtid: Input energy cut file</dd>
</p>

<p>
<dt>(cm1_teldef = CALDB) [filename]</dt>
<dd>cams2att: CAMS1 teldeffile</dd>
</p>

<p>
<dt>(cm2_teldef = CALDB) [filename]</dt>
<dd>cams2att: CAMS2 teldeffile</dd>
</p>

<p>
<dt>(camstempxy = CALDB) [filename]</dt>
<dd>cams2att: CAMS temperature correction file</dd>
</p>

<p>
<dt>(sgd_start = 0.0) [real]</dt>
<dd>SGD CALDB start time</dd>
</p>

<p>
<dt>(sg1_teldef = CALDB) [filename]</dt>
<dd>coordevt: teldeffile</dd>
</p>

<p>
<dt>(sg2_teldef = CALDB) [filename]</dt>
<dd>coordevt: teldeffile</dd>
</p>

<p>
<dt>(sgd_remapfile = CALDB) [filename]</dt>
<dd>hxisgdsff/hxievtid: remapping file</dd>
</p>

<p>
<dt>(sgd_gainfile = CALDB) [filename]</dt>
<dd>hxisgdpha: PHA calibration functions</dd>
</p>

<p>
<dt>(sgd_badpixfile = CALDB) [filename]</dt>
<dd>hxisgdpha/hxievtid: readout channels</dd>
</p>

<p>
<dt>(sgd_fluorefile = CALDB) [filename]</dt>
<dd>sgdevtid: Input fluorescence file</dd>
</p>

<p>
<dt>(sgd_probseqfile = CALDB) [filename]</dt>
<dd>sgdevtid: sequence probability file</dd>
</p>

<p>
<dt>(sgd_probfovfile = CALDB) [filename]</dt>
<dd>sgdevtid: FOV probability file</dd>
</p>

<p>
<dt>(sxi_start = 0.0) [real]</dt>
<dd>SXI CALDB start time</dd>
</p>

<p>
<dt>(sxi_teldef = CALDB) [filename]</dt>
<dd>coordevt: teldeffile</dd>
</p>

<p>
<dt>(sxi_badpixfile = CALDB) [filename]</dt>
<dd>sxiflagpix: badpixfile</dd>
</p>

<p>
<dt>(sxi_maskfile = CALDB) [filename]</dt>
<dd>sxiflagpix: maskfile</dd>
</p>

<p>
<dt>(sxi_vtevnodd = CALDB) [filename]</dt>
<dd>sxipi: evenodd</dd>
</p>

<p>
<dt>(sxi_ctifile = CALDB) [filename]</dt>
<dd>sxipi: cti</dd>
</p>

<p>
<dt>(sxi_chtrailfile = CALDB) [filename]</dt>
<dd>sxipi: chtrail</dd>
</p>

<p>
<dt>(sxi_spthfile = CALDB) [filename]</dt>
<dd>sxipi: splitth</dd>
</p>

<p>
<dt>(sxi_gainfile = CALDB) [filename]</dt>
<dd>sxipi: gain</dd>
</p>

<p>
<dt>(sxi_patternfile = CALDB) [filename]</dt>
<dd>sxipi: grade</dd>
</p>

<p>
<dt>(sxs_start = 0.0) [real]</dt>
<dd>SXS CALDB start time</dd>
</p>

<p>
<dt>(sxs_teldef = CALDB) [filename]</dt>
<dd>coordevt: teldeffile</dd>
</p>

<p>
<dt>(sxs_coeftime = CALDB) [string]</dt>
<dd>sxssamcnt: Input file with arrival time coeffs</dd>
</p>

<p>
<dt>(sxs_pixdeffile = CALDB) [filename]</dt>
<dd>sxsflagpix: Input SXS electrical pixel map file</dd>
</p>

<p>
<dt>(sxs_gainfile = CALDB) [filename]</dt>
<dd>sxsupi: Input SXS gain coefficients file</dd>
</p>

<p>
<dt>(sxs_linefitfile = CALDB) [filename]</dt>
<dd>sxsdrift: Input calibration line file</dd>
</p>

<p>
<dt>(sxs_gainantfile = CALDB) [filename]</dt>
<dd>sxsanticopi: Input antico gain file</dd>
</p>

<p>
<dt>(sxs_delayfile = CALDB) [filename]</dt>
<dd>Input instrument delay file (or CALDB)</dd>
</p>

<p>
<dt>(hxi_mkflabel = HXISFFA1CAM) [string]</dt>
<dd>Label to use for HXI MKF GTI creation</dd>
<dd>For pseudo events "PSE" replaces CAM in the label</dd>
</p>

<p>
<dt>(hxi_ehklabel = HXISFFA1CAM) [string]</dt>
<dd>Label to use for HXI EHK GTI creation</dd>
<dd>For pseudo events "PSE" replaces CAM in the label</dd>
</p>

<p>
<dt>(hxi_evtlabel = HXISFFA1CAM) [string]</dt>
<dd>Label to use for HXI event screening</dd>
<dd>For pseudo events "PSE" replaces CAM in the label</dd>
</p>

<p>
<dt>(sgd_mkflabel = SGDSFFA1#) [string]</dt>
<dd>Label to use for SGD MKF GTI creation. The hash is replaced by a respective Compton camera: CC1, CC2 or CC3</dd>
<dd>For pseudo events "PSE" is appended to the end of the label</dd>
</p>

<p>
<dt>(sgd_ehklabel = SGDSFFA1#) [string]</dt>
<dd>Label to use for SGD EHK GTI creation. The hash is replaced by a respective Compton camera: CC1, CC2 or CC3</dd>
<dd>For pseudo events "PSE" is appended to the end of the label</dd>
</p>

<p>
<dt>(sgd_evtlabel = SGDSFFA1#) [string]</dt>
<dd>Label to use for SGD event screening. The hash is replaced by a respective Compton camera: CC1, CC2 or CC3</dd>
<dd>For pseudo events "PSE" is appended to the end of the label</dd>
</p>

<p>
<dt>(sxi_mkflabel = SXI#SCI) [string]</dt>
<dd>Label to use for SXI MKF GTI creation. The hash is replaced by a respective mode: CCDW1, CCD12WA or CCD34WF</dd>
</p>

<p>
<dt>(sxi_ehklabel = SXI#SCI) [string]</dt>
<dd>Label to use for SXI EHK GTI creation. The hash is replaced by a respective mode: CCDW1, CCD12WA or CCD34WF</dd>
</p>

<p>
<dt>(sxi_evtlabel = SXI#SCI) [string]</dt>
<dd>Label to use for SXI event screening. The hash is replaced by a respective mode: CCDW1, CCD12WA or CCD34WF</dd>
</p>

<p>
<dt>(sxs_mkflabel = PIXELALL3) [string]</dt>
<dd>Label to use for SXS MKF GTI creation</dd>
</p>

<p>
<dt>(sxs_ehklabel = PIXELALL3) [string]</dt>
<dd>Label to use for SXS EHK GTI creation</dd>
</p>

<p>
<dt>(sxs_evtlabel = PIXELALL3) [string]</dt>
<dd>Label to use for SXS event screening</dd>
</p>

<p>
<dt>(dattfile = datt.out) [string]</dt>
<dd>output datt file with drift corrections</dd>
</p>

<p>
<dt>(coordevt_startsys = LOWEST) [string]</dt>
<dd>Starting coordinate system</dd>
</p>

<p>
<dt>(stopsys = HIGHEST) [string]</dt>
<dd>Final coordinate system</dd>
</p>

<p>
<dt>(annaber = no) [string]</dt>
<dd>Apply annual aberration correction (yes, [no], INVERT)</dd>
</p>

<p>
<dt>(followsun = no) [boolean]</dt>
<dd>Recalculate the Sun position for each event (yes, [no])</dd>
</p>

<p>
<dt>(orbaber = no) [string]</dt>
<dd>Apply sat orbital aberration correction (yes, [no], INVERT)</dd>
</p>

<p>
<dt>(attinterp = LINEAR) [string]</dt>
<dd>Sky attitude interpolation method (LINEAR, CONSTANT)</dd>
</p>

<p>
<dt>(dattinterp = LINEAR) [string]</dt>
<dd>Delta attitude interpolation method (LINEAR, CONSTANT)</dd>
</p>

<p>
<dt>(attdt = 32.) [real]</dt>
<dd>Allowed margin for time extrapolation in attfile [s]</dd>
</p>

<p>
<dt>(dattdt = 0.5) [real]</dt>
<dd>Allowed margin for time extrapolation in dattfile [s]</dd>
</p>

<p>
<dt>(chkattgap = no) [boolean]</dt>
<dd>Limit attitude interpolation if gaps present (yes, [no])</dd>
</p>

<p>
<dt>(chkdattgap = yes) [boolean]</dt>
<dd>Limit delta attitude interpolation if gaps present ([yes], no)</dd>
</p>

<p>
<dt>(attext = ATTITUDE) [string]</dt>
<dd>Attitude extension</dd>
</p>

<p>
<dt>(attcol = QPARAM) [string]</dt>
<dd>Attitude column</dd>
</p>

<p>
<dt>(attform = QUAT) [string]</dt>
<dd>Attitude format ([QUAT], EULER)</dd>
</p>

<p>
<dt>(orbext = ORBIT) [string]</dt>
<dd>Orbit extension</dd>
</p>

<p>
<dt>(orbcol = VELOCITY) [string]</dt>
<dd>Orbital velocity column</dd>
</p>

<p>
<dt>(orbform = VECTOR) [string]</dt>
<dd>Orbital velocity format ([VECTOR], COMPONENTS, KEPLERIAN)</dd>
</p>

<p>
<dt>(coordevt_randomize = TELDEF) [string]</dt>
<dd>Randomize coordinates when rebinning ([TELDEF], yes, no)</dd>
</p>

<p>
<dt>(randsys = TELDEF) [string]</dt>
<dd>Starting system for randomization (or TELDEF)</dd>
</p>

<p>
<dt>(randscalesys = TELDEF) [string]</dt>
<dd>System to determine randomization amount (or TELDEF)</dd>
</p>

<p>
<dt>(infileext = EVENTS) [string]</dt>
<dd>Event extension</dd>
</p>

<p>
<dt>(inclfloatcol = no) [boolean]</dt>
<dd>Write non-rounded coordinate columns (yes, [no])</dd>
</p>

<p>
<dt>(inclfloatskycol = no) [boolean]</dt>
<dd>Write non-rounded sky coordinate columns (yes, [no])</dd>
</p>

<p>
<dt>(floatcolsuffix = _FLOAT) [string]</dt>
<dd>Suffix for non-rounded coordinate columns</dd>
</p>

<p>
<dt>(startwithfloat = no) [boolean]</dt>
<dd>Start with non-rounded startsys coordinates (yes, [no])</dd>
</p>

<p>
<dt>(blankcol = yes) [boolean]</dt>
<dd>Assign null values to columns not calculated ([yes], no)</dd>
</p>

<p>
<dt>(btnull = 255) [integer]</dt>
<dd>TNULL for byte (B) columns</dd>
</p>

<p>
<dt>(itnull = -999) [integer]</dt>
<dd>TNULL for short (I) columns</dd>
</p>

<p>
<dt>(jtnull = -999) [integer]</dt>
<dd>TNULL for long (J) columns</dd>
</p>

<p>
<dt>(ktnull = -999) [integer]</dt>
<dd>TNULL for long (K) columns</dd>
</p>

<p>
<dt>(sbtnull = 255) [integer]</dt>
<dd>TNULL for signed byte columns</dd>
</p>

<p>
<dt>(uitnull = -999) [integer]</dt>
<dd>TNULL for unsigned short columns</dd>
</p>

<p>
<dt>(ujtnull = -999) [integer]</dt>
<dd>TNULL for unsigned long columns</dd>
</p>

<p>
<dt>(outnsubcol = no) [boolean]</dt>
<dd>Output the PHA_NSUB column (yes/no)</dd>
</p>

<p>
<dt>(datamode = NONE) [string]</dt>
<dd>Substitute DATAMODE in place of event value (or NONE)</dd>
</p>

<p>
<dt>(outcalfile = NONE) [filename]</dt>
<dd>Output reconstruction tracing file (or NONE)</dd>
</p>

<p>
<dt>(startstep = 1) [integer]</dt>
<dd>Starting step of calculation (1-5)</dd>
</p>

<p>
<dt>(stopstep = 5) [integer]</dt>
<dd>Ending step of calculation (1-5)</dd>
</p>

<p>
<dt>(inext = EVENTS) [string]</dt>
<dd>Input extension</dd>
</p>

<p>
<dt>(outext = CAMS_OFFSETS) [string]</dt>
<dd>Output extension</dd>
</p>

<p>
<dt>(flipsign = no) [boolean]</dt>
<dd>Flip sign of output offsets and angles (yes/[no])</dd>
</p>

<p>
<dt>(prefiltfile1 = NONE) [string]</dt>
<dd>Prefiltered file for CAMS1</dd>
</p>

<p>
<dt>(prefiltfile2 = NONE) [string]</dt>
<dd>Prefiltered file for CAMS2</dd>
</p>

<p>
<dt>(filtoffset = NONE) [string]</dt>
<dd>Filtered offset file</dd>
</p>

<p>
<dt>(prefiltexpr = DSP_UP==1 && IS_SAMPLING==1) [string]</dt>
<dd>Expression to filter input files</dd>
</p>

<p>
<dt>(filtexpr = BAD_UNITS==0) [string]</dt>
<dd>Expression to filter offset file</dd>
</p>

<p>
<dt>(gtiexpr0 = BAD_UNITS==0) [string]</dt>
<dd>Expression to create GTI for both CAMS</dd>
</p>

<p>
<dt>(gtiexpr1 = BAD_UNITS==2) [string]</dt>
<dd>Expression to create GTI for CAMS1</dd>
</p>

<p>
<dt>(gtiexpr2 = BAD_UNITS==1) [string]</dt>
<dd>Expression to create GTI for CAMS2</dd>
</p>

<p>
<dt>(startsys = RAW) [string]</dt>
<dd>Starting coordinate system (cams2att)</dd>
</p>

<p>
<dt>(deltaxcol = DELTARAWX) [string]</dt>
<dd>Column with change in detector X coordinate</dd>
</p>

<p>
<dt>(deltaycol = DELTARAWY) [string]</dt>
<dd>Column with change in detector Y coordinate</dd>
</p>

<p>
<dt>(sincol = SINANGLE) [string]</dt>
<dd>Column with sine of rotation angle</dd>
</p>

<p>
<dt>(coscol = COSANGLE) [string]</dt>
<dd>Column with cosine of rotation angle</dd>
</p>

<p>
<dt>(outtracefile = NONE) [filename]</dt>
<dd>Output reconstruction tracing file (or NONE)</dd>
</p>

<p>
<dt>(numsignal = 48) [integer]</dt>
<dd>Maximum number of signals to analyze</dd>
</p>

<p>
<dt>(d10 = 3.2) [real]</dt>
<dd>Shortest distance between two adjacent pixels [mm]</dd>
</p>

<p>
<dt>(d1a1a = 5.0) [real]</dt>
<dd>Diag distance between two adjacent pixels in layer [mm]</dd>
</p>

<p>
<dt>(d1a1b = 5.0) [real]</dt>
<dd>Distance between two layers (CdTe-CdTe fluor) [mm]</dd>
</p>

<p>
<dt>(d1a2 = 14.0) [real]</dt>
<dd>Distance for combining Si-CdTe fluorescence [mm]</dd>
</p>

<p>
<dt>(d1a3 = 5.0) [real]</dt>
<dd>Distance for combining Si-Si electron scattering [mm]</dd>
</p>

<p>
<dt>(a = 3.0) [real]</dt>
<dd>Acceptance tolerance for F test in Step 2</dd>
</p>

<p>
<dt>(b = 3.0) [real]</dt>
<dd>Acceptance tolerance for G test in Step 2</dd>
</p>

<p>
<dt>(probaccept2 = 0.1) [real]</dt>
<dd>Probability threshold for M=2 acceptance in Step 3</dd>
</p>

<p>
<dt>(probaccept3 = 0.1) [real]</dt>
<dd>Probability threshold for M=3 acceptance in Step 3</dd>
</p>

<p>
<dt>(probaccept4 = 0.1) [real]</dt>
<dd>Probability threshold for M=4 acceptance in Step 3</dd>
</p>

<p>
<dt>(distz = 1000000.0) [real]</dt>
<dd>Very large distance of target object in Step 4 [mm]</dd>
</p>

<p>
<dt>(paraoffset0 = 1.6) [real]</dt>
<dd>Parameter used in calculating G[k,0]</dd>
</p>

<p>
<dt>(paraoffset1 = 1.0) [real]</dt>
<dd>Parameter used in calculating G[k,1]</dd>
</p>

<p>
<dt>(paraoffset2 = 1.0) [real]</dt>
<dd>Parameter used in calculating G[k,2]</dd>
</p>

<p>
<dt>(weight0 = 1.0) [real]</dt>
<dd>Parameter used in calculating G[k,0] for FOM</dd>
</p>

<p>
<dt>(weight1 = 0.0) [real]</dt>
<dd>Parameter used in calculating G[k,1] for FOM</dd>
</p>

<p>
<dt>(weight2 = 0.0) [real]</dt>
<dd>Parameter used in calculating G[k,2] for FOM</dd>
</p>

<p>
<dt>(weight3 = 0.0) [real]</dt>
<dd>Parameter used in calculating Prob[k] for FOM</dd>
</p>

<p>
<dt>(delgmethod = ANALYTIC) [string]</dt>
<dd>Method used to calculate Delta cos(theta)</dd>
</p>

<p>
<dt>(skipreco = no) [boolean]</dt>
<dd>Skip reconstruction of READALL/CALMODE events</dd>
</p>

<p>
<dt>(rejectbgo = no) [boolean]</dt>
<dd>Reject BGO events (yes/[no])</dd>
</p>

<p>
<dt>(occurrenceid = -1) [integer]</dt>
<dd>Occurrence to process (if >0)</dd>
</p>

<p>
<dt>(calc_hotpix = no) [boolean]</dt>
<dd>Run coordevt on hot pixel file (yes/[no])</dd>
</p>

<p>
<dt>(calc_modegti = yes) [boolean]</dt>
<dd>Calculate SXI data mode GTI ([yes]/no)</dd>
</p>

<p>
<dt>(colbound = -32768) [string]</dt>
<dd>TNULL, TLMIN, TLMAX for PHAS</dd>
</p>

<p>
<dt>(chipcol = CCD_ID) [string]</dt>
<dd>Chip column (or NONE)</dd>
</p>

<p>
<dt>(xcol = ACTX) [string]</dt>
<dd>X coordinate column</dd>
</p>

<p>
<dt>(ycol = ACTY) [string]</dt>
<dd>Y coordinate column</dd>
</p>

<p>
<dt>(chancol = PI) [string]</dt>
<dd>Pulse height column (or NONE)</dd>
</p>

<p>
<dt>(gradecol = GRADE) [string]</dt>
<dd>Event grade column (or NONE)</dd>
</p>

<p>
<dt>(grade = 0) [string]</dt>
<dd>Event grade for clean (or ALL)</dd>
</p>

<p>
<dt>(n_division = 1) [integer]</dt>
<dd>Divide total observation time into the given number</dd>
</p>

<p>
<dt>(cleanimg = no) [boolean]</dt>
<dd>Output cleaned image for debugging (yes, no)</dd>
</p>

<p>
<dt>(cellsize = 7) [integer]</dt>
<dd>Poisson clean cell size (odd integer > 1)</dd>
</p>

<p>
<dt>(impfac = 320) [real]</dt>
<dd>Factor for gamma function</dd>
</p>

<p>
<dt>(logprob1 = -5.6) [real]</dt>
<dd>Log Poisson probability threshold</dd>
</p>

<p>
<dt>(logprob2 = -5.6) [real]</dt>
<dd>Log Poisson probability threshold for second step</dd>
</p>

<p>
<dt>(iterate = yes) [boolean]</dt>
<dd>Iterate the second step Poisson clean (yes, no)</dd>
</p>

<p>
<dt>(flagedge = no) [boolean]</dt>
<dd>Zero chip edge pixels (yes, no)</dd>
</p>

<p>
<dt>(bthresh = 3) [integer]</dt>
<dd>Zero background threshold</dd>
</p>

<p>
<dt>(duration = no) [boolean]</dt>
<dd>Perform detailed search for flickering duration (yes, no)</dd>
</p>

<p>
<dt>(sigma = 3.0) [real]</dt>
<dd>Significance level for flickering duration</dd>
</p>

<p>
<dt>(firstchip = TLMIN) [string]</dt>
<dd>Min value for chip number</dd>
</p>

<p>
<dt>(lastchip = TLMAX) [string]</dt>
<dd>Max value for chip number</dd>
</p>

<p>
<dt>(xmin = TLMIN) [string]</dt>
<dd>Min value for X coordinate</dd>
</p>

<p>
<dt>(xmax = TLMAX) [string]</dt>
<dd>Max value for X coordinate</dd>
</p>

<p>
<dt>(ymin = TLMIN) [string]</dt>
<dd>Min value for Y coordinate</dd>
</p>

<p>
<dt>(ymax = TLMAX) [string]</dt>
<dd>Max value for Y coordinate</dd>
</p>

<p>
<dt>(chanmin = TLMIN) [string]</dt>
<dd>Min pulse-height value for clean (inclusive)</dd>
</p>

<p>
<dt>(chanmax = TLMAX) [string]</dt>
<dd>Max pulse-height value for clean (inclusive)</dd>
</p>

<p>
<dt>(outbadpix = no) [boolean]</dt>
<dd>Output bad pixel file (yes/[no]). This parameter is not a boolean in sxiflagpix but rather a filename. For ahpipeline and sxipipeline this is boolean to account for multiple files </dd>
</p>

<p>
<dt>(outbadimg = yes) [boolean]</dt>
<dd>Output bad pixel image ([yes]/no). This parameter is not a boolean in sxiflagpix but rather a filename. For ahpipeline and sxipipeline this is boolean to account for multiple files </dd>
</p>

<p>
<dt>(npixnbr = 1) [integer]</dt>
<dd>Pixel distance defining a neighbor</dd>
</p>

<p>
<dt>(nboundnbr = 1) [integer]</dt>
<dd>Pixel distance defining neighbor from CCD/window/segment boundary</dd>
</p>

<p>
<dt>(citrailnbr = 2) [integer]</dt>
<dd>Pixel distance trailing CI row</dd>
</p>

<p>
<dt>(ciprenbr = 1) [integer]</dt>
<dd>Pixel distance preceding CI row</dd>
</p>

<p>
<dt>(echoflag = yes) [integer]</dt>
<dd>Flag CR echo pixels ([yes]/no)</dd>
</p>

<p>
<dt>(echomap = yes) [integer]</dt>
<dd>Output CR echo pixel fraction map (yes/[no])</dd>
</p>

<p>
<dt>(echonbr = 2) [integer]</dt>
<dd>Distance in pixels from a cosmic ray echo pixel to flag a neighbor
pixel.</dd>
</p>

<p>
<dt>(echomin = 6) [integer]</dt>
<dd>Minimum number of events for the cosmic ray echo fraction
calculation.</dd>
</p>

<p>
<dt>(echospth = 15) [integer]</dt>
<dd>Split threshold for cosmic ray echo fraction calculation.</dd>
</p>

<p>
<dt>(echofrac = 0.7) [float]</dt>
<dd>Minimum fraction of hits defining a cosmic ray echo pixel.  For any
pixel contained in at least 'echomin' events, if at least 'echofrac' of those
events have a pulse height above 'echospth', then the pixel is
considered a cosmic ray echo pixel.</dd>
</p>

<p>
<dt>(bad_status = 3:9,11,12,16:19,25:28,30,37) [string]</dt>
<dd>Bad status list, colons can used to specify a range (e.g. 1:3,5 = 1,2,3,5)</dd>
</p>

<p>
<dt>(copyphas = yes) [boolean]</dt>
<dd>Copy original PHAS before processing ([yes]/no)</dd>
</p>

<p>
<dt>(resetflags = yes) [boolean]</dt>
<dd>Reset all sxiflagpix STATUS flags ([yes]/no)</dd>
</p>

<p>
<dt>(hkext = HK_SXI_USR_USER_HK1) [string]</dt>
<dd>HK extension with video temperatures</dd>
</p>

<p>
<dt>(hkcolstem = SXI_USR_HKTBL_) [string]</dt>
<dd>Column name stem for video temperatures</dd>
</p>

<p>
<dt>(hkvideoid = A,B,B,B) [string]</dt>
<dd>Video card ID for gain correction of CCD1-4</dd>
</p>

<p>
<dt>(startcol = PHAS) [string]</dt>
<dd>Starting point of correction</dd>
</p>

<p>
<dt>(evnoddcor = yes) [boolean]</dt>
<dd>Enable even-odd correction [yes/no]</dd>
</p>

<p>
<dt>(chtrailcor = yes) [boolean]</dt>
<dd>Enable charge trail correction [yes/no]</dd>
</p>

<p>
<dt>(cticor = yes) [boolean]</dt>
<dd>Enable CTI correction [yes/no]</dd>
</p>

<p>
<dt>(gaincor = yes) [boolean]</dt>
<dd>Enable gain correction [yes/no]</dd>
</p>

<p>
<dt>(ctigrade = no) [boolean]</dt>
<dd>Use grade information in CTI correction [yes/no]</dd>
</p>

<p>
<dt>(copygrade = no) [boolean]</dt>
<dd>Copy existing GRADE and PHA columns [yes/no]</dd>
</p>

<p>
<dt>(phcut = CALDB) [string]</dt>
<dd>Pulse-height cut for CTI correction, or CALDB</dd>
</p>

<p>
<dt>(badpixopt = 2) [integer]</dt>
<dd>Options for events with bad pixels: ignore bad pixels (1), null bad pixels (2), null whole event (3)</dd>
</p>

<p>
<dt>(spthiter = yes) [boolean]</dt>
<dd>Enable split threshold iteration [yes/no]</dd>
</p>

<p>
<dt>(spthcaldb = yes) [boolean]</dt>
<dd>Use split thresholds from spthfile [yes/no]</dd>
</p>

<p>
<dt>(spthoffset = 15.) [real]</dt>
<dd>Split threshold offset value (if spthcaldb = no)</dd>
</p>

<p>
<dt>(spthslope = 0.) [real]</dt>
<dd>Split threshold slope value (if spthcaldb = no)</dd>
</p>

<p>
<dt>(evtthre = DEFAULT) [string]</dt>
<dd>Event threshold (or DEFAULT)</dd>
</p>

<p>
<dt>(negthre = -5000) [integer]</dt>
<dd>Minimum PHAS value for normal event</dd>
</p>

<p>
<dt>(deltatime = 8) [integer]</dt>
<dd>Max allowed time gap in HK temp search [s]</dd>
</p>

<p>
<dt>(debugcol = no) [boolean]</dt>
<dd>Write out the debug columns [yes/no]</dd>
</p>

<p>
<dt>(sxs_resetflags = yes) [boolean]</dt>
<dd>Reset all sxsflagpix STATUS flags ([yes]/no)</dd>
</p>

<p>
<dt>(adrgti = REFDATA) [string]</dt>
<dd>Input ADR GTI file (or [REFDATA])</dd>
</p>
<p>

<p>
<dt>(acphaoffset = 0.0) [float]</dt>
<dd>Average offset added to PHA values before applying the gain.  A random
offset is added to each PHA between -0.5+acphaoffset and +0.5+acphaoffset.
So, when acphaoffset=0.5, the random offset is between 0 and 1. </dd>
</p>

<p>
<dt>(pxphaoffset = 0.0) [float]</dt>
<dd>Average offset added to PHA values before applying the gain.  A random
offset is added to each PHA between -0.5+acphaoffset and +0.5+acphaoffset.
So, when acphaoffset=0.5, the random offset is between 0 and 1. </dd>
</p>

<dt>(timecol = TIME) [string]</dt>
<dd>Time column</dd>
</p>

<p>
<dt>(stimecol = S_TIME) [string]</dt>
<dd>Name of S_TIME column</dd>
</p>

<p>
<dt>(tioncol = FWE_TI_LED#_ON) [string]</dt>
<dd>Input TI columns with LED on (#=1-4)</dd>
</p>

<p>
<dt>(tioffcol = FWE_TI_LED#_OFF) [string]</dt>
<dd>Input TI columns with LED off (#=1-4)</dd>
</p>

<p>
<dt>(plslencol = FWE_LED#_PLS_LEN) [string]</dt>
<dd>Input pulse length columns (#=1-4)</dd>
</p>

<p>
<dt>(plsspccol = FWE_LED#_PLS_SPC) [string]</dt>
<dd>Input pulse spacing columns (#=1-4)</dd>
</p>

<p>
<dt>(timeoncol = TIME_LED#_ON) [string]</dt>
<dd>Output LED-on time columns (#=1-4)</dd>
</p>

<p>
<dt>(timeoffcol = TIME_LED#_OFF) [string]</dt>
<dd>Output LED-off time columns (#=1-4)</dd>
</p>

<p>
<dt>(calctime = yes) [boolean]</dt>
<dd>Perform time assignment ([yes]/no)</dd>
</p>

<p>
<dt>(calcgti = yes) [boolean]</dt>
<dd>Produce GTI files ([yes]/no)</dd>
</p>

<p>
<dt>(afterglow = no) [boolean]</dt>
<dd>Add afterglow to fine GTI STOP times (no/[yes])</dd>
</p>

<p>
<dt>(dtdecay = CALDB) [string]</dt>
<dd>Afterglow time [s] (or CALDB)</dd>
</p>

<p>
<dt>(interp = twopoint) [string]</dt>
<dd>Interpolation method (NEAREST, TWOPOINT)</dd>
</p>

<p>
<dt>(margingti = yes) [boolean]</dt>
<dd>Create GTI between TSTART/TSTOP and first/last input GTI</dd>
</p>

<p>
<dt>(tstart = DEFAULT) [string]</dt>
<dd>Value to use for TSTART in seconds (or take from infile)</dd>
</p>

<p>
<dt>(tstop = DEFAULT) [string]</dt>
<dd>Value to use for TSTOP in seconds(or take from infile)</dd>
</p>

<p>
<dt>(dt = 0.) [real]</dt>
<dd>Time separation between input and output GTI (seconds)</dd>
</p>

<p>
<dt>(antpsp = A) [string]</dt>
<dd>Antico PSP to use for coincidence (A=PSPA B=PSPB)</dd>
</p>

<p>
<dt>(antshift = CALDB) [string]</dt>
<dd>Time shift [s] to apply to antico events (or CALDB)</dd>
</p>

<p>
<dt>(calcant = yes) [boolean]</dt>
<dd>Flag antico events ([yes]/no)</dd>
</p>

<p>
<dt>(antdtpre = CALDB) [string]</dt>
<dd>Delta time [s] preceding an antico event (or CALDB)</dd>
</p>

<p>
<dt>(antdtfol = CALDB) [string]</dt>
<dd>Delta time [s] following an antico event (or CALDB)</dd>
</p>

<p>
<dt>(antswitch = 1) [integer]</dt>
<dd>If =1 use antdtfol, =0 read delta-time from file</dd>
</p>

<p>
<dt>(antphathr = 71) [integer]</dt>
<dd>PHA threshold for antico events</dd>
</p>

<p>
<dt>(antdurthr = 2) [integer]</dt>
<dd>DURATION threshold for antico events</dd>
</p>

<p>
<dt>(calcctrec = yes) [boolean]</dt>
<dd>Flag recoil cross-talk ([yes]/no)</dd>
</p>

<p>
<dt>(ctrecdt = CALDB) [string]</dt>
<dd>Delta time [s] for flagging recoil cross-talk (or CALDB)</dd>
</p>

<p>
<dt>(calcprox = yes) [boolean]</dt>
<dd>Flag electrical cross talk ([yes]/no)</dd>
</p>

<p>
<dt>(proxdt = CALDB) [string]</dt>
<dd>Delta time [s] to define simultaneous events (or CALDB)</dd>
</p>

<p>
<dt>(calcctel = yes) [boolean]</dt>
<dd>Flag electrical cross talk ([yes]/no)</dd>
</p>

<p>
<dt>(cteldt = CALDB) [string]</dt>
<dd>Delta time [s] for flagging electrical cross-talk (or CALDB)</dd>
</p>

<p>
<dt>(ctelnear = 1) [integer]</dt>
<dd>Number of pixels for flagging electrical cross-talk</dd>
</p>

<p>
<dt>(calcctel2 = yes) [boolean]</dt>
<dd>Flag electrical cross talk 2 ([yes]/no)</dd>
</p>

<p>
<dt>(cteldt2 = CALDB) [string]</dt>
<dd>Delta time [s] for flagging electrical cross-talk 2 (or CALDB)</dd>
</p>

<p>
<dt>(ctelnear2 = 1) [integer]</dt>
<dd>Number of pixels for flagging electrical cross-talk 2</dd>
</p>


<p>
<dt>(pxpithr = 600) [integer]</dt>
<dd>Events with PI values below this threshold are excluded from 
flagging checks given by the usepxpithr parameter.</dd>
</p>

<p>
<dt>(usepxpithr = ALL) [string]</dt>
<dd>A comma-delimited list specifying which flagging types should use
the pxpithr parameter for excluding events. Allowed values in the list 
are ALL, NONE, PROX (proximity), CTEL (electrical cross talk),  
CTEL2 (2nd electrical cross talk), and  CTREC (recoil cross talk).
Events that do not belong to the types specified in the list are excluded 
from flagging regardless of their PI value.  
</dd>
</p>

<p>
<dt>(calcmxs = yes) [boolean]</dt>
<dd>Flag MXS pixels ([yes]/no)</dd>
</p>

<p>
<dt>(calc_gtilost = no) [boolean]</dt>
<dd>Calculate SXS lost off GTI (yes/[no])</dd>
</p>

<p>
<dt>(screenlost = no) [boolean]</dt>
<dd>Screen lost events (yes/[no])</dd>
</p>

<p>
<dt>(mxsdt = CALDB) [string]</dt>
<dd>Delta time [s] to extend MXS stop time (or CALDB)</dd>
</p>

<p>
<dt>(kalow = 5860.) [real]</dt>
<dd>Lower energy limit of Mn K-alpha for recoil PHA test [eV]</dd>
</p>

<p>
<dt>(kahigh = 5930.) [real]</dt>
<dd>Upper energy limit of Mn K-alpha for recoil PHA test [eV]</dd>
</p>

<p>
<dt>(kbeta = 6450.) [real]</dt>
<dd>Energy of Mn K-beta for recoil PHA test [eV]</dd>
</p>

<p>
<dt>(dtflag = no) [boolean]</dt>
<dd>Add delta-time columns for cross-talk and antico (yes/[no])</dd>
</p>

<p>
<dt>(dtprimary = CALDB) [string]</dt>
<dd>Time interval [ms] for primary (or CALDB)</dd>
</p>

<p>
<dt>(dtlowmid = CALDB) [string]</dt>
<dd>Upper time range [ms] for low secondary (or CALDB)</dd>
</p>

<p>
<dt>(dtmidhigh = CALDB) [string]</dt>
<dd>Upper time range [ms] for mid secondary (or CALDB)</dd>
</p>

<p>
<dt>(tol = 2.) [real]</dt>
<dd>Tolerance of time intervals [ns]</dd>
</p>

<p>
<dt>(regrade = no) [boolean]</dt>
<dd>Recalculate grade assignment (yes/[no])</dd>
</p>

<p>
<dt>(gaincoeff = H) [string]</dt>
<dd>Type of gain coefficients to use ([H]/M/L)</dd>
</p>

<p>
<dt>(linetocorrect = Mnka) [string]</dt>
<dd>Line to fit (HDU name in linefitfile)</dd>
</p>

<p>
<dt>(numevent = 250) [integer]</dt>
<dd>Maximum number of events in a single spectrum</dd>
</p>

<p>
<dt>(minevent = 150) [integer]</dt>
<dd>Minimum number of events in a single spectrum</dd>
</p>

<p>
<dt>(grpoverlap = 0.) [real]</dt>
<dd>Percentage of overlap between adjacent groups</dd>
</p>

<p>
<dt>(startenergy = -1.) [real]</dt>
<dd>Start energy [eV] of bin mesh (-1 = automatic)</dd>
</p>

<p>
<dt>(stopenergy = -1.) [real]</dt>
<dd>Stop energy [eV] of bin mesh (-1 = automatic)</dd>
</p>

<p>
<dt>(extraspread = 100.) [real]</dt>
<dd>Extend bin mesh energy range [eV]</dd>
</p>

<p>
<dt>(broadening = 1.0) [real]</dt>
<dd>FWHM Gaussian broadening of calibration line profile [eV]</dd>
</p>

<p>
<dt>(gridprofile = no) [boolean]</dt>
<dd>Calculate only the grid profile (yes/[no])</dd>
</p>

<p>
<dt>(fitwidth = yes) [boolean]</dt>
<dd>Fit spectrum width (yes/[no])</dd>
</p>

<p>
<dt>(background = CONST) [string]</dt>
<dd>Fitted background type (NONE, CONST, SLOPE)</dd>
</p>

<p>
<dt>(spangti = no) [boolean]</dt>
<dd>Ignore GTI boundaries when binning spectra (yes/[no])</dd>
</p>

<p>
<dt>(usemp = no) [boolean]</dt>
<dd>Include Mp events when fitting (yes/[no])</dd>
</p>

<p>
<dt>(calcerr = no) [boolean]</dt>
<dd>Compute uncertainties on shift and width (yes/[no])</dd>
</p>

<p>
<dt>(writeerrfunc = no) [boolean]</dt>
<dd>Output uncertainty functions (yes/[no])</dd>
</p>

<p>
<dt>(avgwinrad = 30) [real]</dt>
<dd>Radius of interval [binwidth] used to update average</dd>
</p>

<p>
<dt>(minwidth0 = 1.0) [real]</dt>
<dd>Smallest allowed initial value in width fitting [binwidth]</dd>
</p>

<p>
<dt>(maxitcycle = 5) [integer]</dt>
<dd>Maximum number of fitting iterations</dd>
</p>

<p>
<dt>(r2tol = .001) [real]</dt>
<dd>Convergence criterion for R^2</dd>
</p>

<p>
<dt>(searchstepshift = 2.) [real]</dt>
<dd>Step size when fitting shift [binwidth]</dd>
</p>

<p>
<dt>(maxdshift = 5.) [real]</dt>
<dd>Largest allowed deviation from initial guess of shift [binwidth]</dd>
</p>

<p>
<dt>(bisectolshift = .001) [real]</dt>
<dd>Tolerance of shift to stop bisection method [binwidth]</dd>
</p>

<p>
<dt>(searchstepwidth = 5.) [real]</dt>
<dd>Step size when fitting width [binwidth]</dd>
</p>

<p>
<dt>(maxdwidth = 10.) [real]</dt>
<dd>Largest allowed deviation from initial guess of width [binwidth]</dd>
</p>

<p>
<dt>(bisectolwidth = .001) [real]</dt>
<dd>Tolerance of width to stop bisection method [binwidth]</dd>
</p>

<p>
<dt>(minwidth = .5) [real]</dt>
<dd>Smallest width to allow in width fitting [binwidth]</dd>
</p>

<p>
<dt>(nerrshift = 100) [integer]</dt>
<dd>Number of shift values in uncertainty calculations</dd>
</p>

<p>
<dt>(nerrwidth = 100) [integer]</dt>
<dd>Number of width values in uncertainty calculations</dd>
</p>

<p>
<dt>(shifterrfac = 3.0) [real]</dt>
<dd>Factor for determining domain of shift uncertainty arrays</dd>
</p>

<p>
<dt>(widtherrfac = 4.0) [real]</dt>
<dd>Factor for determining domain of width uncertainty arrays</dd>
</p>

<p>
<dt>(calcupi = yes) [boolean]</dt>
<dd>Calculate UPI column ([yes]/no)</dd>
</p>

<p>
<dt>(sxs_pulsefile = CALDB) [filename]</dt>
<dd>Input file with pulse amplitudes (or CALDB)</dd>
</p>

<p>
<dt>(phaout = PHA2) [filename]</dt>
<dd>Name of output PHA column</dd>
</p>

<p>
<dt>(sxs_scalefile = CALDB) [filename]</dt>
<dd>Input EPI scale file for cal-pix (or CALDB)</dd>
</p>

<p>
<dt>(secphacol = PHA) [string]</dt>
<dd>Input PHA column to use for secondary correction</dd>
</p>

<p>
<dt>(scaleepi = no) [boolean]</dt>
<dd>Scale EPI values using scalefile (yes/[no])</dd>
</p>

<p>
<dt>(scalegrade = 0) [string]</dt>
<dd>List of grades to apply scale factors</dd>
</p>

<p>
<dt>(calcpi = yes) [boolean]</dt>
<dd>Calculate PI column ([yes]/no)</dd>
</p>

<p>
<dt>(addepicol = EPI2) [string]</dt>
<dd>Output energy column with secondary correction</dd>
</p>

<p>
<dt>(method = FIT) [string]</dt>
<dd>Correction method (FIT or AVERAGE)</dd>
</p>

<p>
<dt>(extended = no) [boolean]</dt>
<dd>Use extended energy range (yes/[no])</dd>
</p>

<p>
<dt>(binwidth = 0.5) [real]</dt>
<dd>PI bin width for extended energy range [eV]</dd>
</p>

<p>
<dt>(offset = 0.5) [real]</dt>
<dd>Offset for first PI for extended energy range [eV]</dd>
</p>

<p>
<dt>(tlmax = 32767) [integer]</dt>
<dd>Maximum PI channel for extended energy range</dd>
</p>

<p>
<dt>(writetemp = no) [boolean]</dt>
<dd>Output temperature used for each event (yes/[no])</dd>
</p>

<p>
<dt>(dgfile = REFDATA) [file]</dt>
<dd>Input gain coefficients file</dd>
</p>

<p>
<dt>(offsetfile = REFDATA) [file]</dt>
<dd>calibration offset file</dd>
</p>

<p>
<dt>(outrange = NULL) [file]</dt>
<dd>How events are handled outside time range</dd>
</p>

<p>
<dt>(itypecol = ITYPE) [string]</dt>
<dd>ITYPE column</dd>
</p>

<p>
<dt>(ckctrec = no) [boolean]</dt>
<dd>Exclude events with recoil cross-talk (yes/[no])</dd>
</p>

<p>
<dt>(ckctel = no) [boolean]</dt>
<dd>Exclude events with electrical cross-talk (yes/[no])</dd>
</p>

<p>
<dt>(ckant = no) [boolean]</dt>
<dd>Exclude events with antico coincidence (yes/[no])</dd>
</p>

<p>
<dt>(ckrisetime = yes) [boolean]</dt>
<dd>Do not use events with RISE_TIME > 127 ([yes]/no)</dd>
</p>

<p>
<dt>(tempidx = 2) [integer]</dt>
<dd>Input temperature index for selecting gain</dd>
</p>

<p>
<dt>(ntemp = 3) [integer]</dt>
<dd>Number of temperatures from gain file to use in interpolation</dd>
</p>

<p>
<dt>(gapdt = -1.) [real]</dt>
<dd>Time [s] between events to define a gap (or <0)</dd>
</p>

<p>
<dt>(extrap = no) [boolean]</dt>
<dd>Allow extrapolation when determining drift temperature (yes/[no])</dd>
</p>

<p>
<dt>(randomize = yes) [boolean]</dt>
<dd>Allow randomization ([yes]/no)</dd>
</p>

<p>
<dt>(seed = 0) [integer]</dt>
<dd>Random number generator seed (0=use system time)</dd>
</p>

<p>
<dt>(startdate = ) [string]</dt>
<dd>Start date/time of ahpipeline (output)</dd>
</p>

<p>
<dt>(numerrs = 0) [string]</dt>
<dd>Number of errors from ahpipeline (output)</dd>
</p>

<p>
<dt>(cleanup = yes) [boolean]</dt>
<dd>Delete temporary files ([yes]/no)</dd>
</p>

<p>
<dt>(clobber = no) [boolean]</dt>
<dd>Overwrites the existing output file if set to yes (yes/[no]). </dd>
</p>

<p>
<dt>(chatter = 1) [integer] </dt>
<dd>Chatter level for output. Set to 0 to suppress output,
or to 1, 2, or 3 for increasing the chatter of the output. </dd>
</p>

<p>
<dt>(logfile = !DEFAULT) [string]</dt>
<dd>Log filename. If set to DEFAULT uses the name of the task and, if
preceded by '!', overwrite the file if it exists. If set to NONE no
log file is created. </dd>
</p>

<p>
<dt>(debug = no) [boolean]</dt>
<dd>Diagnostic output is printed out on the screen if set to yes
(yes/[no]).</dd>
</p>

<p>
<dt>(history = yes) [boolean]</dt>
<dd>Records tool parameters in HISTORY  ([yes]/no).</dd>
</p>

<p>
<dt>(mode = ql) [string ql|hl|q]</dt>
<dd>Mode to query the parameter file.
Acceptable values include: 'ql' (query and learn/remember), 'hl' (hidden and learn/remember), 'q' (query but don't remember)\
, 'h' (hidden). </dd>
</p>

</dl>

<h2>EXAMPLES</h2>

<ol>
 <li>The following command recalibrates (stage 1) and re-screen (stage 2) all HXI, SGD, SXS and SXI data for sequence 100039010 that currently resides in the directory /data/100039010/, and the output is stored in a directory called /data/100039010_reproc/:

 <p><code>ahpipeline indir=/data/100039010 outdir=/data/100039010_reproc entry_stage=1 exit_stage=2 steminputs=ah100039010 instrument=ALL</code>
 </li>

 <li>The following command re-screens (stage 2 only) HXI1 data for the same data set as in the previous example:

 <p><code>ahpipeline indir=/data/100039010 outdir=/data/100039010_reproc entry_stage=2 exit_stage=2 steminputs=ah100039010 instrument=HXI1</code>
 </li>

</ol>

<h2>NOTES</h2>

<p>None, but see help for individual parameters above.

<h2>SEE ALSO</h2>

ahcalctime hxipipeline sgdpipeline sxipipeline sxspipeline ahfilter ahgtigen ahscreen

<h2>LAST MODIFIED</h2>
<p>February 2016

</body>

</html>
