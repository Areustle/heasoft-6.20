#!/usr/bin/perl 
#
# 
#	nupipeline
#
#	INVOCATION:
#
#		nupipeline [parameter=value ...]
#
#	DESCRIPTION:
#               Script to perform NuSTAR Data Reduction.
#
#	DOCUMENTATION:
#
#
#	CHANGE HISTORY:
#        0.1.0 - NS 12/05/11 - First version
#        0.1.1 - NS 14/07/11 - Added 'nucalcpos' task
#        0.1.2 - NS 22/07/11 - Added 'runcalcpha' input parameter
#        0.1.3 - NS 02/08/11 - Added 'inpsdfilecor' input parameter
#                            - Update 'SOFTVER' keyword in output event files 
#        0.1.4 - NS 06/10/11 - Added 'alignfile' and 'mastaspectfile' input parameters
#        0.1.5 - NS 10/10/11 - Added 'runcalcpi' input parameter
#                            - Removed 'nucalcpos' task
#                            - Added 'nucoord' task
#                            - Added 'nuhotpix' task
#        0.1.6 - NS 24/10/11 - Added 'nufilter' task
#        0.1.7 - NS 02/11/11 - Added 'nuscreen' task
#        0.1.8 - NS 21/11/11 - Added 'indir', 'steminputs' and 'stemoutputs' input parameters
#                            - Removed 'fpma_stemoutputs' and 'fpmb_stemoutputs' input parameters
#                            - Handle 'pntra' and 'pntdec' input parameters as "POINT" or "degrees" or "hh mm ss.s"
#        0.1.9 - NS 02/12/11 - Added 'numetrology' task
#                            - Updated nucoord task call with 'pntra' and 'pntdec' input parameters
#                            - Added 'fpma_optaxisfile' and 'fpmb_optaxisfile' input parameters
#        0.2.0 - NS 22/12/11 - Added 'nuproducts' task
#        0.2.1 - NS 25/01/12 - Updated nucoord task call
#        0.2.2 - NS 16/02/12 - Added 'fpma_clcfile', 'fpmb_clcfile' and 'clcfilterfile' input parameters
#                            - Updated 'nuscreen' task call with new 'hkfile' parameter
#        0.2.3 - NS 27/02/12 - Added 'nuexpomap' and 'nuflagdepth' tasks
#                            - Updated 'nuproducts' task call
#        0.2.4 - NS 28/03/12 - Added 'fpma_inoptaxisfile', 'fpma_indet1reffile', 'fpmb_inoptaxisfile' and 'fpmb_indet1reffile' input parameters
#        0.2.5 - NS 17/04/12 - Modified nufilter and nuscreen task call
#        0.2.6 - NS 08/05/12 - Handle standard naming convention for nuexpomap output files 
#                            - Added 'phibin' input parameter
#        0.2.7 - NS 13/07/12 - Replaced 'nuflagdepth' with 'nuflagevt' task
#                            - Added 'fpma_evtcutfile' and 'fpmb_evtcutfile' input parameters
#                            - Replaced 'runflagdepth' with 'runflagevt' input parameter
#        0.2.8 - NS 19/07/12 - Added "fpm[a|b]_hkrangefile[01|02|03|04|05]" and "gtiexpr[01|02|03|04|05]" input parameters
#        0.2.9 - NS 26/07/12 - Updated 'nuproducts' task call
#                            - Added 'copyattitude' input parameter
#                            - Handle "OBJECT" value for 'pntra' and 'pntdec' input parameters
#        0.3.0 - NS 04/10/12 - Added 'nucalcsaa' task
#        0.3.1 - NS 24/10/12 - Added input parameters needed by new version of nufilter task
#                            - Added input parameters needed by new version of nuproducts task
#                            - Added input parameters needed by new version of nuscreen task
#                            - Added 'nuattcorr' task
#                            - Removed 'copyattitude' input parameter
#                            - Handle 'NORMAL_SC(06)' observing mode
#                            - Added "fpm[a|b]_hkrangefile06" and "gtiexpr06" input parameters
#        0.3.2 - NS 11/12/12 - Added input parameters needed by new version of nuexpomap task
#                            - Added input parameters needed by new version of nuproducts task
#        0.3.3 - NS 25/02/13 - Update 'CALDBVER' keyword in output event files 
#                            - Added input parameters needed by new version of nuproducts task
#        0.3.4 - NS 14/03/13 - Added input parameters needed by new version of nuproducts task
#        0.3.5 - NS 12/04/13 - Added input parameters needed by new version of nuproducts task
#        0.3.6 - NS 10/06/13 - Added input parameters needed by new version of nuproducts task
#        0.3.7 - NS 11/07/13 - Added input parameters needed by new version of nuproducts and nuexpomap task
#        0.3.8 - NS 18/07/13 - Added input parameters needed by new version of nuproducts task
#        0.3.9 - NS 12/09/13 - Added input parameters needed by new version of numetrology task
#        0.4.0 - NS 18/09/13 - Added reporting of the Metrology laser spots out of calibrated PSD grid time
#        0.4.1 - NS 28/11/13 - Added input parameters needed by new version of nuproducts task
#        0.4.2 - NS 09/04/14 - Handle compressed TLE input file
#                            - Removed use of deprecated 'define' PERL function
#        0.4.3 - NS 26/05/14 - Added input parameters needed by new version of nuproducts task
#        0.4.4 - NS 19/05/15 - Handle empty Level 2 Event File
#                            - Update 'CALDBVER' keyword also in EVENTS ext of the output event files
#                            - Added input parameters needed by new version of nuproducts task
#        0.4.5 - RF 30/03/16 - Added input parameters needed by new version of nucalcsaa task
#                            - Added input parameters needed by new nusplitsc task
#        0.4.6 - RF 06/10/16 - Handling of multiple TLE files in the archive
#                            - Bug corrected when reading a string with ‘&’ characters in the input parameter ‘statusexpr’
#                            - Bug corrected for the case runmetrology=no: searching mast aspect and psdcor files in the ‘event_cl’ directory (was in the ‘auxil’ one)
#        
#
#	AUTHORS:
#
#       ASDC - ASI Science Data Center
#
#


# NuSTAR perl library
require "libnustarperl.pl";

use strict;
#use File::Find ();
use File::Copy;
use File::Basename;
use Astro::FITS::CFITSIO qw(:longnames :constants);

use vars qw(%Task %Default %Def %Parms_str %Parms_str_fpma %Parms_str_fpmb %Parms_num %Parms_num_fpma %Parms_num_fpmb %Parms_bool %Parms_bool_fpma %Parms_bool_fpmb);
use vars qw(%EvtFiles %InData %OutFiles %InFiles %InFilesDir %InFilesExt @CleanupList);

#
#  Defaults
#
%Default = (
	    DEFAULT         => "DEFAULT",
	    CALDB           => "CALDB",
	    NONE            => "NONE",
	    NOTVALDPARNUMB  => "-",
	    NOTVALDPARBOOL  => "-",
	    NOTVALIDRADEC   => -91,
	    LLINE           => "------------------------------------------------------------\n",
	    LLINE2          => "============================================================\n",
	    ENDLINE         => "=============================================================================================\n",
	    ALLOBSMODES     => ["01", "02", "03", "04", "05", "06"],
	   );


#
# Specific of the task
#
%Task = (
	 start         => `date`,
	 name          => "nupipeline",
	 version       => "0.4.6",
	 releasedate   => "2016-10-06",
	 stem          => "nupipeline_0.4.6",
	 emptystem     => "                ",
	 clobber       => 0,  # it means 'clobber=no'
	 chatter       => 3,
	 status        => 0,
	 errmess       => "",
	 errors        => 0,
	 report        => "",
	 ranom         => $Default{NOTVALIDRADEC},
	 decnom        => $Default{NOTVALIDRADEC},
	 srcra         => $Default{NOTVALIDRADEC},
	 srcdec        => $Default{NOTVALIDRADEC},
	 bkgra         => $Default{NOTVALIDRADEC},
	 bkgdec        => $Default{NOTVALIDRADEC},
	 instr         => [], # list of instrument to be processed
	 obsmode       => [], # list of observing mode to be processed
	 obsmodename   => {
	                  '01' => "SCIENCE",
			  '02' => "OCCULTATION",
			  '03' => "SLEW",
			  '04' => "SAA",
			  '05' => "CALIBRATION",
	                  '06' => "SCIENCE_SC",
		          },
	 stemout       => "",
	 nrun          => 0,
	 );


#
#  Parameters
#

%Parms_str = (
	      # common parameters
	      indir            => "",
	      steminputs       => "",
	      outdir           => "",
	      stemoutputs      => "",
	      instrument       => "",
	      pntra            => "",
	      pntdec           => "",
	      obsmode          => "",
	      attfile          => "",
	      cebhkfile        => "",
	      chu123hkfile     => "",
	      alignfile        => "",
              # numetrology task
	      metgridfile      => "",
	      metrologyfile    => "",
	      inpsdfilecor     => "",
	      outpsdfile       => "",
	      outpsdfilecor    => "",
	      mastaspectfile   => "",
              # nuattcorr task
	      outattfile       => "",
	      chuoffsetfile    => "",
              # nucalcpha task
	      gradefile        => "",
              # nucalcpi task
	      clcfilterfile    => "",
              # nucoord task
	      inmastaspectfile => "",
	      attinterpol      => "",
              # nucalcsaa task
	      saaparfile       => "",
	      saamode          => "",
	      hkevtexpr        => "",
              # nufilter task
	      orbitfile        => "",
	      preconfigfile    => "",
	      tlemode          => "",
	      tlefile          => "",
	      leapfile         => "",
	      rigfile          => "",
	      origin           => "",
	      mkfconfigfile    => "",
	      mkfgtiexpr       => "",
	      # nuscreen task
	      gtiexpr01        => "",
	      gtiexpr02        => "",
	      gtiexpr03        => "",
	      gtiexpr04        => "",
	      gtiexpr05        => "",
	      gtiexpr06        => "",
	      gradeexpr        => "",
	      statusexpr       => "",
	      usrgtifile       => "",
	      depthcut         => "",
	      timecol          => "",
	      gtiext           => "",
	      # nusplitsc task
	      splitmode        => "",
	      chu123rangefile  => "",
	      # nuexpomap task
	      # nuproducts task
	      srcregionfile    => "",
	      bkgregionfile    => "",
	      srcra            => "",
	      srcdec           => "",
	      bkgra            => "",
	      bkgdec           => "",
	      productsgtifile  => "",
	      plotdevice       => "",
	      clockfile        => "",
	     );

%Parms_str_fpma = (
	      # common parameters
	      fpma_infile      => "",
	      fpma_pixposfile  => "",
	      fpma_instrprobmapfile => "",
	      fpma_vignfile    => "",
	      fpma_apstopcorrfile=> "",
	      fpma_grcorrfile    => "",
	      fpma_detabscorrfile=> "",
	      fpma_inoptaxisfile => "",
	      fpma_indet1reffile => "",
              # nuflagbad task
	      fpma_bpfile      => "",
	      fpma_dispixfile  => "",
	      fpma_userbpfile  => "",
	      fpma_outbpfile   => "",	
	      # nuhotpix task
	      fpma_outhpfile   => "",
              # nucalcpha task
	      fpma_phaparfile  => "",
	      fpma_capoffsetfile=>"",
              # nucalcpi task
	      fpma_hkfile      => "",
	      fpma_gainfile    => "",
	      fpma_clcfile     => "",
              # nuflagevt task
	      fpma_depthcutfile=> "",
	      fpma_evtcutfile  => "",
              # nucoord task
	      fpma_teldef      => "",
	      fpma_optaxisfile => "",
	      fpma_det1reffile => "",
              # nucalcsaa task
	      fpma_outhkfile   => "",
              # nufilter task
	      fpma_attorbfile  => "",
	      fpma_mkffile     => "",
	      # nuscreen task
	      fpma_hkrangefile01   => "",
	      fpma_hkrangefile02   => "",
	      fpma_hkrangefile03   => "",
	      fpma_hkrangefile04   => "",
	      fpma_hkrangefile05   => "",
	      fpma_hkrangefile06   => "",
	      fpma_evtrangefile    => "",
	      # nuexpomap task
	      fpma_det1offsetfile  => "",
	      fpma_aspecthistofile => "",
	      fpma_det1instrfile   => "",
	      fpma_det2instrfile   => "",
	      fpma_skyinstrfile    => "",
	      fpma_expomapfile     => "",
	      # nuproducts task
	      fpma_lcfile      => "",
	      fpma_phafile     => "",
	      fpma_bkglcfile   => "",
	      fpma_bkgphafile  => "",
	      fpma_imagefile   => "",
	      fpma_outarffile  => "",
	      fpma_inarffile   => "",
	      fpma_psffile     => "",
	      fpma_grppsffile  => "",
	      fpma_psfdir      => "",
	      fpma_outrmffile  => "",
	      fpma_grprmffile  => "",
	      fpma_rmfdir      => "",
	      fpma_lcsrccorrfile   => "",
	      fpma_lcbkgcorrfile   => "",
	     );

%Parms_str_fpmb = (
	      # common parameters
	      fpmb_infile      => "",
	      fpmb_pixposfile  => "",
	      fpmb_instrprobmapfile => "",
	      fpmb_vignfile    => "",
	      fpmb_apstopcorrfile=> "",
	      fpmb_grcorrfile    => "",
	      fpmb_detabscorrfile=> "",
	      fpmb_inoptaxisfile => "",
	      fpmb_indet1reffile => "",
              # nuflagbad task
	      fpmb_bpfile      => "",
	      fpmb_dispixfile  => "",
	      fpmb_userbpfile  => "",
	      fpmb_outbpfile   => "",
	      # nuhotpix task
	      fpmb_outhpfile   => "",
              # nucalcpha task
	      fpmb_phaparfile  => "",
	      fpmb_capoffsetfile=>"",
              # nucalcpi task
	      fpmb_hkfile      => "",
	      fpmb_gainfile    => "",
	      fpmb_clcfile     => "",
              # nuflagevt task
	      fpmb_depthcutfile=> "",
	      fpmb_evtcutfile  => "",
              # nucoord task
	      fpmb_teldef      => "",
	      fpmb_optaxisfile => "",
	      fpmb_det1reffile => "",
              # nucalcsaa task
	      fpmb_outhkfile   => "",
              # nufilter task
	      fpmb_attorbfile  => "",
	      fpmb_mkffile     => "",
	      # nuscreen task
	      fpmb_hkrangefile01   => "",
	      fpmb_hkrangefile02   => "",
	      fpmb_hkrangefile03   => "",
	      fpmb_hkrangefile04   => "",
	      fpmb_hkrangefile05   => "",
	      fpmb_hkrangefile06   => "",
	      fpmb_evtrangefile    => "",
	      # nuexpomap task
	      fpmb_det1offsetfile  => "",
	      fpmb_aspecthistofile => "",
	      fpmb_det1instrfile   => "",
	      fpmb_det2instrfile   => "",
	      fpmb_skyinstrfile    => "",
	      fpmb_expomapfile     => "",
	      # nuproducts task
	      fpmb_lcfile      => "",
	      fpmb_phafile     => "",
	      fpmb_bkglcfile   => "",
	      fpmb_bkgphafile  => "",
	      fpmb_imagefile   => "",
	      fpmb_outarffile  => "",
	      fpmb_inarffile   => "",
	      fpmb_psffile     => "",
	      fpmb_grppsffile  => "",
	      fpmb_psfdir      => "",
	      fpmb_outrmffile  => "",
	      fpmb_grprmffile  => "",
	      fpmb_rmfdir      => "",
	      fpmb_lcsrccorrfile   => "",
	      fpmb_lcbkgcorrfile   => "",
	     );

%Parms_num  = (
	       # common parameters
	       entrystage      => $Default{'NOTVALDPARNUMB'},
	       exitstage       => $Default{'NOTVALDPARNUMB'},
	       chatter         => $Default{'NOTVALDPARNUMB'},
	       percent         => $Default{'NOTVALDPARNUMB'},
               # nuhotpix task
	       hpbinsize       => $Default{'NOTVALDPARNUMB'},
	       hpcellsize      => $Default{'NOTVALDPARNUMB'},
	       impfac          => $Default{'NOTVALDPARNUMB'},
	       logpos          => $Default{'NOTVALDPARNUMB'},
	       bthresh         => $Default{'NOTVALDPARNUMB'},
               # nucoord task
	       seedcoordinator => $Default{'NOTVALDPARNUMB'},
	       timemargin      => $Default{'NOTVALDPARNUMB'},
              # nufilter task
	       interval        => $Default{'NOTVALDPARNUMB'},
	       # nuexpomap task
	       energy          => $Default{'NOTVALDPARNUMB'},
	       pixbin          => $Default{'NOTVALDPARNUMB'},
	       skyx            => $Default{'NOTVALDPARNUMB'},
	       skyy            => $Default{'NOTVALDPARNUMB'},
	       skysize         => $Default{'NOTVALDPARNUMB'},
	       # nuproducts task
	       srcradius       => $Default{'NOTVALDPARNUMB'},
	       bkgradius1      => $Default{'NOTVALDPARNUMB'},
	       bkgradius2      => $Default{'NOTVALDPARNUMB'},
	       lcbinsize       => $Default{'NOTVALDPARNUMB'},
	       pilow           => $Default{'NOTVALDPARNUMB'},
	       pihigh          => $Default{'NOTVALDPARNUMB'},
	       phibin          => $Default{'NOTVALDPARNUMB'},
	       apstopphibin    => $Default{'NOTVALDPARNUMB'},
	       grphibin        => $Default{'NOTVALDPARNUMB'},
	       boxsize         => $Default{'NOTVALDPARNUMB'},
	       pilowarf        => $Default{'NOTVALDPARNUMB'},
	       pihigharf       => $Default{'NOTVALDPARNUMB'},
	       srcra_barycorr  => $Default{'NOTVALDPARNUMB'},
	       srcdec_barycorr => $Default{'NOTVALDPARNUMB'},
	       lcenergy        => $Default{'NOTVALDPARNUMB'},
	       
	       # nucalcsaa task
	       saacalc          => $Default{'NOTVALDPARNUMB'},
	       optimizedrms     => $Default{'NOTVALDPARNUMB'},
	       tentaclerms      => $Default{'NOTVALDPARNUMB'},
	       sourcethr        => $Default{'NOTVALDPARNUMB'},
	      );

%Parms_num_fpma  = (
               # nucalcpha task
	       fpma_evtthr     => $Default{'NOTVALDPARNUMB'},
	       fpma_timerise   => $Default{'NOTVALDPARNUMB'},
               # nucoord task
	       fpma_det1xref   => $Default{'NOTVALDPARNUMB'},
	       fpma_det1yref   => $Default{'NOTVALDPARNUMB'},
	      );

%Parms_num_fpmb  = (
               # nucalcpha task
	       fpmb_evtthr     => $Default{'NOTVALDPARNUMB'},
	       fpmb_timerise   => $Default{'NOTVALDPARNUMB'},
               # nucoord task
	       fpmb_det1xref   => $Default{'NOTVALDPARNUMB'},
	       fpmb_det1yref   => $Default{'NOTVALDPARNUMB'},
	      );

%Parms_bool = (
               # common parameters
	       initseed     => $Default{'NOTVALDPARBOOL'},
	       cleancols    => $Default{'NOTVALDPARBOOL'},
	       cleanup      => $Default{'NOTVALDPARBOOL'},
	       clobber      => $Default{'NOTVALDPARBOOL'},
	       history      => $Default{'NOTVALDPARBOOL'},
	       # numetrology task
	       runmetrology => $Default{'NOTVALDPARBOOL'},
	       metflag      => $Default{'NOTVALDPARBOOL'},
	       psdcal       => $Default{'NOTVALDPARBOOL'},
               # nuhotpix task
	       cleanflick   => $Default{'NOTVALDPARBOOL'},
	       hpiterate    => $Default{'NOTVALDPARBOOL'},
               # nucalcpha task
	       runcalcpha   => $Default{'NOTVALDPARBOOL'},
               # nucalcpi task
	       runcalcpi    => $Default{'NOTVALDPARBOOL'},
               # nucoord task
	       aberration   => $Default{'NOTVALDPARBOOL'},
	       follow_sun   => $Default{'NOTVALDPARBOOL'},
	       randomizecoordinator => $Default{'NOTVALDPARBOOL'},
               # nucalcsaa task
	       tentacle        => $Default{'NOTVALDPARBOOL'},
	       eliminatesource => $Default{'NOTVALDPARBOOL'}, 
	       tentacleregcut  => $Default{'NOTVALDPARBOOL'},
               # nufilter task
	       nonulls      => $Default{'NOTVALDPARBOOL'},
	       # nuscreen task
	       gtiscreen      => $Default{'NOTVALDPARBOOL'},
	       evtscreen      => $Default{'NOTVALDPARBOOL'},
	       createattgti   => $Default{'NOTVALDPARBOOL'},
	       createinstrgti => $Default{'NOTVALDPARBOOL'},
	       # nuexpomap task
	       createexpomap  => $Default{'NOTVALDPARBOOL'},
	       expovignflag   => $Default{'NOTVALDPARBOOL'},
	       # nuproducts task
	       bkgextract     => $Default{'NOTVALDPARBOOL'},
	       correctlc      => $Default{'NOTVALDPARBOOL'},
	       runmkarf       => $Default{'NOTVALDPARBOOL'},
	       psfflag        => $Default{'NOTVALDPARBOOL'},
	       arfvignflag    => $Default{'NOTVALDPARBOOL'},
	       arfapstopflag  => $Default{'NOTVALDPARBOOL'},
	       arfgrflag      => $Default{'NOTVALDPARBOOL'},
	       arfdetabsflag  => $Default{'NOTVALDPARBOOL'},
	       extended       => $Default{'NOTVALDPARBOOL'},
	       flatflagarf    => $Default{'NOTVALDPARBOOL'},
	       runmkrmf       => $Default{'NOTVALDPARBOOL'},
	       runbackscale   => $Default{'NOTVALDPARBOOL'},
	       cutmaps        => $Default{'NOTVALDPARBOOL'},
	       barycorr       => $Default{'NOTVALDPARBOOL'},
	       productsgtibarycorr => $Default{'NOTVALDPARBOOL'},
	       cmprmf         => $Default{'NOTVALDPARBOOL'},
	       lcpsfflag      => $Default{'NOTVALDPARBOOL'},
	       lcexpoflag     => $Default{'NOTVALDPARBOOL'},
	       lcvignflag     => $Default{'NOTVALDPARBOOL'},
	       # nnflagevt task
	       runflagevt     => $Default{'NOTVALDPARBOOL'},
	       # nusplitsc task
               runsplitsc     => $Default{'NOTVALDPARBOOL'},
               timecut        => $Default{'NOTVALDPARBOOL'},
	      );

%Parms_bool_fpma = (

	      );

%Parms_bool_fpmb = (

	      );


%EvtFiles = (
	     fpma => {
		 lev1name   => "",
		 lev1aname  => "",
		 # lev2cl[xx]name => "", must be defined in InitRun() routine
		 nfiles     => 0,
	     },
	     fpmb => {
		 lev1name   => "",
		 lev1aname  => "",
		 # lev2cl[xx]name => "", must be defined in InitRun() routine
		 nfiles     => 0,
	     },
	     );


%InData = (

	   alignfile       => "",

	   fpma => {
	       startdate     => "",
	       starttime     => "",
	       teldef        => "",
	   },
	   fpmb => {
	       startdate     => "",
	       starttime     => "",
	       teldef        => "",
	   },
	   );


%InFiles = (
	    fpma_infile         => "",
	    fpmb_infile         => "",
	    attfile             => "",
	    fpma_hkfile         => "",
	    fpmb_hkfile         => "",
	    cebhkfile           => "",
	    chu123hkfile        => "",
	    fpma_dispixfile     => "",
	    fpmb_dispixfile     => "",
	    metrologyfile       => "",
	    inpsdfilecor        => "",
	    orbitfile           => "",
	    inmastaspectfile    => "",
	    tlefile             => "",
	    );


%InFilesDir = (
	       fpma_infile         => "event_uf",
	       fpmb_infile         => "event_uf",
	       attfile             => "auxil",
	       fpma_hkfile         => "hk",
	       fpmb_hkfile         => "hk",
	       cebhkfile           => "hk",
	       chu123hkfile        => "hk",
	       fpma_dispixfile     => "hk",
	       fpmb_dispixfile     => "hk",
	       metrologyfile       => "hk",
	       inpsdfilecor        => "event_cl",
	       orbitfile           => "auxil",
	       inmastaspectfile    => "event_cl",
	       tlefile             => "auxil",
	       );


%InFilesExt = (
	       fpma_infile         => "A_uf.evt",
	       fpmb_infile         => "B_uf.evt",
	       attfile             => "_att.fits",
	       fpma_hkfile         => "A_fpm.hk",
	       fpmb_hkfile         => "B_fpm.hk",
	       cebhkfile           => "_ceb.hk",
	       chu123hkfile        => "_chu123.fits",
	       fpma_dispixfile     => "A_dspx.fits",
	       fpmb_dispixfile     => "B_dspx.fits",
	       metrologyfile       => "_met.fits",
	       inpsdfilecor        => "_psdcorr.fits",
	       orbitfile           => "_orb.fits",
	       inmastaspectfile    => "_mast.fits",
	       tlefile             => "NUSTAR_TLE_ARCHIVE.txt",
	       );


%OutFiles = (

	     mastaspectfile => "",
	     outpsdfile     => "",
	     outpsdfilecor  => "",
	     outattfile     => "",

	     fpma => {
		 # Stage 1
		 outbpfile      => "",
		 outhpfile      => "",
		 optaxisfile    => "",
		 det1reffile    => "",
		 # Stage 2
		 outhkfile      => "",
		 attorbfile     => "",
		 mkffile        => "",
		 # gtifile[xx]  => "", must be defined in InitRun() routine
		 # Stage 3
		 expomapfile    => "",
		 lcfile         => "",
		 phafile        => "",
		 bkglcfile      => "",
		 bkgphafile     => "",	
		 imagefile      => "",
		 outarffile     => "",
		 outrmffile     => "",		 
		 det1offsetfile => "",
		 aspecthistofile=> "",
		 det1instrfile  => "",
		 det2instrfile  => "",
		 skyinstrfile   => "",
		 lcsrccorrfile  => "",
		 lcbkgcorrfile  => "",
	     },
	     fpmb => {
		 # Stage 1
		 outbpfile      => "",
		 outhpfile      => "",
		 optaxisfile    => "",
		 det1reffile    => "",
		 # Stage 2
		 outhkfile      => "",
		 attorbfile     => "",
		 mkffile        => "",
		 # gtifile[xx]  => "", must be defined in InitRun() routine
		 # Stage 3
		 expomapfile    => "",
		 lcfile         => "",
		 phafile        => "",
		 bkglcfile      => "",
		 bkgphafile     => "",	
		 imagefile      => "",
		 outarffile     => "",
		 outrmffile     => "",
		 det1offsetfile => "",
		 aspecthistofile=> "",
		 det1instrfile  => "",
		 det2instrfile  => "",
		 skyinstrfile   => "",
		 lcsrccorrfile  => "",
		 lcbkgcorrfile  => "",
	     },
	     );


#
# Starting Messages
#
&StartProcessing;


#
# Get Input Parameters 
#
if ( &GetInputParameters ) {
    $Task{errmess} = "Error parsing input parameters";
    goto EXITWITHERROR;
}


#
# Check Input Parameters 
#
if ( &CheckInputParameters ) {
    $Task{errmess} = "Error checking input parameters";
    goto EXITWITHERROR;
}

if(&CompUL($Parms_bool{runsplitsc},"YES"))
{
      if( (!&CompUL($Parms_str{obsmode},"ALL")) && (!&CompUL($Parms_str{obsmode},"SCIENCE_SC")) )
      {
		$Task{errmess} = "Input parameter runsplitsc can be set to yes only if input parameter obsmode is set to ALL or SCIENCE_SC";
		goto EXITWITHERROR;
      }
}
#
# Set the names of the input files 
# and put them in '%InFiles' hash table
#
if ( &SetInFiles ) {
    $Task{errmess} = "Error setting the names of the input files";
    goto EXITWITHERROR;
}

#
# Set the names of the output files 
# and put them in '%OutFiles' hash table
#
if ( &SetOutFiles ) {
    $Task{errmess} = "Error setting the names of the output files";
    goto EXITWITHERROR;
}

#
# Get Input information needed to run the pipeline,
# perform some checks and set common variables
#
if ( &InitRun ) {
    $Task{errmess} = "Error while loading pipeline starting data";
    goto EXITWITHERROR;
}


#
# Set $Task{ranom} and $Task{decnom}
#
if ( &SetPointingAndSourceInfo ) {
    $Task{errmess} = "Error setting Optical Axis Direction";
    goto EXITWITHERROR;
}


#
# Run numetrology if requested
#
if( ($Parms_bool{runmetrology} =~ /[yY]/) && ($Parms_num{entrystage} == 1) ){
    if( &RunNuMetrology ) {
	goto EXITWITHERROR;
    }
}


#
# Run nuattcorr
#

if( &RunNuAttCorr ) {
    goto EXITWITHERROR;
}


#
# Run Pipeline for each instrument input by the user
#
my ($instr);
foreach $instr (@{$Task{instr}}){
  
    if ( $EvtFiles{$instr}{nfiles} == 0 ) { next; } 

    my ($instr_uc) = uc($instr);

    # Reset pipeline status
    $Task{status} = 0;

    # Increment counter of task running
    $Task{nrun} = $Task{nrun}+1;

    # Stage1
    if(&DoStage(1)){

	if(&RunStageI($instr)){
	    &AddReport(3,"$instr_uc: .... Stage   I: ERROR\n");
	    $Task{errors} = 1;
	    next;
	}
	elsif ( $Task{status} == 2 ) { 
	    if ( &DoStage(2) ) { &AddReport(3,"$instr_uc: .... Stage  II: WARNING: no screening performed on data files\n");}
	    if ( &DoStage(3) ) { &AddReport(3,"$instr_uc: .... Stage III: WARNING: no products generated for data files\n");}
	    next;
	}

    } # End Stage1

    
    # Stage2
    if(&DoStage(2)){
	
	if(&RunStageII($instr)){
	    &AddReport(3,"$instr_uc: .... Stage   II: ERROR\n");
	    $Task{errors} = 1;
	    next;
	}
	
    } # End Stage2


    # Stage3
    if(&DoStage(3)){
	
	if(&RunStageIII($instr)){
	    &AddReport(3,"$instr_uc: .... Stage  III: ERROR\n");
	    $Task{errors} = 1;
	    next;
	}
	
    } # End Stage3
    else{
	if( $Parms_bool{barycorr} =~ /[yY]/ ){
	    &AddReport(3,"$instr_uc: .............. : WARNING: Barycenter correction not applied, parameter exitstage<3\n");
	}
    }


}


#
# Cleanup temporary files
#
if ( $Parms_bool{cleanup} =~ /[yY]/ ) {
    &Cleanup(@CleanupList);
}


#
# Ending Messages
#

 ENDPIPELINE:

my ( $EndDate ) = `date`;
print $Task{report};
if ( $Task{errors} ) { 
    &PipelineEndMsg("$Task{'stem'}: ERROR: Pipeline exit with errors - $EndDate");
    exit(1);
}
else {
    &PipelineEndMsg("$Task{'stem'}: Exit with no errors - $EndDate");
    exit (0);
}

 EXITWITHERROR:

print $Task{report};
&PipelineEndMsg("$Task{'stem'}: ERROR: Pipeline exit with error: $Task{errmess}");
exit(1);





#------------------------------------------------------------------------------------------------------------
#    Pipeline Subroutines
#------------------------------------------------------------------------------------------------------------

sub StartProcessing {

    print"\n============================================================\n";
    print"                 Running NuSTAR pipeline\n";
    print" Task: $Task{'name'} Version: $Task{'version'} Release Date: $Task{'releasedate'}\n";
    print"============================================================\n";
    
    #
    # Add Starting Messages to Report
    #
    &AddReport(3,"\n============================================================\n");
    &AddReport(3,"                  NuSTAR pipeline Report\n");
    &AddReport(3," Task: $Task{'name'} Version: $Task{'version'} Release Date: $Task{'releasedate'}\n");
    &AddReport(3,"============================================================\n");

} # StartProcessing


sub AddReport {
    my ( $chatty, $string ) = @_;
    use vars qw ($Task);
    if ( $chatty <= $Task{chatter} ) {
	$Task{report} .= $string;
    }
    return;
} # AddReport


sub PipelineStageMsg {

    my ( $message ) = @_;

    &PrntChty(2, "\n$Default{LLINE2}${message}\n$Default{LLINE2}\n");

} # PipelineStageMsg

sub PipelineMessage {

    my ( $message ) = @_;

    &PrntChty(2, "$Default{LLINE}               $message\n$Default{LLINE}");

} # Pipeline Message 

sub PipelineEndMsg {

    my ( $message ) = @_;

    &PrntChty(2, "\n$Default{ENDLINE}${message}\n$Default{ENDLINE}$Default{ENDLINE}\n");

    &PrntChty(2, "    If the NuSTARDAS software was helpful for your research work, the following\n");
    &PrntChty(2, "    acknowledgement would be appreciated: \"This research has made use of the\n");
    &PrntChty(2, "    NuSTAR Data Analysis Software (NuSTARDAS) jointly developed by the ASI Science\n");
    &PrntChty(2, "    Data Center (ASDC, Italy) and the California Institute of Technology (Caltech, USA).\"\n");

    &PrntChty(2, "\n$Default{ENDLINE}$Default{ENDLINE}\n");


} # PipelineEndMsg


sub GetInputParameters {

    use vars qw( %Task  %Parms_str %Parms_num %Parms_bool );
 
    my ($name,$par);   
    
    # get the invoking string, if it exists, to pass to pquery2 for parsing

    # We quote each element since existing quotes have been stripped and we
    # need to pass this on to pquery with quotes intact

    my ($i,$invokestring);
    $invokestring = "";
    if( @ARGV ) {
	foreach $i (0 .. $#ARGV) {
	    $ARGV[$i] = "\"".$ARGV[$i]."\"";
	}
	$invokestring = join(' ',@ARGV);
    }

    # Scan input for 'instrument' parameter
    foreach $name (@ARGV) {
	if ( $name =~ /^instrument=/ ) {
	    $Parms_str{instrument} = GetInputParam ( $name );
	    if ( $Task{status} ) { return 1; }
	    last;
	}
    }
    if(!$Parms_str{instrument}){
	my ($String) = "";
	chop($String = qx(pquery2 nupipeline instrument $invokestring));
	if ( !$String && $String !~ "0" ) {
	    &PrntChty(3, "$Task{'stem'}: Error: error running: 'pquery2 nupipeline instrument $invokestring'\n");
	    return 1;
	}
	$Parms_str{instrument} = $String;
    }
 
    #Check 'instrument' parameter value
    if(!&CompUL($Parms_str{instrument},"FPMA")&&!&CompUL($Parms_str{instrument},"FPMB")&&!&CompUL($Parms_str{instrument},"ALL")){
	&PrntChty(3, "$Task{'stem'}: Error: input parameter '$Parms_str{instrument}' not allowed for parameter 'instrument'\n");
	&PrntChty(3, "$Task{'emptystem'}  Please specify one of the follows:\n");
	&PrntChty(3, "$Task{'emptystem'}   ALL - for all instruments\n");
	&PrntChty(3, "$Task{'emptystem'}  FPMA - for FPMA instrument\n");
	&PrntChty(3, "$Task{'emptystem'}  FPMB - for FPMB instrument\n");
	return 1;
    }

    #Check 'indir' parameter value
    {
	my (%tmp) = (indir => "",);
	if( &getStrPar(\%tmp, $invokestring)){ return 1;}
	$Parms_str{indir} = $tmp{indir};
    }

    #Check 'steminputs' parameter value
    {
	my (%tmp) = (steminputs => "",);
	if( &getStrPar(\%tmp, $invokestring)){ return 1;}
	$Parms_str{steminputs} = $tmp{steminputs};
    }

    #Check 'outdir' parameter value
    {
	my (%tmp) = (outdir => "",);
	if( &getStrPar(\%tmp, $invokestring)){ return 1;}
	$Parms_str{outdir} = $tmp{outdir};
    }

    #Check 'entrystage' parameter value
    {
	my (%tmp) = (entrystage  => $Default{'NOTVALDPARNUMB'},);
	if( &getNumPar(\%tmp, $invokestring)){ return 1;}
	$Parms_num{entrystage} = $tmp{entrystage};
	
	if ( $Parms_num{entrystage} != 2 ) {
	    delete $Parms_str_fpma{fpma_inoptaxisfile};
	    delete $Parms_str_fpma{fpma_indet1reffile};
	    delete $Parms_str_fpmb{fpmb_inoptaxisfile};
	    delete $Parms_str_fpmb{fpmb_indet1reffile};
	}
    }

    #Check 'exitstage' parameter value
    {
	my (%tmp) = (exitstage  => $Default{'NOTVALDPARNUMB'},);
	if( &getNumPar(\%tmp, $invokestring)){ return 1;}
	$Parms_num{exitstage} = $tmp{exitstage};
	
	if ( $Parms_num{exitstage} <= 1 ) {
	    delete $Parms_str{cebhkfile};
	}
	
	if ( $Parms_num{exitstage} <= 2 ) {
	    delete $Parms_str{srcra};
	    delete $Parms_str{srcdec};
	    delete $Parms_str{bkgra};
	    delete $Parms_str{bkgdec};
	}
    }

    #Check 'runmetrology' parameter value
    {
	my (%tmp) = (runmetrology => $Default{'NOTVALDPARBOOL'},);
	if( &getBoolPar(\%tmp, $invokestring)){ return 1;}
	$Parms_bool{runmetrology} = $tmp{runmetrology};
	
	if ( $Parms_bool{runmetrology} =~ /[nN]/ ) {
	    delete $Parms_str{metrologyfile};
	}

	if( ($Parms_bool{runmetrology} =~ /[yY]/) && ($Parms_num{entrystage}==1) ){
	    delete $Parms_str{inmastaspectfile};
	}
    }

    #Check 'metflag' parameter value
    {
	my (%tmp) = (metflag => $Default{'NOTVALDPARBOOL'},);
	if( &getBoolPar(\%tmp, $invokestring)){ return 1;}
	$Parms_bool{metflag} = $tmp{metflag};
	
	if ( $Parms_bool{metflag} =~ /[nN]/ ) {
	    delete $Parms_str{metrologyfile};
	}
	if ( $Parms_bool{metflag} =~ /[yY]/ && $Parms_num{entrystage}==1 && $Parms_bool{runmetrology} =~ /[yY]/ ){
	    delete $Parms_str{inpsdfilecor};
	}
    }

    #Check 'barycorr' parameter value
    {
	my (%tmp) = (barycorr => $Default{'NOTVALDPARBOOL'},);
	if( &getBoolPar(\%tmp, $invokestring)){ return 1;}
	$Parms_bool{barycorr} = $tmp{barycorr};
	
	if ( $Parms_bool{barycorr} =~ /[nN]/ ) {
	    delete $Parms_str{clockfile};
	    delete $Parms_num{srcra_barycorr};
	    delete $Parms_num{srcdec_barycorr};
	}
    }

    #Check 'srcregionfile' parameter value
    {
	my (%tmp) = (srcregionfile => "",);
	if( &getStrPar(\%tmp, $invokestring)){ return 1;}
	$Parms_str{srcregionfile} = $tmp{srcregionfile};
	
	if ( !&CompUL($Parms_str{srcregionfile}, $Default{DEFAULT}) ) {
	    delete $Parms_str{srcra};
	    delete $Parms_str{srcdec};
	    delete $Parms_num{srcradius};
	}
    }

    #Check 'bkgregionfile' parameter value
    {
	my (%tmp) = (bkgregionfile => "",);
	if( &getStrPar(\%tmp, $invokestring)){ return 1;}
	$Parms_str{bkgregionfile} = $tmp{bkgregionfile};
	
	if ( !&CompUL($Parms_str{bkgregionfile}, $Default{DEFAULT}) ) {
	    delete $Parms_str{bkgra};
	    delete $Parms_str{bkgdec};
	    delete $Parms_num{bkgradius1};
	    delete $Parms_num{bkgradius2};
	}
    }

    #Check 'bkgextract' parameter value
    {
	my (%tmp) = (bkgextract => $Default{'NOTVALDPARBOOL'},);
	if( &getBoolPar(\%tmp, $invokestring)){ return 1;}
	$Parms_bool{bkgextract} = $tmp{bkgextract};
	
	if ( $Parms_bool{bkgextract} =~ /[nN]/ ) {
	    delete $Parms_str{bkgregionfile};
	    delete $Parms_str{bkgra};
	    delete $Parms_str{bkgdec};
	    delete $Parms_num{bkgradius1};
	    delete $Parms_num{bkgradius2};
	}
    }

    # Get FPMA input parameters
    if(&CompUL($Parms_str{instrument},"FPMA")||&CompUL($Parms_str{instrument},"ALL")){

	if( &getStrPar(\%Parms_str_fpma, $invokestring)  ){ return 1;}
	if( &getNumPar(\%Parms_num_fpma, $invokestring)  ){ return 1;}
	if( &getBoolPar(\%Parms_bool_fpma, $invokestring)){ return 1;}

	push @{$Task{instr}},"fpma";
    }

    # Get FPMB input parameters
    if(&CompUL($Parms_str{instrument},"FPMB")||&CompUL($Parms_str{instrument},"ALL")){

	if( &getStrPar(\%Parms_str_fpmb, $invokestring)  ){ return 1;}
	if( &getNumPar(\%Parms_num_fpmb, $invokestring)  ){ return 1;}
	if( &getBoolPar(\%Parms_bool_fpmb, $invokestring)){ return 1;}

	push @{$Task{instr}},"fpmb";
    }

    # Get common parameters
    if( &getStrPar(\%Parms_str, $invokestring)  ){ return 1;}
    if( &getNumPar(\%Parms_num, $invokestring)  ){ return 1;}
    if( &getBoolPar(\%Parms_bool, $invokestring)){ return 1;}
    

    #
    # Update Task global variables
    #
    $Task{chatter} = $Parms_num{chatter};
    
    if ( $Parms_bool{clobber} =~ /[yY]/ ) {
	$Task{clobber} = 1;
    }

  OBSMODESWITCH: {
      if ( &CompUL( $Parms_str{obsmode},"SCIENCE") )      { push @{$Task{obsmode}},"01"; last OBSMODESWITCH; }
      if ( &CompUL( $Parms_str{obsmode},"OCCULTATION") ) { push @{$Task{obsmode}},"02"; last OBSMODESWITCH; }
      if ( &CompUL( $Parms_str{obsmode},"SLEW") )        { push @{$Task{obsmode}},"03"; last OBSMODESWITCH; }
      if ( &CompUL( $Parms_str{obsmode},"SAA") )         { push @{$Task{obsmode}},"04"; last OBSMODESWITCH; }
      if ( &CompUL( $Parms_str{obsmode},"CALIBRATION") ) { push @{$Task{obsmode}},"05"; last OBSMODESWITCH; }
      if ( &CompUL( $Parms_str{obsmode},"SCIENCE_SC") )   { push @{$Task{obsmode}},"06"; last OBSMODESWITCH; }
      if ( &CompUL( $Parms_str{obsmode},"ALL") ) {
	  foreach my $mode (@{$Default{ALLOBSMODES}}) {push @{$Task{obsmode}},$mode;}
	  last OBSMODESWITCH;
      }
      {$Task{errmess} = "Observing mode: '" . $Parms_str{obsmode} . "' not supported"; return 1; }
  }

    if ( &CompUL($Parms_str{stemoutputs}, $Default{DEFAULT}) ) {
	$Task{stemout} = $Parms_str{steminputs};
    }
    else{
	$Task{stemout} = $Parms_str{stemoutputs};
    }


    return 0;

} # GetInputParameters


sub getStrPar{
    my ($strin, $invokestring) = @_;
    my ($par);

    #
    # pquery2 returns the value of the named parameter on
    # stdout, prompting if necessary directly to /dev/tty
    # Any command line arguments must be passed along.
    #
    
    for $par ( sort(keys %$strin) ) {
	# check if parameter already settled
	if ( !$$strin{$par} && $$strin{$par} !~ "0" ) {
	    my ($String) = "";
	    chop($String = qx(pquery2 nupipeline $par $invokestring));
	    if ( !$String && $String !~ "0" ) {
		&PrntChty(3, "$Task{stem}: Error: error running: 'pquery2 nupipeline $par $invokestring'\n");
		return 1;
	    }
	    $$strin{$par} = $String;
	}
    }
    return 0;

} # getStrPar


sub getNumPar{
    my ($strin, $invokestring) = @_;
    my ($par);

    #
    # pquery2 returns the value of the named parameter on
    # stdout, prompting if necessary directly to /dev/tty
    # Any command line arguments must be passed along.
    #
    
    for $par ( sort(keys %$strin) ) {
	# check if parameter already settled
	if ( $$strin{$par} eq $Default{'NOTVALDPARNUMB'} ) {
	    my ($Num) = "";
	    chop($Num = qx(pquery2 nupipeline $par $invokestring));
	    if ( !$Num && $Num !~ 0 ) {
		&PrntChty(3, "$Task{stem}: Error: error running: 'pquery2 nupipeline $par $invokestring'\n");
		return 1;
	    }
	    $$strin{$par} = $Num;
	}
    }
    return 0;

} # getNumPar


sub getBoolPar{
    my ($strin, $invokestring) = @_;
    my ($par);
 
    #
    # pquery2 returns the value of the named parameter on
    # stdout, prompting if necessary directly to /dev/tty
    # Any command line arguments must be passed along.
    #
   
    for $par ( sort(keys %$strin) ) {
	# check if parameter already settled
	if ( $$strin{$par} eq $Default{'NOTVALDPARBOOL'} ) {
	    my ($Bool) = "";
	    chop($Bool = qx(pquery2 nupipeline $par $invokestring));
	    if ( !$Bool ) {
		&PrntChty(3, "$Task{stem}: Error: error running: 'pquery2 nupipeline $par $invokestring'\n");
		return 1;
	    }
	    $$strin{$par} = $Bool;
	}
    }
    return 0;

} # getBoolPar


sub CheckInputParameters {

    if ( $Parms_num{entrystage} <= 0 || $Parms_num{entrystage} > 2 ) {
	&PrntChty(2,"$Task{'stem'}: Error: Input parameter 'entrystage' out of range [1,2].\n");
	return 1;
    }

    if ( $Parms_num{exitstage} <= 0 || $Parms_num{exitstage} > 3 ) {
	&PrntChty(2,"$Task{'stem'}: Error: Input parameter 'exitstage' out of range [1,3].\n");
	return 1;
    }

    if ( $Parms_num{entrystage} > $Parms_num{exitstage} ) {
	&PrntChty(2,"$Task{'stem'}: Error: Input parameter 'entrystage'=$Parms_num{entrystage} larger then 'exitstage'=$Parms_num{exitstage}");
	return 1;
    }

    if ( &CheckInputDirectory ){ return 1;}

    if ( &CheckOutputDirectory ){ return 1;}

    if ( $Parms_str{outdir} eq $Parms_str{indir} ) {
	&PrntChty(2,"$Task{'stem'}: Error: Please do not specify the 'outdir' same as 'indir'\n");
	return 1;
    }

    return 0;

} # CheckInputParameters


sub CheckInputDirectory {
    
    # cut off the last '/'
    $Parms_str{indir} =~ s/\/$// ;
    
    if( !-d $Parms_str{indir} ){
	&PrntChty(2,"$Task{'stem'}: Error: Input Directory '$Parms_str{indir}' not found\n");
	return 1;
    }
    
    return 0;

} # CheckInputDirectory


sub CheckOutputDirectory {
    
    # cut off the last '/'
    $Parms_str{outdir} =~ s/\/$// ;
    
    if( $Parms_str{outdir} !~ /^\// && $Parms_str{outdir} !~ /^\./ ) {
	$Parms_str{outdir} = "./".$Parms_str{outdir};
    }

    if( !-d $Parms_str{outdir} ){
	if( &CreateDir($Parms_str{outdir}) ) { return 1; }
    }
    
    return 0;

} # CheckOutputDirectory


sub InitRun(){
    
    my ($instr, $instrstem, $align);
    my($zipext, $filename);

    no strict;
   
    foreach $instr (@{$Task{instr}}){

	if(&CompUL($instr,"FPMA")){
	    $instrstem = "A";
	}
	else{
	    $instrstem = "B";
	}

	my($infile) = $InFiles{"${instr}_infile"};
	my($hkfile) = $InFiles{"${instr}_hkfile"};


	# Check if Event File exists
	if ( !-f $infile){
	    &PrntChty(3, "$Task{stem}: Error: event file '$infile' not found.\n");
	    return 1;
	}

	# Check if Housekeeping File exists
	if ( !-f $hkfile){
	    &PrntChty(3, "$Task{stem}: Error: housekeeping file '$hkfile' not found.\n");
	    return 1;
	}

	# Load input evt file name into 'EvtFiles' variable

	if ( $Parms_num{entrystage} == 1 ){
	    $EvtFiles{$instr}{lev1name} = $infile;
	    $EvtFiles{$instr}{lev1aname} = $Parms_str{outdir}."/".$Task{stemout}.$instrstem.$Def{LEV1STEM}.$Def{EVTEXT};
	}
	elsif ( $Parms_num{entrystage} == 2 ){
	    $EvtFiles{$instr}{lev1aname} = $infile;
	}
	else{
	    &PrntChty(5, "$Task{stem}: Error: Not a valid 'entrystage' value '$Parms_num{entrystage}'\n");
	    return 1;
	}

	foreach my $mode (@{$Task{obsmode}}){
	    $EvtFiles{$instr}{"lev2cl".$mode."name"} = $Parms_str{outdir}."/".$Task{stemout}.$instrstem.$mode.$Def{LEV2STEM}.$Def{EVTEXT};
	    $OutFiles{$instr}{"gtifile".$mode} = $Parms_str{outdir}."/".$Task{stemout}.$instrstem.$mode.$Def{GTISTEM}.$Def{FITSEXT};
	}

	$EvtFiles{$instr}{nfiles} = 1;

    
	# Get Observation Start Date from the input Evt File
	my ( $StartDate, $StartTime, $teldef );
	&GetEventStartDate($infile,\$StartDate,\$StartTime);
	if ( $Task{status} ) { 
	    return 1; 
	}
	$InData{$instr}{startdate} = $StartDate;
	$InData{$instr}{starttime} = $StartTime;
	
	# Set Teldef file name
	if ( &SetTeldefFileName($instr,\$teldef) ){
	    &PrntChty(3, "$Task{stem}: Error: unable to set teldef file name.\n");
	    return 1;
	}
	$InData{$instr}{teldef} = $teldef;

    } # End -> foreach $instr (@{$Task{instr}})

    use strict;

    $instr = ${$Task{instr}}[0];
    # Set Align file name
    if ( &SetAlignFileName($instr,\$align) ){
	&PrntChty(3, "$Task{stem}: Error: unable to set alignment file name.\n");
	return 1;
    }
    $InData{alignfile} = $align;


    # unzip TLE file if needed
    my($zipext) = substr($InFiles{tlefile},rindex( $InFiles{tlefile}, '.' ));

    if($zipext=~ /(.gz|.Z)$/){
	
	$filename = $Parms_str{outdir}."/".basename($InFiles{tlefile});
	&PrntChty(3,"$Task{stem}: Info: Extracting TLE File '$InFiles{tlefile}' in '$Parms_str{outdir}' output directory\n");

	if (!copy($InFiles{tlefile}, $filename)) {
	    &PrntChty(3,"$Task{stem}: Error: unable to create a local copy of the input TLE file '".$InFiles{tlefile}."' ($!)\n");
	    return 1;
	}
	if ( system ( "gunzip -fq $filename\n" ) ) {
	    if($? != 512){
		&PrntChty(3, "$Task{stem}: Error: running 'gunzip -fq $filename'\n");
		return 1;
	    }
	}

	$filename =~ s/(.gz|.Z)$//;
	$InFiles{tlefile} = $filename;

	push @CleanupList, $InFiles{tlefile};
    }


    return 0;

} # InitRun


sub SetInFiles(){

    my (@filelist);
    my ($instr);
    no strict;
    
    foreach $instr (@{$Task{instr}}){
	
	# infile
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_infile"},$Default{DEFAULT}) ) {
	    $InFiles{"${instr}_infile"} = $Parms_str{indir} . "/" . $InFilesDir{"${instr}_infile"} . "/" . $Parms_str{steminputs} . $InFilesExt{"${instr}_infile"} ;
	    
	    my ($filename) = $InFiles{"${instr}_infile"};
	    @filelist = grep ( /$filename((.gz)|(.tgz))?$/, (glob "$filename*"));
	    if(scalar(@filelist)==1){
		$InFiles{"${instr}_infile"} = $filelist[0];
	    }
	}
	else{
	    $InFiles{"${instr}_infile"} = ${"Parms_str_${instr}"}{"${instr}_infile"};
	}

	# hkfile
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_hkfile"},$Default{DEFAULT}) ) {
	    $InFiles{"${instr}_hkfile"} = $Parms_str{indir} . "/" . $InFilesDir{"${instr}_hkfile"} . "/" . $Parms_str{steminputs} . $InFilesExt{"${instr}_hkfile"} ;
	    
	    my ($filename) = $InFiles{"${instr}_hkfile"};
	    @filelist = grep ( /$filename((.gz)|(.tgz))?$/, (glob "$filename*"));
	    if(scalar(@filelist)==1){
		$InFiles{"${instr}_hkfile"} = $filelist[0];
	    }
	}
	else{
	    $InFiles{"${instr}_hkfile"} = ${"Parms_str_${instr}"}{"${instr}_hkfile"};
	}

	# dispixfile
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_dispixfile"},$Default{DEFAULT}) ) {
	    $InFiles{"${instr}_dispixfile"} = $Parms_str{indir} . "/" . $InFilesDir{"${instr}_dispixfile"} . "/" . $Parms_str{steminputs} . $InFilesExt{"${instr}_dispixfile"} ;
	    
	    my ($filename) = $InFiles{"${instr}_dispixfile"};
	    @filelist = grep ( /$filename((.gz)|(.tgz))?$/, (glob "$filename*"));
	    if(scalar(@filelist)==1){
		$InFiles{"${instr}_dispixfile"} = $filelist[0];
	    }
	}
	else{
	    $InFiles{"${instr}_dispixfile"} = ${"Parms_str_${instr}"}{"${instr}_dispixfile"};
	}

    }

    use strict;


    # attfile
    if ( &CompUL($Parms_str{attfile},$Default{DEFAULT}) ) {
	$InFiles{attfile} = $Parms_str{indir} . "/" . $InFilesDir{attfile} . "/" . $Parms_str{steminputs} . $InFilesExt{attfile} ;

	my ($filename) = $InFiles{attfile};
	@filelist = grep ( /$filename((.gz)|(.tgz))?$/, (glob "$filename*"));
	if(scalar(@filelist)==1){
	    $InFiles{attfile} = $filelist[0];
	}
    }
    else{
	$InFiles{attfile} = $Parms_str{attfile};
    }

    # cebhkfile
    if ( &CompUL($Parms_str{cebhkfile},$Default{DEFAULT}) ) {
	$InFiles{cebhkfile} = $Parms_str{indir} . "/" . $InFilesDir{cebhkfile} . "/" . $Parms_str{steminputs} . $InFilesExt{cebhkfile} ;

	my ($filename) = $InFiles{cebhkfile};
	@filelist = grep ( /$filename((.gz)|(.tgz))?$/, (glob "$filename*"));
	if(scalar(@filelist)==1){
	    $InFiles{cebhkfile} = $filelist[0];
	}
    }
    else{
	$InFiles{cebhkfile} = $Parms_str{cebhkfile};
    }
    
     # chu123hkfile
    if ( &CompUL($Parms_str{chu123hkfile},$Default{DEFAULT}) ) {
	$InFiles{chu123hkfile} = $Parms_str{indir} . "/" . $InFilesDir{chu123hkfile} . "/" . $Parms_str{steminputs} . $InFilesExt{chu123hkfile} ;

	my ($filename) = $InFiles{chu123hkfile};
	@filelist = grep ( /$filename((.gz)|(.tgz))?$/, (glob "$filename*"));
	if(scalar(@filelist)==1){
	    $InFiles{chu123hkfile} = $filelist[0];
	}
    }
    else{
	$InFiles{chu123hkfile} = $Parms_str{chu123hkfile};
    }

    # metrologyfile
    if ( &CompUL($Parms_str{metrologyfile},$Default{DEFAULT}) ) {
	$InFiles{metrologyfile} = $Parms_str{indir} . "/" . $InFilesDir{metrologyfile} . "/" . $Parms_str{steminputs} . $InFilesExt{metrologyfile} ;
 
	my ($filename) = $InFiles{metrologyfile};
	@filelist = grep ( /$filename((.gz)|(.tgz))?$/, (glob "$filename*"));
	if(scalar(@filelist)==1){
	    $InFiles{metrologyfile} = $filelist[0];
	}
    }
    else{
	$InFiles{metrologyfile} = $Parms_str{metrologyfile};
    }

    # inpsdfilecor
    if ( &CompUL($Parms_str{inpsdfilecor},$Default{DEFAULT}) ) {
	$InFiles{inpsdfilecor} = $Parms_str{indir} . "/" . $InFilesDir{inpsdfilecor} . "/" . $Parms_str{steminputs} . $InFilesExt{inpsdfilecor} ;

	my ($filename) = $InFiles{inpsdfilecor};
	@filelist = grep ( /$filename((.gz)|(.tgz))?$/, (glob "$filename*"));
	if(scalar(@filelist)==1){
	    $InFiles{inpsdfilecor} = $filelist[0];
	}
    }
    else{
	$InFiles{inpsdfilecor} = $Parms_str{inpsdfilecor};
    }

    # orbitfile
    if ( &CompUL($Parms_str{orbitfile},$Default{DEFAULT}) ) {
	$InFiles{orbitfile} = $Parms_str{indir} . "/" . $InFilesDir{orbitfile} . "/" . $Parms_str{steminputs} . $InFilesExt{orbitfile} ;

	my ($filename) = $InFiles{orbitfile};
	@filelist = grep ( /$filename((.gz)|(.tgz))?$/, (glob "$filename*"));
	if(scalar(@filelist)==1){
	    $InFiles{orbitfile} = $filelist[0];
	}
    }
    else{
	$InFiles{orbitfile} = $Parms_str{orbitfile};
    }

    # inmastaspectfile
    if ( &CompUL($Parms_str{inmastaspectfile},$Default{DEFAULT}) ) {
	$InFiles{inmastaspectfile} = $Parms_str{indir} . "/" . $InFilesDir{inmastaspectfile} . "/" . $Parms_str{steminputs} . $InFilesExt{inmastaspectfile} ;

	my ($filename) = $InFiles{inmastaspectfile};
	@filelist = grep ( /$filename((.gz)|(.tgz))?$/, (glob "$filename*"));
	if(scalar(@filelist)==1){
	    $InFiles{inmastaspectfile} = $filelist[0];
	}
    }
    else{
	$InFiles{inmastaspectfile} = $Parms_str{inmastaspectfile};
    }

    # tlefile
    if ( &CompUL($Parms_str{tlefile},$Default{DEFAULT}) ) {
	$InFiles{tlefile} = $Parms_str{indir} . "/" . $InFilesDir{tlefile} . "/" . $InFilesExt{tlefile} ;

	my ($filename) = $InFiles{tlefile};
	@filelist = grep ( /$filename\./, (glob "$filename*"));
	if(scalar(@filelist)==1){
	    $InFiles{tlefile} = $filelist[0];
	}
	elsif(scalar(@filelist)>1){
	    &PrntChty(2,"$Task{stem}: Warning: Found more than one TLE file in '$Parms_str{indir}' directory tree\n");

	    my $tlefilesize = 0. ;
	    my $tlefile_useme=$filelist[0];
	    foreach my $thistlefile ( @filelist ) {
		    &PrntChty(2,"$Task{stem}: Found $thistlefile \n");
		    my $thistlefilesize = -s $thistlefile;
#			&PrntChty(2,"$Task{stem}: File size: $thistlefilesize \n");
		    
		    if($thistlefilesize>$tlefilesize){
			    $tlefilesize=$thistlefilesize;
			    $tlefile_useme=$thistlefile;
		    }
	    }

	    &PrntChty(2,"$Task{stem}: $tlefile_useme is the most recent, so using this one.\n");
	    $InFiles{tlefile} = $tlefile_useme;
	    
	    #&PrntChty(2,"$Task{stem}: Error: Found more than one TLE file in '$Parms_str{indir}' directory tree\n");
	    #&PrntChty(2,"$Task{stem}: Error: This case is not supported.\n");
	    #return 1;
	}
    }
    else{
	$InFiles{tlefile} = $Parms_str{tlefile};
    }


    return 0;

} # SetInFiles


sub SetOutFiles(){

    my ($instr, $instrstem);

    # mastaspectfile
    if ( &CompUL($Parms_str{mastaspectfile},$Default{DEFAULT}) ) {
	my ($filename) = $Task{stemout}.$Def{MASTSTEM}.$Def{FITSEXT};
	$OutFiles{mastaspectfile} = $Parms_str{outdir}."/".$filename;
    }
    else{
	$OutFiles{mastaspectfile} = $Parms_str{outdir}."/".$Parms_str{mastaspectfile};
    }

    # outpsdfile
    if ( &CompUL($Parms_str{outpsdfile},$Default{DEFAULT}) ) {
	my ($filename) = $Task{stemout}.$Def{PSDSTEM}.$Def{FITSEXT};
	$OutFiles{outpsdfile} = $Parms_str{outdir}."/".$filename;
    }
    else{
	$OutFiles{outpsdfile} = $Parms_str{outdir}."/".$Parms_str{outpsdfile};
    }
    
    # outpsdfilecor
    if ( &CompUL($Parms_str{outpsdfilecor},$Default{DEFAULT}) ) {
	my ($filename) = $Task{stemout}.$Def{PSDCORRSTEM}.$Def{FITSEXT};
	$OutFiles{outpsdfilecor} = $Parms_str{outdir}."/".$filename;
    }
    else{
	$OutFiles{outpsdfilecor} = $Parms_str{outdir}."/".$Parms_str{outpsdfilecor};
    }

    # outattfile
    if ( &CompUL($Parms_str{outattfile},$Default{DEFAULT}) ) {
	my ($filename) = $Task{stemout}.$Def{ATTSTEM}.$Def{FITSEXT};
	$OutFiles{outattfile} = $Parms_str{outdir}."/".$filename;
    }
    else{
	$OutFiles{outattfile} = $Parms_str{outdir}."/".$Parms_str{outattfile};
    }


    no strict;
    
    foreach $instr (@{$Task{instr}}){
	
	if(&CompUL($instr,"FPMA")){
	    $instrstem = "A";
	}
	else{
	    $instrstem = "B";
	}

	# outbpfile
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_outbpfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem.$Def{BADPIXSTEM}.$Def{FITSEXT};
	    $OutFiles{$instr}{outbpfile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_outbpfile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{outbpfile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{outbpfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_outbpfile"};
	}

	# outhpfile
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_outhpfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem.$Def{HOTPIXSTEM}.$Def{FITSEXT};
	    $OutFiles{$instr}{outhpfile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_outhpfile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{outhpfile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{outhpfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_outhpfile"};
	}

	# outhkfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_outhkfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem.$Def{HKSTEM}.$Def{HKEXT};
	    $OutFiles{$instr}{outhkfile} = $Parms_str{outdir}."/".$filename;
	}
	else{
	    $OutFiles{$instr}{outhkfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_outhkfile"};
	}

	# attorbfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_attorbfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem.$Def{ATTORBEXT};
	    $OutFiles{$instr}{attorbfile} = $Parms_str{outdir}."/".$filename;
	}
	else{
	    $OutFiles{$instr}{attorbfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_attorbfile"};
	}

	# mkffile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_mkffile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem.$Def{MKFSTEM}.$Def{MKFEXT};
	    $OutFiles{$instr}{mkffile} = $Parms_str{outdir}."/".$filename;
	}
	else{
	    $OutFiles{$instr}{mkffile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_mkffile"};
	}

	# optaxisfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_optaxisfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem.$Def{OPTAXISSTEM}.$Def{FITSEXT};
	    $OutFiles{$instr}{optaxisfile} = $Parms_str{outdir}."/".$filename;
	}
	else{
	    $OutFiles{$instr}{optaxisfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_optaxisfile"};
	}

	# det1reffile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_det1reffile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem.$Def{DET1REFSTEM}.$Def{FITSEXT};
	    $OutFiles{$instr}{det1reffile} = $Parms_str{outdir}."/".$filename;
	}
	else{
	    $OutFiles{$instr}{det1reffile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_det1reffile"};
	}

	# expomapfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_expomapfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{EXPOSTEM}.$Def{IMGEXT};
	    $OutFiles{$instr}{expomapfile} = $Parms_str{outdir}."/".$filename;
	}
	else{
	    $OutFiles{$instr}{expomapfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_expomapfile"};
	}

	# lcfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_lcfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{LCSTEM}.$Def{LCEXT};
	    $OutFiles{$instr}{lcfile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_lcfile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{lcfile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{lcfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_lcfile"};
	}

	# phafile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_phafile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{PHASTEM}.$Def{PHAEXT};
	    $OutFiles{$instr}{phafile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_phafile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{phafile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{phafile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_phafile"};
	}

	# bkglcfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_bkglcfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{BKGLCSTEM}.$Def{LCEXT};
	    $OutFiles{$instr}{bkglcfile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_bkglcfile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{bkglcfile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{bkglcfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_bkglcfile"};
	}

	# bkgphafile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_bkgphafile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{BKGPHASTEM}.$Def{PHAEXT};
	    $OutFiles{$instr}{bkgphafile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_bkgphafile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{bkgphafile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{bkgphafile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_bkgphafile"};
	}

	# imagefile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_imagefile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{IMGSTEM}.$Def{IMGEXT};
	    $OutFiles{$instr}{imagefile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_imagefile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{imagefile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{imagefile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_imagefile"};
	}

	# outarffile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_outarffile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{ARFSTEM}.$Def{ARFEXT};
	    $OutFiles{$instr}{outarffile} = $Parms_str{outdir}."/".$filename;
	}
	else{
	    $OutFiles{$instr}{outarffile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_outarffile"};
	}

	# outrmffile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_outrmffile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{RMFSTEM}.$Def{RMFEXT};
	    $OutFiles{$instr}{outrmffile} = $Parms_str{outdir}."/".$filename;
	}
	else{
	    $OutFiles{$instr}{outrmffile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_outrmffile"};
	}

	# det1offsetfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_det1offsetfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{DET1OFFSET}.$Def{FITSEXT};
	    $OutFiles{$instr}{det1offsetfile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_det1offsetfile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{det1offsetfile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{det1offsetfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_det1offsetfile"};
	}

	# aspecthistofile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_aspecthistofile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{ASPHIST}.$Def{FITSEXT};
	    $OutFiles{$instr}{aspecthistofile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_aspecthistofile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{aspecthistofile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{aspecthistofile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_aspecthistofile"};
	}

	# det1instrfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_det1instrfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{DET1MAP}.$Def{IMGEXT};
	    $OutFiles{$instr}{det1instrfile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_det1instrfile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{det1instrfile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{det1instrfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_det1instrfile"};
	}

	# det2instrfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_det2instrfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{DET2MAP}.$Def{IMGEXT};
	    $OutFiles{$instr}{det2instrfile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_det2instrfile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{det2instrfile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{det2instrfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_det2instrfile"};
	}

	# skyinstrfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_skyinstrfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{SKYMAP}.$Def{IMGEXT};
	    $OutFiles{$instr}{skyinstrfile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_skyinstrfile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{skyinstrfile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{skyinstrfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_skyinstrfile"};
	}

	# lcsrccorrfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_lcsrccorrfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{SRCLCCORRSTEM}.$Def{FITSEXT};
	    $OutFiles{$instr}{lcsrccorrfile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_lcsrccorrfile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{lcsrccorrfile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{lcsrccorrfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_lcsrccorrfile"};
	}

	# lcbkgcorrfile	
	if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_lcbkgcorrfile"},$Default{DEFAULT}) ) {
	    my ($filename) = $Task{stemout}.$instrstem."01".$Def{BKGLCCORRSTEM}.$Def{FITSEXT};
	    $OutFiles{$instr}{lcbkgcorrfile} = $Parms_str{outdir}."/".$filename;
	}
	elsif ( &CompUL(${"Parms_str_${instr}"}{"${instr}_lcbkgcorrfile"},$Default{NONE}) ) {
	    $OutFiles{$instr}{lcbkgcorrfile} = "NONE";
	}
	else{
	    $OutFiles{$instr}{lcbkgcorrfile} = $Parms_str{outdir}."/".${"Parms_str_${instr}"}{"${instr}_lcbkgcorrfile"};
	}

    }

    use strict;

    return 0;

} # SetOutFiles


sub SetPointingAndSourceInfo {

    my ($instr, $evtfile); 

    $instr = ${$Task{instr}}[0];
    if(&CompUL($instr,"FPMA")){
	$evtfile = $InFiles{fpma_infile};
    }
    else{
	$evtfile = $InFiles{fpmb_infile};
    }

    &PipelineMessage("Setting Optical Axis Direction");
        
    if ( &CompUL($Parms_str{pntra},"POINT") || &CompUL($Parms_str{pntdec},"POINT") ) {
	&PrntChty(3,"$Task{stem}: Info: 'pntra' and/or 'pntdec' input parameter set to POINT\n");
	&PrntChty(3,"$Task{stem}: Info: getting default S/C direction\n"); 
	
	##############################################
	# Get $Task{ranom} and $Task{decnom} 
	# from the evt file
	##############################################
	
	if ( &GetPntFromExt($evtfile,"EVENTS",undef,\$Task{ranom}, \$Task{decnom}) ){
	    return -1;
	}
	
	&PrntChty(3,"$Task{stem}: Info: Optical Axis   RA : $Task{ranom}(deg)\n"); 
	&PrntChty(3,"$Task{stem}: Info: Optical Axis  DEC : $Task{decnom}(deg)\n"); 
	
	&AddReport(3,"evt: .... Optical Axis   RA from  RA_PNT keyword : $Task{ranom}(deg)\n"); 
	&AddReport(3,"evt: .... Optical Axis  DEC from DEC_PNT keyword : $Task{decnom}(deg)\n"); 
    
    }
    elsif ( &CompUL($Parms_str{pntra},"OBJECT") || &CompUL($Parms_str{pntdec},"OBJECT") ) {
	&PrntChty(3,"$Task{stem}: Info: 'pntra' and/or 'pntdec' input parameter set to OBJECT\n");
	&PrntChty(3,"$Task{stem}: Info: Using OBJECT keywords from $evtfile file\n"); 
	
	##############################################
	# Get $Task{ranom} and $Task{decnom} 
	# from the evt file
	##############################################
	
	if ( &GetObjFromExt($evtfile,"EVENTS",undef,\$Task{ranom}, \$Task{decnom}) ){
	    return -1;
	}
	
	&PrntChty(3,"$Task{stem}: Info: Optical Axis   RA : $Task{ranom}(deg)\n"); 
	&PrntChty(3,"$Task{stem}: Info: Optical Axis  DEC : $Task{decnom}(deg)\n"); 
	
	&AddReport(3,"evt: .... Optical Axis   RA from  RA_OBJ keyword : $Task{ranom}(deg)\n"); 
	&AddReport(3,"evt: .... Optical Axis  DEC from DEC_OBJ keyword : $Task{decnom}(deg)\n");
  
    }
    else {
	&PrntChty(3,"$Task{stem}: Info: 'pntra' and 'pntdec' set by input parameter\n");
	&PrntChty(3,"$Task{stem}: Info: using: 'pntra' = '$Parms_str{pntra}' and 'pntdec' = '$Parms_str{pntdec}'\n");
	&PrntChty(3,"$Task{stem}: Info: as S/C Pointing Direction\n");
	if (!&CheckRa($Parms_str{pntra})) { 
	    &PrntChty(2,"$Task{stem}: ERROR: error on 'pntra' input: '$Parms_str{pntra}'\n");
	    return -1;
	}
	if (!&CheckDec($Parms_str{pntdec})) { 
	    &PrntChty(2,"$Task{stem}: ERROR: error on 'pntdec' input: '$Parms_str{pntdec}'\n");
	    return -1;
	}
	
	########################################
	# Perform convertion to degree if needed
	########################################
	
	$Task{ranom} = &Ra2Deg($Parms_str{pntra});
	$Task{decnom} = &Dec2Deg($Parms_str{pntdec});
	
	&PrntChty(3,"$Task{stem}: Info: Input S/C  RA Direction : $Task{ranom}\n");
	&PrntChty(3,"$Task{stem}: Info: Input S/C DEC Direction : $Task{decnom}\n");
	&AddReport(3,"................. : S/C RA  Direction from input parameter 'pntra' : $Task{ranom}\n");
	&AddReport(3,"................. : S/C DEC Direction from input parameter 'pntdec': $Task{decnom}\n");

    }

    if( &DoStage(3) ){

	if( &CompUL($Parms_str{srcregionfile}, $Default{DEFAULT}) ){

	    &PipelineMessage("Setting source RA and DEC position");
	    
	    if ( &CompUL($Parms_str{srcra},"OBJECT") || &CompUL($Parms_str{srcdec},"OBJECT") ) {
		
		&PrntChty(2,"$Task{stem}: Info: Input parameters 'srcra' and/or 'srcdec' set to 'OBJECT'\n");
		&PrntChty(2,"$Task{stem}: Info: Using OBJECT keywords from $evtfile file\n");
		
		##############################################
		# Get $Task{srcra} and $Task{srcdec} 
		# from the evt file
		##############################################
		
		if ( &GetObjFromExt($evtfile,"EVENTS",undef,\$Task{srcra}, \$Task{srcdec}) ){
		    return -1;
		}
		
		&PrntChty(3,"$Task{stem}: Info: Input  RA Source Position : $Task{srcra}\n");
		&PrntChty(3,"$Task{stem}: Info: Input DEC Source Position : $Task{srcdec}\n");
		&AddReport(3,"evt: .... Source  RA from  RA_OBJ keyword        : $Task{srcra}(deg)\n"); 
		&AddReport(3,"evt: .... Source DEC from DEC_OBJ keyword        : $Task{srcdec}(deg)\n"); 
	    }
	    else {
		
		if (!&CheckRa($Parms_str{srcra})) { 
		    &PrntChty(2,"$Task{stem}: ERROR: error on 'srcra' input: '$Parms_str{srcra}'\n");
		    return -1;
		}
		if (!&CheckDec($Parms_str{srcdec})) { 
		    &PrntChty(2,"$Task{stem}: ERROR: error on 'srcdec' input: '$Parms_str{srcdec}'\n");
		    return -1;
		}
	
		########################################
		# Perform convertion to degree if needed
		########################################
		
		$Task{srcra} = &Ra2Deg($Parms_str{srcra});
		$Task{srcdec} = &Dec2Deg($Parms_str{srcdec});
		
		&PrntChty(3,"$Task{stem}: Info: Input  RA Source Position : $Task{srcra}\n");
		&PrntChty(3,"$Task{stem}: Info: Input DEC Source Position : $Task{srcdec}\n");
		&AddReport(3,"................. : Source RA  from input parameter 'srcra'        : $Task{srcra}\n");
		&AddReport(3,"................. : Source DEC from from input parameter 'srcdec'  : $Task{srcdec}\n");
	    }
	}


	if( &CompUL($Parms_str{bkgregionfile}, $Default{DEFAULT}) ){
	    if ( &CompUL($Parms_str{bkgra},"OBJECT") || &CompUL($Parms_str{bkgdec},"OBJECT") ) {
		
		##############################################
		# Get $Task{bkgra} and $Task{bkgdec} 
		# from the evt file
		##############################################
		if ( &GetObjFromExt($evtfile,"EVENTS",undef,\$Task{bkgra}, \$Task{bkgdec}) ){
		    return -1;
		}
	    }
	    else {
		
		if (!&CheckRa($Parms_str{bkgra})) { 
		    &PrntChty(2,"$Task{stem}: ERROR: error on 'bkgra' input: '$Parms_str{bkgra}'\n");
		    return -1;
		}
		if (!&CheckDec($Parms_str{bkgdec})) { 
		    &PrntChty(2,"$Task{stem}: ERROR: error on 'bkgdec' input: '$Parms_str{bkgdec}'\n");
		    return -1;
		}
	
		########################################
		# Perform convertion to degree if needed
		########################################
		
		$Task{bkgra} = &Ra2Deg($Parms_str{bkgra});
		$Task{bkgdec} = &Dec2Deg($Parms_str{bkgdec});
	    }
	}

    } #if(&DoStage(3)){

    return 0;

} # SetPointingAndSourceInfo


sub DoStage {
    my ( $numstage ) = @_;
    use vars qw (%Task);

    if ( $Parms_num{entrystage} <= $numstage && $Parms_num{exitstage} >= $numstage){

	if($numstage<=2){
	    return 1;
	}
	else{
	    foreach my $mode (@{$Task{obsmode}}){
		if($mode eq "01"){ return 1; }
	    }
	    &PrntChty(3, "$Task{stem}: WARNING: 'SCIENCE' obsmode not processed, Stage III not executed.\n");
	    return 0;
	}
    }

    return 0;

} # DoStage


sub RunStageI {

    # Return $Task{status}:
    #          0 - no errors
    #          1 - errors found: break nupipeline run
    #          2 - empty file generated: do not continue
    #              processing on this file

    my ($instr) = @_;
    my ($instr_uc) = uc($instr);
    my ($InEvtFile) = $EvtFiles{$instr}{lev1name};
    my ($EvtFile)   = $EvtFiles{$instr}{lev1aname};
    my ($ZipEvtFile) = $EvtFile;

    my($zipext) = substr($InEvtFile,rindex( $InEvtFile, '.' ));

    if($zipext=~ /(.gz|.Z)$/){
	$ZipEvtFile = $EvtFile.$zipext; 
    }

    # Copy input Level 1 Event File to Level 1a Calibrated Event File  
    &PrntChty(3,"$Task{stem}: Info: Copying Level 1 Event File '$InEvtFile' in '$ZipEvtFile'\n");
    if (!copy($InEvtFile, $ZipEvtFile)) {
	&PrntChty(3,"$Task{stem}: Unable to create the Level 1a Calibrated Event File '".$ZipEvtFile."'\n");
	&PrntChty(3,"$Task{stem}: from input Level 1 Event File '".$InEvtFile."' ($!)\n");
	$Task{status} = 1;
	return 1;
    }

    # Unzip the file if needed
    if($zipext=~ /(.gz|.Z)$/){
	&PrntChty(3,"$Task{stem}: Info: the file '$ZipEvtFile' is compressed\n");
	&PrntChty(3,"$Task{stem}: Info: Unzip the file to allow FTOOLS processing\n");
	if ( system ( "gunzip -fq $ZipEvtFile\n" ) ) {
	    if($? != 512){
		&PrntChty(3, "$Task{stem}: Error: running 'gunzip -fq $ZipEvtFile'\n");
		$Task{status} = 1;
		return 1;
	    }
	}
    }


    &PipelineStageMsg("$Task{stem}: Stage  I: Calibrating '$EvtFile'");
    &AddReport(3,"$instr_uc: .... Stage    I: Calibrating Level 1 Event File: '$EvtFile'\n");

   
    # Run nuflagbad task
    if ( &RunNuFlagBad($instr,$EvtFile) ) { $Task{status} = 1; return 1; }

     # Run nuhotpix task
    if ( &RunNuHotPix($instr,$EvtFile) ) { $Task{status} = 1; return 1; }   

    # Run nucalcpha task
    if( $Parms_bool{runcalcpha} =~ /[yY]/ ){
	if ( &RunNuCalcPha($instr,$EvtFile) ) { $Task{status} = 1; return 1; }
    }

    # Run nucalcpi task
    if( $Parms_bool{runcalcpi} =~ /[yY]/ ){
	if ( &RunNuCalcPi($instr,$EvtFile) ) { $Task{status} = 1; return 1; }
    }

     # Run nuflagevt task
    if( $Parms_bool{runflagevt} =~ /[yY]/ ){
	if ( &RunNuflagEvt($instr,$EvtFile) ) { $Task{status} = 1; return 1; }   
    }

    # Run nucoord task
    if ( &RunNuCoord($instr,$EvtFile) ) { $Task{status} = 1; return 1; }

    # Update processing keywords
    if ( &UpdateEvtPipeKeys($instr,$EvtFile) ) { $Task{status} = 1; return 1; }


    &PipelineStageMsg("$Task{stem}: Stage  I: '$EvtFile' calibrated.");
    &AddReport(3,"$instr_uc: .... Stage    I: Calibrated Event File: '$EvtFile'\n");
    return 0;

} # RunStageI


sub RunStageII {

    # Return $Task{status}:
    #          0 - no errors
    #          1 - errors found: break nupipeline run

    my ($instr) = @_;
    my ($instr_uc) = uc($instr);
    my ($InEvtFile) = $EvtFiles{$instr}{lev1aname};


    &PipelineStageMsg("$Task{stem}: Stage II: Screening '$InEvtFile'");
    &AddReport(3,"$instr_uc: .... Stage   II: Screening Level 1a Event File: '$InEvtFile'\n");

    # Run nucalcsaa task
    if ( &RunNuCalcSaa($instr,$InEvtFile) ) {
	&AddReport(3,"$instr_uc: ....Stage   II: Error Creating 'outhkfile' output file\n");
	$Task{status} = 1; 
	return 1; 
    }

    # Run nufilter task
    if ( &RunNuFilter($instr) ) {
	&AddReport(3,"$instr_uc: ....Stage   II: Error Creating 'makefilter' output file\n");
	$Task{status} = 1; 
	return 1; 
    }

    # Run nuscreen task
    foreach my $mode (@{$Task{obsmode}}){
	if ( &RunNuScreen($instr,$mode,$InEvtFile) ) {
	    &AddReport(3,"$instr_uc: .... Stage   II: Error Screening '$InEvtFile' file for Observing Mode '$mode'\n");
	    $Task{status} = 1;
	    return 1; 
	}

	if($mode eq "01"){
	    &ReportOutOfPsdTime($instr);
	}
    }

    # Run nusplitsc task
    if(&CompUL($Parms_bool{runsplitsc},"YES")) 
    {
	foreach my $mode (@{$Task{obsmode}})
	{
	    my ($outfile) = $EvtFiles{$instr}{"lev2cl".$mode."name"};

	    if(&CompUL($mode,"06"))
	    {
		if( -f $outfile )
		{
		    if ( &RunNuSplitSc($instr,$mode,$outfile) ) 
		    {
			&AddReport(3,"$instr_uc: .... Stage   II: Error nusplitsc '$InEvtFile' file for Observing Mode '$mode'\n");
			$Task{status} = 1;
			return 1; 
		    }
		}
		else
		{
		    &PrntChty(3, "$Task{stem}: Warning: No Level 2 Observing Mode '$mode' Event File created, skipping nusplitsc run.\n");
		    &AddReport(3,"$instr_uc: .... Stage   II: WARNING: No Level 2 Observing Mode '$mode' Event File created, nusplitsc run not executed.\n");
		}
	    }
	}
    }
#     else
#     {
# 	printf "Skip RunNuSplitSc\n";
#     }

    &PipelineStageMsg("$Task{stem}: Stage II: '$InEvtFile' Screened.");


    # Run nuexpomap task
    foreach my $mode (@{$Task{obsmode}}){
	
	if( ($mode eq "01") && ( $Parms_bool{createexpomap} =~ /[yY]/ )){

	    my ($EvtFileCl) = $EvtFiles{$instr}{lev2cl01name};
	    
	    if( -f $EvtFileCl ){
		&PipelineStageMsg("$Task{stem}: Stage II: Generating '$EvtFileCl' exposure map");
		&AddReport(3,"$instr_uc: .... Stage   II: Generating exposure map on Level 2 Event File: '$EvtFileCl'\n");
	    
		if ( &RunNuExpoMap($instr,$EvtFileCl) ) { 
		    &AddReport(3,"$instr_uc: .... Stage   II: Error Generating exposure map on '$EvtFileCl'\n");
		    $Task{status} = 1; 
		    return 1; 
		}
	    
		&PipelineStageMsg("$Task{stem}: Stage II: '$EvtFileCl' exposure map created.");
		&AddReport(3,"$instr_uc: .... Stage   II: Generated exposure map on Level 2 Event File: '$EvtFileCl'\n");
	    }
	    else{
		&AddReport(3,"$instr_uc: .... Stage   II: WARNING No Sky Exposure Map created for Observing Mode '01' (empty Level 2 Event File)\n");
	    }

	}
    }


    return 0;

} # RunStageII


sub RunStageIII {

    # Return $Task{status}:
    #          0 - no errors
    #          1 - errors found: break nupipeline run

    my ($instr) = @_;
    my ($instr_uc) = uc($instr);
    my ($InEvtFile) = $EvtFiles{$instr}{lev2cl01name};


    if( !-f $InEvtFile ){
	&AddReport(3,"$instr_uc: .... Stage  III: WARNING No products and images generated for Observing Mode '01' (empty Level 2 Event File)\n");
	return 0;
    }

    # Run nuproducts task

    &PipelineStageMsg("$Task{stem}: Stage III: Generating '$InEvtFile' products and images");
    &AddReport(3,"$instr_uc: .... Stage  III: Generating products and images on Level 2 Event File: '$InEvtFile'\n");

    if ( &RunNuProducts($instr,$InEvtFile) ) {
	&AddReport(3,"$instr_uc: .... Stage  III: Error Generating products and images on '$InEvtFile'\n");
	$Task{status} = 1;
	return 1; 
    }

    &PipelineStageMsg("$Task{stem}: Stage III: '$InEvtFile' products and images created.");
    &AddReport(3,"$instr_uc: .... Stage  III: Generated products and images on Level 2 Event File: '$InEvtFile'\n");



    return 0;

} # RunStageIII


sub RunNuMetrology {

    my ( $par, $ret );
    my ( $command, %numetrology );

    %numetrology = (

		metflag       => $Parms_bool{metflag},		  
		metrologyfile => $InFiles{metrologyfile},
		metgridfile   => $Parms_str{metgridfile},
		outpsdfile    => $OutFiles{outpsdfile},
		outpsdfilecor => $OutFiles{outpsdfilecor},
		inpsdfilecor  => $InFiles{inpsdfilecor},
		alignfile     => $InData{alignfile},
		mastaspectfile=> $OutFiles{mastaspectfile},
		psdcal        => $Parms_bool{psdcal},
		chatter       => $Parms_num{chatter},
		clobber       => $Parms_bool{clobber},
		history       => $Parms_bool{history},
		);

    $command = "numetrology";
    for $par ( keys %numetrology ) { $command .= " $par=$numetrology{$par}"; } 

    &RunningSub("RunNuMetrology","numetrology");
    &RunningComm("RunNuMetrology",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuMetrology","numetrology",$command);
        $Task{errmess} = "ERROR running 'numetrology'";
	$Task{status} = 1;
	return 1;
    }

    &SuccessSub("RunNuMetrology","numetrology", "'$OutFiles{mastaspectfile}' mast aspect solution file created.");
    return 0;

} # RunNuMetrology


sub RunNuAttCorr {

    my ( $par, $ret );
    my ( $command, %nuattcorr );

    %nuattcorr = (
		  attfile       => $InFiles{attfile},
		  outattfile    => $OutFiles{outattfile},
		  chuoffsetfile => $Parms_str{chuoffsetfile},
		  chatter       => $Parms_num{chatter},
		  clobber       => $Parms_bool{clobber},
		  history       => $Parms_bool{history},
		);

    $command = "nuattcorr";
    for $par ( keys %nuattcorr ) { $command .= " $par=$nuattcorr{$par}"; } 

    &RunningSub("RunNuAttCorr","nuattcorr");
    &RunningComm("RunNuAttCorr",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuAttCorr","nuattcorr",$command);
        $Task{errmess} = "ERROR running 'nuattcorr'";
	$Task{status} = 1;
	return 1;
    }

    &SuccessSub("RunNuAttCorr","nuattcorr", "'$OutFiles{outattfile}' corrected attitude file created.");
    return 0;

} # RunNuAttCorr


sub RunNuFlagBad {
    my ($instr,$EvtFile) = @_;

    my ( $par, $ret );
    my ( $command, %nuflagbad );
    my ($pid) = getppid();

    my $TmpFile = substr($EvtFile,0,rindex($EvtFile,'.')).".${pid}tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    no strict;
    %nuflagbad = (
		  infile       => $EvtFile,
		  outfile      => $TmpFile,
		  dispixfile   => $InFiles{"${instr}_dispixfile"},
		  bpfile       => ${"Parms_str_${instr}"}{"${instr}_bpfile"},
		  userbpfile   => ${"Parms_str_${instr}"}{"${instr}_userbpfile"},
		  outbpfile    => $OutFiles{$instr}{outbpfile},
		  chatter      => $Parms_num{chatter},
		  clobber      => $Parms_bool{clobber},
		  history      => $Parms_bool{history},
		  );
    use strict;

    $command = "nuflagbad";
    for $par ( keys %nuflagbad ) { $command .= " $par=$nuflagbad{$par}"; } 

    &RunningSub("RunNuFlagBad","nuflagbad");
    &RunningComm("RunNuFlagBad",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuFlagBad","nuflagbad",$command);
        $Task{errmess} = "ERROR running 'nuflagbad'";
	$Task{status} = 1;
	return 1;
    }

    if ( &RenameFile($TmpFile, $EvtFile) ) { return 1; }

    &SuccessSub("RunNuFlagBad","nuflagbad", "'$EvtFile' updated");

    return 0;

} # RunNuFlagBad


sub RunNuHotPix {
    my ($instr,$EvtFile) = @_;

    my ( $par, $ret );
    my ( $command, %nuhotpix );
    my ($pid) = getppid();

    my $TmpFile = substr($EvtFile,0,rindex($EvtFile,'.')).".${pid}tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    no strict;
    %nuhotpix = (
		 infile       => $EvtFile,
		 outfile      => $TmpFile,
		 outhpfile    => $OutFiles{$instr}{outhpfile},
		 binsize      => $Parms_num{hpbinsize},
		 cellsize     => $Parms_num{hpcellsize},
		 impfac       => $Parms_num{impfac},
		 logpos       => $Parms_num{logpos},
		 bthresh      => $Parms_num{bthresh},
		 cleanflick   => $Parms_bool{cleanflick},
		 iterate      => $Parms_bool{hpiterate},
		 chatter      => $Parms_num{chatter},
		 clobber      => $Parms_bool{clobber},
		 history      => $Parms_bool{history},
		  );
    use strict;

    $command = "nuhotpix";
    for $par ( keys %nuhotpix ) { $command .= " $par=$nuhotpix{$par}"; } 

    &RunningSub("RunNuHotPix","nuhotpix");
    &RunningComm("RunNuHotPix",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuHotPix","nuhotpix",$command);
        $Task{errmess} = "ERROR running 'nuhotpix'";
	$Task{status} = 1;
	return 1;
    }

    if ( &RenameFile($TmpFile, $EvtFile) ) { return 1; }

    &SuccessSub("RunNuHotPix","nuhotpix", "'$EvtFile' updated");

    return 0;

} # RunNuHotPix


sub RunNuCalcPha {
    my ($instr,$EvtFile) = @_;

    my ( $par, $ret );
    my ( $command, %nucalcpha );
    my ($pid) = getppid();

    my $TmpFile = substr($EvtFile,0,rindex($EvtFile,'.')).".${pid}tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    no strict;
    %nucalcpha = (
		  infile       => $EvtFile,
		  outfile      => $TmpFile,
		  offsetfile   => ${"Parms_str_${instr}"}{"${instr}_capoffsetfile"},
		  gradefile    => $Parms_str{"gradefile"},
		  phaparfile   => ${"Parms_str_${instr}"}{"${instr}_phaparfile"},
		  evtthr       => ${"Parms_num_${instr}"}{"${instr}_evtthr"},
		  timerise     => ${"Parms_num_${instr}"}{"${instr}_timerise"},
		  cleancols    => $Parms_bool{cleancols},
		  chatter      => $Parms_num{chatter},
		  clobber      => $Parms_bool{clobber},
		  history      => $Parms_bool{history},
		  );
    use strict;

    $command = "nucalcpha";
    for $par ( keys %nucalcpha ) { $command .= " $par=$nucalcpha{$par}"; } 

    &RunningSub("RunNuCalcPha","nucalcpha");
    &RunningComm("RunNuCalcPha",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuCalcPha","nucalcpha",$command);
        $Task{errmess} = "ERROR running 'nucalcpha'";
	$Task{status} = 1;
	return 1;
    }

    if ( &RenameFile($TmpFile, $EvtFile) ) { return 1; }

    &SuccessSub("RunNuCalcPha","nucalcpha", "'$EvtFile' updated");


    return 0;

} # RunNuCalcPha


sub RunNuCalcPi {
    my ($instr,$EvtFile) = @_;

    my ( $par, $ret );
    my ( $command, %nucalcpi );
    my ($pid) = getppid();

    my $TmpFile = substr($EvtFile,0,rindex($EvtFile,'.')).".${pid}tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    no strict;
    %nucalcpi = (
		  infile       => $EvtFile,
		  outfile      => $TmpFile,
		  hkfile       => $InFiles{"${instr}_hkfile"},
		  gainfile     => ${"Parms_str_${instr}"}{"${instr}_gainfile"},
		  clcfile      => ${"Parms_str_${instr}"}{"${instr}_clcfile"},
		  clcfilterfile=> $Parms_str{"clcfilterfile"},
		  temperature  => 5,
		  chatter      => $Parms_num{chatter},
		  clobber      => $Parms_bool{clobber},
		  history      => $Parms_bool{history},
		  );
    use strict;

    $command = "nucalcpi";
    for $par ( keys %nucalcpi ) { $command .= " $par=$nucalcpi{$par}"; } 

    &RunningSub("RunNuCalcPi","nucalcpi");
    &RunningComm("RunNuCalcPi",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuCalcPi","nucalcpi",$command);
        $Task{errmess} = "ERROR running 'nucalcpi'";
	$Task{status} = 1;
	return 1;
    }

    if ( &RenameFile($TmpFile, $EvtFile) ) { return 1; }

    &SuccessSub("RunNuCalcPi","nucalcpi", "'$EvtFile' updated");


    return 0;

} # RunNuCalcPi


sub RunNuflagEvt {
    my ($instr,$EvtFile) = @_;

    my ( $par, $ret );
    my ( $command, %nuflagevt );
    my ($pid) = getppid();

    my $TmpFile = substr($EvtFile,0,rindex($EvtFile,'.')).".${pid}tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    no strict;
    %nuflagevt = (
		  infile       => $EvtFile,
		  outfile      => $TmpFile,
		  depthcutfile => ${"Parms_str_${instr}"}{"${instr}_depthcutfile"},
		  evtcutfile   => ${"Parms_str_${instr}"}{"${instr}_evtcutfile"},
		  chatter      => $Parms_num{chatter},
		  clobber      => $Parms_bool{clobber},
		  history      => $Parms_bool{history},
		  );
    use strict;

    $command = "nuflagevt";
    for $par ( keys %nuflagevt ) { $command .= " $par=$nuflagevt{$par}"; } 

    &RunningSub("RunNuflagEvt","nuflagevt");
    &RunningComm("RunNuflagEvt",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuflagEvt","nuflagevt",$command);
        $Task{errmess} = "ERROR running 'nuflagevt'";
	$Task{status} = 1;
	return 1;
    }

    if ( &RenameFile($TmpFile, $EvtFile) ) { return 1; }

    &SuccessSub("RunNuflagEvt","nuflagevt", "'$EvtFile' updated");


    return 0;

} # RunNuflagEvt


sub RunNuCoord {
    my ($instr,$EvtFile) = @_;

    my ( $par, $ret );
    my ( $command, %nucoord );
    my ($pid) = getppid();

    my $TmpFile = substr($EvtFile,0,rindex($EvtFile,'.')).".${pid}tmp";
    if ( -f $TmpFile ) { unlink ($TmpFile); }

    no strict;
    %nucoord = (
		infile        => $EvtFile,
		outfile       => $TmpFile,
		pixposfile    => ${"Parms_str_${instr}"}{"${instr}_pixposfile"},
		initseed      => $Parms_bool{initseed},
		alignfile     => $InData{alignfile},
		attfile       => $OutFiles{outattfile},
		teldef        => $InData{$instr}{teldef},
		aberration    => $Parms_bool{aberration},
		follow_sun    => $Parms_bool{follow_sun},
		pntra         => $Task{ranom},
		pntdec        => $Task{decnom},
		randomizecoordinator => $Parms_bool{randomizecoordinator},
		seedcoordinator      => $Parms_num{seedcoordinator},
		timemargin           => $Parms_num{timemargin},
		attinterpol          => $Parms_str{attinterpol},
		optaxisfile          => $OutFiles{$instr}{optaxisfile},
		det1reffile          => $OutFiles{$instr}{det1reffile},
		det1xref             => ${"Parms_num_${instr}"}{"${instr}_det1xref"},
		det1yref             => ${"Parms_num_${instr}"}{"${instr}_det1yref"},
		chatter       => $Parms_num{chatter},
		clobber       => $Parms_bool{clobber},
		history       => $Parms_bool{history},
		);
    use strict;


    if( ($Parms_bool{runmetrology} =~ /[yY]/) && ($Parms_num{entrystage} == 1) ){
	$nucoord{mastaspectfile} = $OutFiles{mastaspectfile};
    }
    else{
	$nucoord{mastaspectfile} = $InFiles{inmastaspectfile};
    }

    $command = "nucoord";
    for $par ( keys %nucoord ) { $command .= " $par=$nucoord{$par}"; } 

    &RunningSub("RunNuCoord","nucoord");
    &RunningComm("RunNuCoord",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuCoord","nucoord",$command);
        $Task{errmess} = "ERROR running 'nucoord'";
	$Task{status} = 1;
	return 1;
    }

    if ( &RenameFile($TmpFile, $EvtFile) ) { return 1; }

    &SuccessSub("RunNuCoord","nucoord", "'$EvtFile' updated");


    return 0;

} # RunNuCoord


sub RunNuCalcSaa {
    my ($instr,$InEvtFile) = @_;

    my ( $par, $ret );
    my ( $command, %nucalcsaa );

    no strict;
    %nucalcsaa = (
		 hkfile                => $InFiles{"${instr}_hkfile"},
		 orbitfile             => $InFiles{orbitfile},
		 evtfile               => $InEvtFile,
		 outfile               => $OutFiles{$instr}{outhkfile},
		 saaparfile            => $Parms_str{saaparfile},
		 saamode               => $Parms_str{saamode},
		 tentacle              => $Parms_bool{tentacle},
		 evtexpr               => "\"$Parms_str{hkevtexpr}\"",
		 saacalc               => $Parms_num{saacalc},
		 optimizedrms          => $Parms_num{optimizedrms},
		 tentaclerms           => $Parms_num{tentaclerms},
		 eliminatesource       => $Parms_bool{eliminatesource},
		 sourcethr             => $Parms_num{sourcethr},
		 tentacleregcut        => $Parms_bool{tentacleregcut},	
		 optimizedsanitychecks => "yes",
		 tentaclesanitychecks  => "yes",
		 chatter               => $Parms_num{chatter},
		 clobber               => $Parms_bool{clobber},
		 history               => $Parms_bool{history},
		 );
    use strict;

    $command = "nucalcsaa";
    for $par ( keys %nucalcsaa ) { $command .= " $par=$nucalcsaa{$par}"; } 
    
    &RunningSub("RunNuCalcSaa","nucalcsaa");
    &RunningComm("RunNuCalcSaa",$command);
    
    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuCalcSaa","nucalcsaa",$command);
        $Task{errmess} = "ERROR running 'nucalcsaa'";
	$Task{status} = 1;
	return 1;
    }

    &SuccessSub("RunNuCalcSaa","nucalcsaa", "'$OutFiles{$instr}{mkffile}' filter file created.");

    return 0;

} # RunNuCalcSaa


sub RunNuFilter {
    my ($instr) = @_;

    my ( $par, $ret );
    my ( $command, %nufilter );


    no strict;
    %nufilter = (
		 hkfile         => $OutFiles{$instr}{outhkfile},
		 cebhkfile      => $InFiles{cebhkfile},
		 attfile        => $OutFiles{outattfile},
		 orbitfile      => $InFiles{orbitfile},
		 outdir         => $Parms_str{outdir},
		 teldef         => $InData{$instr}{teldef},
		 attorbfile     => $OutFiles{$instr}{attorbfile},
		 preconfigfile  => $Parms_str{preconfigfile},
		 tlemode        => $Parms_str{tlemode},
		 tlefile        => $InFiles{tlefile},
		 leapfile       => $Parms_str{leapfile},
		 rigfile        => $Parms_str{rigfile},
		 origin         => $Parms_str{origin},
		 interval       => $Parms_num{interval},
		 pntra          => $Task{ranom},
		 pntdec         => $Task{decnom},
		 mkfconfigfile  => $Parms_str{mkfconfigfile},
		 mkffile        => $OutFiles{$instr}{mkffile},
		 nonulls        => $Parms_bool{nonulls},
		 gtiexpr        => "\"$Parms_str{mkfgtiexpr}\"",
		 chatter        => $Parms_num{chatter},
		 clobber        => $Parms_bool{clobber},
		 history        => $Parms_bool{history},
		 );


    if( ($Parms_bool{runmetrology} =~ /[yY]/) && ($Parms_num{entrystage} == 1) && ($Parms_bool{metflag} =~ /[yY]/) ){
	$nufilter{psdcorfile} = $OutFiles{outpsdfilecor};
    }
    else{
	$nufilter{psdcorfile} = $InFiles{inpsdfilecor};
    }

    $command = "nufilter";
    for $par ( keys %nufilter ) { $command .= " $par=$nufilter{$par}"; } 

    &RunningSub("RunNuFilter","nufilter");
    &RunningComm("RunNuFilter",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuFilter","nufilter",$command);
        $Task{errmess} = "ERROR running 'nufilter'";
	$Task{status} = 1;
	return 1;
    }

    &SuccessSub("RunNuFilter","nufilter", "'$OutFiles{$instr}{mkffile}' filter file created.");

    use strict;


    return 0;

} # RunNuFilter


sub RunNuScreen {
    my ($instr,$mode,$infile) = @_;

    my ($instr_uc) = uc($instr);
    my ( $outfile, $gtifile, $strmode, $gtiexpr);
    my ( $par, $ret );
    my ( $command, %nuscreen );
 
    no strict;
   
    $outfile = $EvtFiles{$instr}{"lev2cl".$mode."name"};
    $gtifile = $OutFiles{$instr}{"gtifile".$mode};
    $strmode = $Task{obsmodename}{$mode};
    
    if(!$outfile || !$gtifile){
	&PrntChty(3, "$Task{stem}: Error: unable to define outfile ('$outfile') and/or gtifile ('$gtifile') nuscreen input parameters.\n");
	$Task{errmess} = "ERROR checking 'nuscreen' input parameters";
	$Task{status} = 1;
	return 1;
    }

    $gtiexpr =  $Parms_str{"gtiexpr${mode}"};
    if ( !&CompUL($gtiexpr,$Default{DEFAULT}) && !&CompUL($gtiexpr,$Default{NONE}) ) {
	$gtiexpr =~ s/^\"//;
	$gtiexpr =~ s/\"$//;
	$gtiexpr = "\"$gtiexpr\"";
    }


    %nuscreen = (
		 infile         =>  $infile,
		 gtiscreen      =>  $Parms_bool{gtiscreen},
		 evtscreen      =>  $Parms_bool{evtscreen},
		 gtiexpr        =>  $gtiexpr,
		 gradeexpr      =>  $Parms_str{gradeexpr},
		 statusexpr     =>  "\"".$Parms_str{statusexpr}."\"",
		 createattgti   =>  $Parms_bool{createattgti},
		 createinstrgti =>  $Parms_bool{createinstrgti},
		 outdir         =>  $Parms_str{outdir},
		 obsmode        =>  "\"$strmode\"",
		 hkfile         =>  $InFiles{"${instr}_hkfile"},
		 mkffile        =>  $OutFiles{$instr}{mkffile},
		 usrgtifile     =>  $Parms_str{usrgtifile},
		 hkrangefile    =>  ${"Parms_str_${instr}"}{"${instr}_hkrangefile${mode}"},
		 evtrangefile   =>  ${"Parms_str_${instr}"}{"${instr}_evtrangefile"},
		 depthcut       =>  $Parms_str{depthcut},
		 timecol        =>  $Parms_str{timecol},
		 gtiext         =>  $Parms_str{gtiext},
		 gtifile        =>  $gtifile,
		 outfile        =>  $outfile,
		 cleancols      =>  $Parms_bool{cleancols},
		 cleanup        =>  $Parms_bool{cleanup},
		 chatter        =>  $Parms_num{chatter},
		 clobber        =>  $Parms_bool{clobber},
		 history        =>  $Parms_bool{history},
		 );

    if ( !&CompUL($nuscreen{gtiexpr}, $Default{DEFAULT}) ) {
	delete $nuscreen{hkrangefile};
	delete $nuscreen{createattgti};
	delete $nuscreen{createinstrgti};
    }

    if ( &CompUL($nuscreen{gtiexpr}, $Default{NONE}) ) {
	delete $nuscreen{mkffile};
	delete $nuscreen{gtifile};
    }

    if ( !&CompUL($nuscreen{statusexpr}, $Default{DEFAULT}) &&  !&CompUL($nuscreen{gradeexpr}, $Default{DEFAULT}) ) {
	delete $nuscreen{evtrangefile};
    }

    if ( $nuscreen{evtscreen}=~/[nN]/ ) {
	delete $nuscreen{gradeexpr};
	delete $nuscreen{statusexpr};
    }


    $command = "nuscreen";
    for $par ( keys %nuscreen ) { $command .= " $par=$nuscreen{$par}"; } 
   
    &RunningSub("RunNuScreen","nuscreen");
    &RunningComm("RunNuScreen",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuScreen","nuscreen",$command);
        $Task{errmess} = "ERROR running 'nuscreen'";
	$Task{status} = 1;
	return 1;
    }

    if( -f $outfile ){
	&AddReport(3,"$instr_uc: .... Stage   II: Created Filtered Level 2 Event File '$outfile' for Observing Mode '$mode'\n");
	&SuccessSub("RunNuScreen","nuscreen", "Filtered Level 2 Event File '$outfile' created (Observing Mode '$mode').");
    }
    else{
	&AddReport(3,"$instr_uc: .... Stage   II: WARNING No Filtered Level 2 Event File created for Observing Mode '$mode'\n");
	&SuccessSub("RunNuScreen","nuscreen", "WARNING No Level 2 Event File created (Observing Mode '$mode').");
    }

    use strict;


    return 0;

} # RunNuScreen

sub RunNuSplitSc {
    my ($instr,$mode,$infile) = @_;

    my ( $par, $ret );
    my ( $command, %nusplitsc );

    no strict;
    
    %nusplitsc = (
		 stemout         =>  $Parms_str{stemoutputs},
		 hkfile          =>  $InFiles{"${instr}_hkfile"},
		 chu123hkfile    =>  $InFiles{chu123hkfile},
		 infile          =>  $infile,
		 outdir          =>  $Parms_str{outdir},
		 splitmode       =>  $Parms_str{splitmode},
		 chu123rangefile =>  $Parms_str{chu123rangefile},
		 timecut         =>  $Parms_bool{timecut},
		 cleanup         =>  $Parms_bool{cleanup},
		 chatter         =>  $Parms_num{chatter},
		 clobber         =>  $Parms_bool{clobber},
		 history         =>  $Parms_bool{history},
		 );
    
    $command = "nusplitsc";
    for $par ( keys %nusplitsc ) { $command .= " $par=$nusplitsc{$par}"; } 

#     print "---->Running nusplitsc: $command\n";
    
    &RunningSub("RunNuSplitSc","nusplitsc");
    &RunningComm("RunNuSplitSc",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuSplitSc","nusplitsc",$command);
        $Task{errmess} = "ERROR running 'nusplitsc'";
	$Task{status} = 1;
	return 1;
    }
    
    
    use strict;
    
    return 0;

} # RunNuSplitSc

sub RunNuExpoMap {
    my ($instr,$infile) = @_;

    my ( $par, $ret );
    my ( $command, %nuexpomap, $stemout );

    no strict;
    %nuexpomap = (
		  infile         => $infile,
		  pixposfile     => ${"Parms_str_${instr}"}{"${instr}_pixposfile"},
		  alignfile      => $InData{alignfile},
		  attfile        => $OutFiles{outattfile},
		  teldef         => $InData{$instr}{teldef},
		  instrprobmapfile => ${"Parms_str_${instr}"}{"${instr}_instrprobmapfile"},
		  vignfile       => ${"Parms_str_${instr}"}{"${instr}_vignfile"},
		  indet2instrfile=> "NONE",
		  aberration     => $Parms_bool{aberration},
		  vignflag       => $Parms_bool{expovignflag},
		  energy         => $Parms_num{energy},
		  det1reffile    => $OutFiles{$instr}{det1reffile},
		  pixbin         => $Parms_num{pixbin},
		  skyx           => $Parms_num{skyx},
		  skyy           => $Parms_num{skyy},
		  skysize        => $Parms_num{skysize},
		  offsetfile     => $OutFiles{$instr}{det1offsetfile},
		  aspecthistofile=> $OutFiles{$instr}{aspecthistofile}, 
		  det1instrfile  => $OutFiles{$instr}{det1instrfile},
		  det2instrfile  => $OutFiles{$instr}{det2instrfile},
		  skyinstrfile   => $OutFiles{$instr}{skyinstrfile},
		  expomapfile    => $OutFiles{$instr}{expomapfile},
		  percent        => $Parms_num{percent},
		  initseed       => $Parms_bool{initseed},
		  chatter        => $Parms_num{chatter},
		  clobber        => $Parms_bool{clobber},
		  history        => $Parms_bool{history},
		  );


    if( $Parms_num{entrystage} == 2){
	$nuexpomap{det1reffile} = ${"Parms_str_${instr}"}{"${instr}_indet1reffile"};
    }
    else{
	$nuexpomap{det1reffile} = $OutFiles{$instr}{det1reffile};
    }

    if( ($Parms_bool{runmetrology} =~ /[yY]/) && ($Parms_num{entrystage}==1) ){
	$nuexpomap{mastaspectfile} = $OutFiles{mastaspectfile};
    }
    else{
	$nuexpomap{mastaspectfile} = $InFiles{inmastaspectfile};
    }

    use strict;

    $command = "nuexpomap";
    for $par ( keys %nuexpomap ) { $command .= " $par=$nuexpomap{$par}"; } 

    &RunningSub("RunNuExpoMap","nuexpomap");
    &RunningComm("RunNuExpoMap",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuExpoMap","nuexpomap",$command);
        $Task{errmess} = "ERROR running 'nuexpomap'";
	$Task{status} = 1;
	return 1;
    }

    &SuccessSub("RunNuExpoMap","nuexpomap", "Exposure map generated for '$infile'");

    return 0;

} # RunNuExpoMap


sub RunNuProducts {
    my ($instr,$infile) = @_;

    my ( $par, $ret );
    my ( $command, %nuproducts, $stemout );
 
    if(&CompUL($instr,"FPMA")){
	$stemout = $Task{stemout}."A01";
    }
    else{
	$stemout = $Task{stemout}."B01";
    }

    no strict;
    %nuproducts = (
		   indir          => $Parms_str{outdir},
		   instrument     => $instr,
		   steminputs     => $Task{stemout},
		   outdir         => $Parms_str{outdir},
		   stemout        => $stemout,
		   infile         => $infile,
		   srcregionfile  => $Parms_str{srcregionfile},
		   bkgextract     => $Parms_bool{bkgextract},
		   bkgregionfile  => $Parms_str{bkgregionfile},
		   srcra          => $Task{srcra},
		   srcdec         => $Task{srcdec},
		   srcradius      => $Parms_num{srcradius}, 
		   bkgra          => $Task{bkgra},
		   bkgdec         => $Task{bkgdec},		    
		   bkgradius1     => $Parms_num{bkgradius1},	    
		   bkgradius2     => $Parms_num{bkgradius2},
		   binsize        => $Parms_num{lcbinsize},
		   lcfile         => basename($OutFiles{$instr}{lcfile}),
		   phafile        => basename($OutFiles{$instr}{phafile}),
		   bkglcfile      => basename($OutFiles{$instr}{bkglcfile}),
		   bkgphafile     => basename($OutFiles{$instr}{bkgphafile}),		    
		   imagefile      => basename($OutFiles{$instr}{imagefile}),
		   usrgtifile     => $Parms_str{productsgtifile},
		   plotdevice     => $Parms_str{plotdevice},
		   pilow          => $Parms_num{pilow},
		   pihigh         => $Parms_num{pihigh},
		   correctlc      => $Parms_bool{correctlc},
		   hkfile         => $OutFiles{$instr}{outhkfile},
		   lcenergy       => $Parms_num{lcenergy},
		   lcpsfflag      => $Parms_bool{lcpsfflag},
		   lcexpoflag     => $Parms_bool{lcexpoflag},
		   lcvignflag     => $Parms_bool{lcvignflag},
		   lcsrccorrfile  => basename($OutFiles{$instr}{lcsrccorrfile}),
		   lcbkgcorrfile  => basename($OutFiles{$instr}{lcbkgcorrfile}),
		   runmkarf       => $Parms_bool{runmkarf},
		   outarffile     => basename($OutFiles{$instr}{outarffile}),
		   offaxisfile    => "NONE",
		   offaxishisto   => "NONE",
		   apstophisto    => "NONE",
		   grhisto        => "NONE",
		   pixposfile     => ${"Parms_str_${instr}"}{"${instr}_pixposfile"},
		   alignfile      => $InData{alignfile},
		   attfile        => $OutFiles{outattfile},
		   teldef         => $InData{$instr}{teldef},
		   instrprobmapfile => ${"Parms_str_${instr}"}{"${instr}_instrprobmapfile"},
		   aberration     => $Parms_bool{aberration},
		   pixbin         => $Parms_num{pixbin},
		   inarffile      => ${"Parms_str_${instr}"}{"${instr}_inarffile"},
		   grppsffile     => ${"Parms_str_${instr}"}{"${instr}_grppsffile"},
		   psfdir         => ${"Parms_str_${instr}"}{"${instr}_psfdir"},
		   psffile        => ${"Parms_str_${instr}"}{"${instr}_psffile"},
		   vignfile       => ${"Parms_str_${instr}"}{"${instr}_vignfile"},
		   apstopcorrfile => ${"Parms_str_${instr}"}{"${instr}_apstopcorrfile"},
		   grcorrfile     => ${"Parms_str_${instr}"}{"${instr}_grcorrfile"},
		   detabscorrfile => ${"Parms_str_${instr}"}{"${instr}_detabscorrfile"},
		   psfflag        => $Parms_bool{psfflag},
		   vignflag       => $Parms_bool{arfvignflag},
		   apstopflag     => $Parms_bool{arfapstopflag},
		   grflag         => $Parms_bool{arfgrflag},
		   detabsflag     => $Parms_bool{arfdetabsflag},
		   extended       => $Parms_bool{extended},
		   phibin         => $Parms_num{phibin},
		   apstopphibin   => $Parms_num{apstopphibin},
		   grphibin       => $Parms_num{grphibin},
		   boxsize        => $Parms_num{boxsize},
		   pilowarf       => $Parms_num{pilowarf},
		   pihigharf      => $Parms_num{pihigharf},
		   flatflagarf    => $Parms_bool{flatflagarf},
		   cutmaps        => $Parms_bool{cutmaps},
		   percent        => $Parms_num{percent},
		   orbitfile      => $InFiles{orbitfile},
		   barycorr       => $Parms_bool{barycorr},
		   clockfile      => $Parms_str{clockfile},
		   srcra_barycorr => $Parms_num{srcra_barycorr},
		   srcdec_barycorr=> $Parms_num{srcdec_barycorr},
		   outfile        => "DEFAULT",
		   usrgtibarycorr => $Parms_bool{productsgtibarycorr},
		   runmkrmf       => $Parms_bool{runmkrmf},
		   outrmffile     => basename($OutFiles{$instr}{outrmffile}),
		   grprmffile     => ${"Parms_str_${instr}"}{"${instr}_grprmffile"},
		   rmfdir         => ${"Parms_str_${instr}"}{"${instr}_rmfdir"},
		   cmprmf         => $Parms_bool{cmprmf},
		   runbackscale   => $Parms_bool{runbackscale},
		   rungrppha      => "no",
		   initseed       => $Parms_bool{initseed},
		   cleanup        => $Parms_bool{cleanup},
		   chatter        => $Parms_num{chatter},
		   clobber        => $Parms_bool{clobber},
		   history        => $Parms_bool{history},
		 );


    if ( !&CompUL($Parms_str{srcregionfile}, $Default{DEFAULT}) ) {
	delete $nuproducts{srcra};
	delete $nuproducts{srcdec};
	delete $nuproducts{srcradius};
    }

    if ( !&CompUL($Parms_str{bkgregionfile}, $Default{DEFAULT}) ) {
	delete $nuproducts{bkgra};
	delete $nuproducts{bkgdec};
	delete $nuproducts{bkgradius1};
	delete $nuproducts{bkgradius2};
    }

    if ( $Parms_bool{bkgextract} =~ /[nN]/ ) {
	delete $nuproducts{bkgregionfile};
	delete $nuproducts{bkgra};
	delete $nuproducts{bkgdec};
	delete $nuproducts{bkgradius1};
	delete $nuproducts{bkgradius2};
    }

    if( ($Parms_bool{runmetrology} =~ /[yY]/) && ($Parms_num{entrystage}==1) ){
	$nuproducts{mastaspectfile} = $OutFiles{mastaspectfile};
    }
    else{
	$nuproducts{mastaspectfile} = $InFiles{inmastaspectfile};
    }

    if( $Parms_num{entrystage} == 2){
	$nuproducts{optaxisfile} = ${"Parms_str_${instr}"}{"${instr}_inoptaxisfile"};
	$nuproducts{det1reffile} = ${"Parms_str_${instr}"}{"${instr}_indet1reffile"};
    }
    else{
	$nuproducts{optaxisfile} = $OutFiles{$instr}{optaxisfile};
	$nuproducts{det1reffile} = $OutFiles{$instr}{det1reffile};
    }

    if ( $Parms_bool{correctlc} =~ /[nN]/ ) {
	delete $nuproducts{hkfile};
    }

    if ( $Parms_bool{runmkarf} =~ /[nN]/ ) {
	delete $nuproducts{outarffile};
	delete $nuproducts{optaxisfile};
	delete $nuproducts{mastaspectfile};
	delete $nuproducts{attfile};
	delete $nuproducts{det1reffile};
    }

    if ( $Parms_bool{barycorr} =~ /[nN]/ ) {
	delete $nuproducts{orbitfile};
	delete $nuproducts{outfile};
	delete $nuproducts{clockfile};
	delete $nuproducts{srcra_barycorr};
	delete $nuproducts{srcdec_barycorr};
    }

    use strict;

    $command = "nuproducts";
    for $par ( keys %nuproducts ) { $command .= " $par=$nuproducts{$par}"; } 

    &RunningSub("RunNuProducts","nuproducts");
    &RunningComm("RunNuProducts",$command);

    $ret = 0;
    $ret = system( $command );

    if ( $ret != 0 ) {
	&ErrorComm("RunNuProducts","nuproducts",$command);
        $Task{errmess} = "ERROR running 'nuproducts'";
	$Task{status} = 1;
	return 1;
    }

    &SuccessSub("RunNuProducts","nuproducts", " '$infile' products and images created.");

    return 0;

} # RunNuProducts


sub UpdateEvtPipeKeys {
    my ($instr,$EvtFile) = @_;
   
    my ($fptr,$status) = (0,0);
    my ($softver,$nuver,$caldbver);

    chop( $nuver=`nuversion`);
    chop( $softver=`fversion`);
    $softver = "Hea_${softver}_${nuver}";
 

    # retrieve CALDB version
    if( &GetCaldbVersion(\$caldbver) ) {
	$caldbver = "-";
	&PrntChty(2,"$Task{stem}: Warning: unable to retrieve CALDB version, 'CALDBVER' keyword will be set to '$caldbver'\n");
	&PrntChty(4,"$Task{stem}: Warning: '$Task{errmess}'\n");
	$Task{errmess} = "";
	$Task{status} = 0;
    }

    # open fits file
    fits_open_file($fptr,$EvtFile,READWRITE,$status);
    if ($status) {
	&PrntChty(3, "$Task{stem}: Error: unable to open '$EvtFile' file.");
	return 1;
    }

    # update 'SOFTVER' keyword
    fits_update_key($fptr,TSTRING,'SOFTVER',$softver,"HEASoft/NuSTAR software version", $status);
    if ( $status ) {
	&PrntChty(3, "$Task{stem}: Error: cannot update keyword 'SOFTVER' of '$EvtFile' file");
	goto UpdateEvtPipeKeys_end;
    }

    # update 'CALDBVER' keyword
    fits_update_key($fptr,TSTRING,'CALDBVER',$caldbver,"CALDB index version", $status);
    if ( $status ) {
	&PrntChty(3, "$Task{stem}: Error: cannot update keyword 'CALDBVER' of '$EvtFile' file");
	goto UpdateEvtPipeKeys_end;
    }

    # update current HDU checksum
    fits_write_chksum($fptr,$status);
    if ( $status ) {
	&PrntChty(3, "$Task{stem}: Error: cannot update HDU checksum of file '$EvtFile'");
	 goto UpdateEvtPipeKeys_end;
    }
    
    # move to 'EVENTS' extension
    fits_movnam_hdu($fptr,ANY_HDU,"EVENTS",0,$status);
    if ($status) {
	&PrntChty(3, "$Task{stem}: Error: cannot move into '$EvtFile' file, extension 'EVENTS'");
	goto UpdateEvtPipeKeys_end;
    }

    # update 'SOFTVER' keyword
    fits_update_key($fptr,TSTRING,'SOFTVER',$softver,"HEASoft/NuSTAR software version", $status);
    if ( $status ) {
	&PrntChty(3, "$Task{stem}: Error: cannot update keyword 'SOFTVER' of '$EvtFile' file");
	goto UpdateEvtPipeKeys_end;
    }

    # update 'CALDBVER' keyword
    fits_update_key($fptr,TSTRING,'CALDBVER',$caldbver,"CALDB index version", $status);
    if ( $status ) {
	&PrntChty(3, "$Task{stem}: Error: cannot update keyword 'CALDBVER' of '$EvtFile' file");
	goto UpdateEvtPipeKeys_end;
    }

    # update current HDU checksum
    fits_write_chksum($fptr,$status);
    if ( $status ) {
	&PrntChty(3, "$Task{stem}: Error: cannot update HDU checksum of file '$EvtFile'");
	 goto UpdateEvtPipeKeys_end;
    }


    # close fits file
    if ( $fptr ) {
	$status = 0;
	fits_close_file($fptr,$status);
	if ( $status ) { 
	    &PrntChty(3, "$Task{stem}: Error: cannot close '$EvtFile' event file");
	    return 1;
	}
    }

    return 0;


  UpdateEvtPipeKeys_end:

    # close fits file
    if ( $fptr ) {
	$status = 0;
	fits_close_file($fptr,$status);
    }

    return 1;


} # UpdateEvtPipeKeys


sub SetTeldefFileName(){
    my ($instr,$teldef) = @_;

    no strict;
   
    if ( &CompUL(${"Parms_str_${instr}"}{"${instr}_teldef"},$Default{CALDB}) ) {

	# Get Teldef File Name
	my ($refa,$refb)  = &CallQuzcif("TELDEF", $InData{$instr}{startdate}, $InData{$instr}{starttime}, "-", 1, uc($instr), "-");
	if ( $Task{status} ) {
	    &PrntChty(4,"$Task{stem}: Error: cannot retieve Teldef file name from CALDB\n");
	    return 1;
	}
	if ( $#{$refa}> 0 ) {
	    &PrntChty(2,"$Task{stem}: Error: found more then 1 Teldef CALDB file\n");
	    return 1;
	}
	else {
	    $$teldef = @$refa[0];
	}
    }
    else{
	$$teldef = ${"Parms_str_${instr}"}{"${instr}_teldef"};
    }

    use strict;

    return 0;

} # SetTeldefFileName


sub SetAlignFileName(){
    my ($instr,$align) = @_;
  
    if ( &CompUL($Parms_str{alignfile},$Default{CALDB}) ) {

	# Get Alignment File Name
	my ($refa,$refb)  = &CallQuzcif("ALIGNMENT", $InData{$instr}{startdate}, $InData{$instr}{starttime}, "type.eq.systems", 1, "FPM", "-");
	if ( $Task{status} ) {
	    &PrntChty(4,"$Task{stem}: Error: cannot retieve Alignment file name from CALDB\n");
	    return 1;
	}
	if ( $#{$refa}> 0 ) {
	    &PrntChty(2,"$Task{stem}: Error: found more then 1 Alignment CALDB file\n");
	    return 1;
	}
	else {
	    $$align = @$refa[0];
	}
    }
    else{
	$$align = $Parms_str{alignfile};
    }


    return 0;

} # SetAlignFileName


sub ReportOutOfPsdTime(){

    my ($instr) = @_;
    my ($instr_uc) = uc($instr);
    my ($InEvtFile) = $EvtFiles{$instr}{lev2cl01name};
    my ($psdout_exposure);
    my $checkexist = 1;
    

    if( -f $InEvtFile ){

	&GetKeyword ( $InEvtFile, "EVENTS", undef, "NUPSDOUT", \$psdout_exposure, $checkexist);

	if ( $Task{status} ) { 
	    &PrntChty(2,"$Task{stem}: Warning: 'NUPSDOUT' keyword not found in $InEvtFile file\n");
	    $Task{status} = 0;
	}
	else{
	    if( $psdout_exposure>0 ){
		$psdout_exposure = sprintf("%.1f",$psdout_exposure);
		&AddReport(3,"$instr_uc: .... Stage   II: ****************************************************************************************************************\n");
		&AddReport(3,"$instr_uc: .... Stage   II: **  WARNING Metrology laser spots out of calibrated PSD grid for ONTIME=$psdout_exposure seconds for Observing Mode '01'\n");
		&AddReport(3,"$instr_uc: .... Stage   II: ****************************************************************************************************************\n");

	    }
	}

    }

} # ReportOutOfPsdTime
